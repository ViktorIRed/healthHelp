/*!
 * Диаграмма.js
 * http://chartjs.org/
 * Версия: 2.7.2
 *
 * Авторские права 2018 Chart.js Участники
 * Выпущено по лицензии MIT
 * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Chart = f()}})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Не удалось найти модуль '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
/* Лицензия Массачусетского технологического института */
var colorNames = require(6);

модуль.экспорты = {
   получитьRgba: получитьRgba,
   получитьHsla: получитьHsla,
   получитьRgb: получитьRgb,
   получитьHsl: получитьHsl,
   получитьHwb: ​​получитьHwb,
   получитьАльфа: получитьАльфа,

   hexString: шестнадцатеричнаяСтрока,
   rgbString: rgbString,
   rgbaString: rgbaString,
   процентСтрока: процентСтрока,
   процентнаяСтрока: процентнаяСтрока,
   hslString: hslString,
   hslaString: hslaString,
   hwbString: hwbString,
   ключевое слово: ключевое слово
}

функция getRgba(строка) {
   если (!строка) {
      возвращаться;
   }
   var abbr = /^#([a-fA-F0-9]{3})$/i,
       шестнадцатеричное = /^#([a-fA-F0-9]{6})$/i,
       rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
       за = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
       ключевое слово = /(\w+)/;

   вар rgb = [0, 0, 0],
       а = 1,
       совпадение = строка.совпадение(аббр);
   если (совпадение) {
      совпадение = совпадение[1];
      для (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i] + match[i], 16);
      }
   }
   иначе если (соответствие = строка.соответствие(шестнадцатеричное)) {
      совпадение = совпадение[1];
      для (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
      }
   }
   иначе если (соответствие = строка.соответствие(rgba)) {
      для (var i = 0; i < rgb.length; i++) {
         rgb[i] = parseInt(match[i + 1]);
      }
      а = parseFloat(match[4]);
   }
   иначе если (соответствие = строка.соответствие(за)) {
      для (var i = 0; i < rgb.length; i++) {
         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      а = parseFloat(match[4]);
   }
   иначе если (соответствие = строка.соответствие(ключевое слово)) {
      если (match[1] == "прозрачный") {
         вернуть [0, 0, 0, 0];
      }
      rgb = colorNames[match[1]];
      если (!rgb) {
         возвращаться;
      }
   }

   для (var i = 0; i < rgb.length; i++) {
      rgb[i] = масштаб(rgb[i], 0, 255);
   }
   если (!а && а != 0) {
      а = 1;
   }
   еще {
      а = масштаб(а, 0, 1);
   }
   rgb[3] = а;
   вернуть rgb;
}

функция getHsla(строка) {
   если (!строка) {
      возвращаться;
   }
   var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\ s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)? \)/;
   вар совпадение = string.match(hsl);
   если (совпадение) {
      вар альфа = parseFloat(match[4]);
      var h = масштаб(parseInt(match[1]), 0, 360),
          s = масштаб (parseFloat (match [2]), 0, 100),
          l = масштаб (parseFloat (match[3]), 0, 100),
          а = масштаб (isNaN(альфа)? 1: альфа, 0, 1);
      вернуть [ч, с, л, а];
   }
}

функция getHwb(строка) {
   если (!строка) {
      возвращаться;
   }
   var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s *,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\ )/;
   вар match = string.match(hwb);
   если (совпадение) {
    вар альфа = parseFloat(match[4]);
      var h = масштаб(parseInt(match[1]), 0, 360),
          w = масштаб (parseFloat (match [2]), 0, 100),
          b = масштаб(parseFloat(match[3]), 0, 100),
          а = масштаб (isNaN(альфа)? 1: альфа, 0, 1);
      вернуть [ч, в, б, а];
   }
}

функция getRgb(строка) {
   var rgba = getRgba(строка);
   вернуть rgba && rgba.slice(0, 3);
}

функция getHsl(строка) {
  var hsla = getHsla(строка);
  вернуть hsla && hsla.slice(0, 3);
}

функция getAlpha(строка) {
   var vals = getRgba(строка);
   если (значения) {
      возвращаемые значения[3];
   }
   иначе если (vals = getHsla(string)) {
      возвращаемые значения[3];
   }
   иначе если (vals = getHwb(string)) {
      возвращаемые значения[3];
   }
}

// генераторы
функция hexString(rgb) {
   вернуть "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
              + hexDouble(rgb[2]);
}

функция rgbString(rgba, альфа) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      вернуть rgbaString(rgba, alpha);
   }
   вернуть "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
}

функция rgbaString(rgba, альфа) {
   если (альфа === не определено) {
      альфа = (rgba[3] !== не определено ? rgba[3] : 1);
   }
   вернуть "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
           + ", " + альфа + ")";
}

функция процентСтрока(rgba, альфа) {
   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
      вернуть процентную строку (rgba, alpha);
   }
   var r = Math.round(rgba[0]/255 * 100),
       g = Матем.округление(rgba[1]/255 * 100),
       b = Матем.округление(rgba[2]/255 * 100);

   вернуть "rgb(" + r + "%, " + g + "%, " + b + "%)";
}

функция процентная_строка(rgba, альфа) {
   var r = Math.round(rgba[0]/255 * 100),
       g = Матем.округление(rgba[1]/255 * 100),
       b = Матем.округление(rgba[2]/255 * 100);
   вернуть "rgba(" + r + "%, " + g + "%, " + b + "%, " + (альфа || rgba[3] || 1) + ")";
}

функция hslString(hsla, альфа) {
   если (альфа < 1 || (hsla[3] && hsla[3] < 1)) {
      вернуть hslaString(hsla, alpha);
   }
   вернуть "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
}

функция hslaString(hsla, альфа) {
   если (альфа === не определено) {
      альфа = (hsla[3] !== не определено ? hsla[3] : 1);
   }
   вернуть "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
           + альфа + ")";
}

// hwb немного отличается от rgb(a) и hsl(a), поскольку не имеет синтаксиса, специфичного для альфа-канала
// (hwb имеет необязательный параметр alpha и 1 является значением по умолчанию)
функция hwbString(hwb, альфа) {
   если (альфа === не определено) {
      альфа = (hwb[3] !== не определено ? hwb[3] : 1);
   }
   return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
           + (альфа !== не определено && альфа !== 1 ? ", " + альфа : "") + ")";
}

ключевое слово функции (rgb) {
  вернуть reverseNames[rgb.slice(0, 3)];
}

// помощники
функция масштабирования(число, мин, макс) {
   вернуть Math.min(Math.max(min, num), max);
}

функция hexDouble(число) {
  вар стр = num.toString(16).toUpperCase();
  вернуть (str.length < 2) ? "0" + str : str;
}


//создаем список обратных названий цветов
var reverseNames = {};
для (имя переменной в colorNames) {
   reverseNames[colorNames[name]] = имя;
}

},{"6":6}],3:[function(require,module,exports){
/* Лицензия Массачусетского технологического института */
var convert = require(5);
переменная строка = require(2);

var Цвет = функция (obj) {
	если (объект_экземпляр_цвета) {
		вернуть объект;
	}
	если (!(этот экземпляр цвета)) {
		вернуть новый Цвет(obj);
	}

	это.действительно = ложь;
	это.значения = {
		rgb: [0, 0, 0],
		hsl: [0, 0, 0],
		вчс: [0, 0, 0],
		hwb: [0, 0, 0],
		cmyk: [0, 0, 0, 0],
		альфа: 1
	};

	// анализ аргумента Color()
	вар вальс;
	если (тип объекта === 'строка') {
		vals = string.getRgba(obj);
		если (значения) {
			this.setValues('rgb', vals);
		} иначе если (vals = string.getHsla(obj)) {
			this.setValues('hsl', vals);
		} иначе если (vals = string.getHwb(obj)) {
			this.setValues('hwb', vals);
		}
	} иначе если (тип объекта === 'объект') {
		vals = объект;
		если (vals.r !== не определено || vals.red !== не определено) {
			this.setValues('rgb', vals);
		} иначе если (vals.l !== не определено || vals.lightness !== не определено) {
			this.setValues('hsl', vals);
		} иначе если (vals.v !== не определено || vals.value !== не определено) {
			this.setValues('hsv', vals);
		} иначе если (vals.w !== не определено || vals.whiteness !== не определено) {
			this.setValues('hwb', vals);
		} иначе если (vals.c !== не определено || vals.cyan !== не определено) {
			this.setValues('cmyk', vals);
		}
	}
};

Цвет.прототип = {
	isValid: функция () {
		вернуть это.действительно;
	},
	rgb: функция () {
		вернуть this.setSpace('rgb', аргументы);
	},
	hsl: функция () {
		вернуть this.setSpace('hsl', аргументы);
	},
	hsv: функция () {
		вернуть this.setSpace('hsv', аргументы);
	},
	hwb: функция () {
		вернуть this.setSpace('hwb', аргументы);
	},
	cmyk: функция () {
		вернуть this.setSpace('cmyk', аргументы);
	},

	rgbArray: функция () {
		вернуть это.значения.rgb;
	},
	hslArray: функция () {
		вернуть this.values.hsl;
	},
	hsvArray: функция () {
		вернуть this.values.hsv;
	},
	hwbArray: функция () {
		значения переменной = this.values;
		если (значения.альфа !== 1) {
			вернуть значения.hwb.concat([значения.альфа]);
		}
		возвращаемые значения.hwb;
	},
	cmykArray: функция () {
		вернуть this.values.cmyk;
	},
	rgbaArray: функция () {
		значения переменной = this.values;
		возвращать значения.rgb.concat([значения.альфа]);
	},
	hslaArray: функция () {
		значения переменной = this.values;
		вернуть значения.hsl.concat([значения.альфа]);
	},
	альфа: функция (val) {
		если (значение === не определено) {
			вернуть это.значения.альфа;
		}
		this.setValues('альфа', значение);
		верните это;
	},

	красный: функция (знач) {
		вернуть this.setChannel('rgb', 0, val);
	},
	зеленый: функция (val) {
		вернуть this.setChannel('rgb', 1, val);
	},
	синий: функция (val) {
		вернуть this.setChannel('rgb', 2, val);
	},
	оттенок: функция (значение) {
		если (значение) {
			значение %= 360;
			значение = значение <0? 360 + значение: значение;
		}
		вернуть this.setChannel('hsl', 0, val);
	},
	насыщенность: функция (val) {
		вернуть this.setChannel('hsl', 1, val);
	},
	легкость: функция (val) {
		вернуть this.setChannel('hsl', 2, val);
	},
	насыщенностьv: функция (val) {
		вернуть this.setChannel('hsv', 1, val);
	},
	белизна: функция (val) {
		вернуть this.setChannel('hwb', 1, val);
	},
	чернота: функция (val) {
		вернуть this.setChannel('hwb', 2, val);
	},
	значение: функция (знач) {
		вернуть this.setChannel('hsv', 2, val);
	},
	голубой: функция (val) {
		вернуть this.setChannel('cmyk', 0, val);
	},
	пурпурный: функция (val) {
		вернуть this.setChannel('cmyk', 1, val);
	},
	желтый: функция (val) {
		вернуть this.setChannel('cmyk', 2, val);
	},
	черный: функция (val) {
		вернуть this.setChannel('cmyk', 3, val);
	},

	hexString: функция () {
		вернуть строку.hexString(this.values.rgb);
	},
	rgbString: функция () {
		вернуть строку.rgbString(эти.значения.rgb, эти.значения.альфа);
	},
	rgbaString: функция () {
		вернуть строку.rgbaString(эти.значения.rgb, эти.значения.альфа);
	},
	процентСтрока: функция () {
		вернуть строку.percentString(эти.значения.rgb, эти.значения.альфа);
	},
	hslString: функция () {
		вернуть строку.hslString(эти.значения.hsl, эти.значения.альфа);
	},
	hslaString: функция () {
		вернуть строку.hslaString(эти.значения.hsl, эти.значения.альфа);
	},
	hwbString: функция () {
		вернуть строку.hwbString(эти.значения.hwb, эти.значения.альфа);
	},
	ключевое слово: функция () {
		вернуть строку.ключевое_слово(это.значения.rgb, это.значения.альфа);
	},

	rgbNumber: функция () {
		var rgb = это.значения.rgb;
		вернуть (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
	},

	светимость: функция () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = это.значения.rgb;
		var lum = [];
		для (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0,03928) ? chan / 12,92 : Math.pow(((chan + 0,055) / 1,055), 2,4);
		}
		вернуть 0,2126 * люм[0] + 0,7152 * люм[1] + 0,0722 * люм[2];
	},

	контраст: функция (цвет2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = эта.люминесценция();
		var lum2 = color2.яркость();
		если (люм1 > люм2) {
			возврат (люм1 + 0,05) / (люм2 + 0,05);
		}
		возврат (люм2 + 0,05) / (люм1 + 0,05);
	},

	уровень: функция (цвет2) {
		var contrastRatio = этот.контраст(цвет2);
		если (коэффициент контрастности >= 7,1) {
			вернуть «ААА»;
		}

		возврат (contrastRatio >= 4.5) ? 'AA' : '';
	},

	темный: функция () {
		// Уравнение YIQ из http://24ways.org/2010/calculating-color-contrast
		var rgb = это.значения.rgb;
		вар yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		возврат yiq < 128;
	},

	свет: функция () {
		вернуть !этот.темный();
	},

	отрицание: функция () {
		var rgb = [];
		для (var i = 0; i < 3; i++) {
			rgb[i] = 255 - эти.значения.rgb[i];
		}
		this.setValues('rgb', rgb);
		верните это;
	},

	облегчить: функция (соотношение) {
		var hsl = this.values.hsl;
		hsl[2] += hsl[2] * отношение;
		this.setValues('hsl', hsl);
		верните это;
	},

	затемнить: функция (соотношение) {
		var hsl = this.values.hsl;
		hsl[2] -= hsl[2] * отношение;
		this.setValues('hsl', hsl);
		верните это;
	},

	насыщать: функция (соотношение) {
		var hsl = this.values.hsl;
		hsl[1] += hsl[1] * отношение;
		this.setValues('hsl', hsl);
		верните это;
	},

	обесцвечивание: функция (соотношение) {
		var hsl = this.values.hsl;
		hsl[1] -= hsl[1] * отношение;
		this.setValues('hsl', hsl);
		верните это;
	},

	отбеливание: функция (соотношение) {
		var hwb = это.значения.hwb;
		hwb[1] += hwb[1] * отношение;
		this.setValues('hwb', hwb);
		верните это;
	},

	почернеть: функция (соотношение) {
		var hwb = это.значения.hwb;
		hwb[2] += hwb[2] * отношение;
		this.setValues('hwb', hwb);
		верните это;
	},

	оттенки серого: функция () {
		var rgb = это.значения.rgb;
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		вар val = rgb[0] * 0,3 + rgb[1] * 0,59 + rgb[2] * 0,11;
		this.setValues('rgb', [значение, значение, значение]);
		верните это;
	},

	яснее: функция (соотношение) {
		var alpha = это.значения.альфа;
		this.setValues('альфа', альфа - (альфа * отношение));
		верните это;
	},

	непрозрачный: функция (соотношение) {
		var alpha = это.значения.альфа;
		this.setValues('альфа', альфа + (альфа * отношение));
		верните это;
	},

	поворот: функция (градусы) {
		var hsl = this.values.hsl;
		var оттенок = (hsl[0] + градусы) % 360;
		hsl[0] = оттенок < 0 ? 360 + оттенок : оттенок;
		this.setValues('hsl', hsl);
		верните это;
	},

	/**
	 * Перенесено из реализации sass на языке C
	 * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
	 */
	смешать: функция (mixinColor, вес) {
		var color1 = это;
		var color2 = mixinColor;
		var p = вес === не определено ? 0.5 : вес;

		вар w = 2 * p - 1;
		var a = цвет1.альфа() - цвет2.альфа();

		вар w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2,0;
		переменная w2 = 1 - w1;

		вернуть это
			.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue()
			)
			.альфа(цвет1.альфа() * p + цвет2.альфа() * (1 - p));
	},

	toJSON: функция () {
		вернуть this.rgb();
	},

	клон: функция () {
		// ПРИМЕЧАНИЕ(SB): использование node-clone создает зависимость от Buffer при использовании браузера,
		// делая финальную сборку слишком большой для встраивания в Chart.js. Так что давайте сделаем это вручную,
		// предполагая, что значения для клонирования представляют собой одномерные массивы, содержащие только числа,
		// за исключением «альфа», которое является числом.
		var result = new Color();
		источник переменной = this.values;
		var target = result.values;
		значение переменной, тип;

		для (var prop в исходном коде) {
			если (источник.имеетСобственноеСвойство(свойство)) {
				значение = источник[свойство];
				тип = ({}).toString.call(значение);
				если (тип === '[объект Массив]') {
					цель[свойство] = значение.срез(0);
				} иначе если (тип === '[номер объекта]') {
					цель[свойство] = значение;
				} еще {
					console.error('неожиданное значение цвета:', value);
				}
			}
		}

		вернуть результат;
	}
};

Цвет.прототип.пространства = {
	rgb: ['красный', 'зеленый', 'синий'],
	hsl: ['оттенок', 'насыщенность', 'яркость'],
	hsv: ['оттенок', 'насыщенность', 'значение'],
	hwb: ['оттенок', 'белизна', 'чернота'],
	cmyk: ['голубой', 'пурпурный', 'желтый', 'черный']
};

Цвет.прототип.макс = {
	РГБ: [255, 255, 255],
	hsl: [360, 100, 100],
	ВЧС: [360, 100, 100],
	hwb: [360, 100, 100],
	cmyk: [100, 100, 100, 100]
};

Color.prototype.getValues ​​= функция (пробел) {
	значения переменной = this.values;
	var vals = {};

	для (var i = 0; i < пробел.длина; i++) {
		vals[пробел.charAt(i)] = значения[пробел][i];
	}

	если (значения.альфа !== 1) {
		vals.a = значения.альфа;
	}

	// {р: 255, г: 255, б: 255, а: 0,4}
	возврат значений;
};

Color.prototype.setValues ​​= функция (пробел, значения) {
	значения переменной = this.values;
	var пробелы = это.пробелы;
	var maxes = this.maxes;
	вар альфа = 1;
	вар i;

	это.действительно = правда;

	если (пробел === 'альфа') {
		альфа = вальс;
	} иначе если (vals.length) {
		// [10, 10, 10]
		значения[пробел] = vals.slice(0, пробел.length);
		альфа = vals[пробел.длина];
	} иначе если (vals[space.charAt(0)] !== не определено) {
		// {р: 10, г: 10, б: 10}
		для (i = 0; i < пробел.длина; i++) {
			значения[пробел][i] = значения[пробел.charAt(i)];
		}

		альфа = vals.a;
	} иначе если (vals[spaces[space][0]] !== не определено) {
		// {красный: 10, зеленый: 10, синий: 10}
		var chans = пробелы[пробел];

		для (i = 0; i < пробел.длина; i++) {
			значения[пробел][i] = значения[каналы[i]];
		}

		альфа = vals.альфа;
	}

	значения.альфа = Math.макс(0, Math.мин(1, (альфа === не определено ? значения.альфа : альфа)));

	если (пробел === 'альфа') {
		вернуть ложь;
	}

	var ограничен;

	// ограничить значения пространства перед преобразованием всех значений
	для (i = 0; i < пробел.длина; i++) {
		capped = Math.max(0, Math.min(макс[пробел][i], значения[пробел][i]));
		значения[пробел][i] = Math.round(ограничено);
	}

	// преобразовать во все остальные цветовые пространства
	для (var sname в пробелах) {
		если (sname !== пробел) {
			значения[имя_файла] = конвертировать[пробел][имя_файла](значения[пробел]);
		}
	}

	вернуть истину;
};

Color.prototype.setSpace = функция (пробел, аргументы) {
	var vals = args[0];

	если (значения === неопределено) {
		// цвет.rgb()
		вернуть this.getValues(пробел);
	}

	// цвет.rgb(10, 10, 10)
	если (typeof vals === 'number') {
		vals = Массив.прототип.срез.вызов(args);
	}

	this.setValues(пробел, значения);
	верните это;
};

Color.prototype.setChannel = функция (пробел, индекс, значение) {
	var svalues ​​= this.values[пробел];
	если (значение === не определено) {
		// цвет.красный()
		вернуть svalues[индекс];
	} иначе если (val === svalues[index]) {
		// цвет.красный(цвет.красный())
		верните это;
	}

	// цвет.красный(100)
	svalues[индекс] = значение;
	this.setValues(пространство, svalues);

	верните это;
};

если (тип окна !== 'не определен') {
	окно.Цвет = Цвет;
}

module.exports = Цвет;

},{"2":2,"5":5}],4:[function(require,module,exports){
/* Лицензия Массачусетского технологического института */

модуль.экспорты = {
  rgb2hsl: rgb2hsl,
  rgb2hsv: rgb2hsv,
  rgb2hwb: rgb2hwb,
  rgb2cmyk: rgb2cmyk,
  rgb2ключевое_слово: rgb2ключевое_слово,
  rgb2xyz: rgb2xyz,
  rgb2lab: rgb2lab,
  rgb2lch: rgb2lch,

  hsl2rgb: hsl2rgb,
  hsl2hsv: hsl2hsv,
  hsl2hwb: hsl2hwb,
  hsl2cmyk: hsl2cmyk,
  hsl2ключевое_слово: hsl2ключевое_слово,

  hsv2rgb: hsv2rgb,
  hsv2hsl: hsv2hsl,
  hsv2hwb: hsv2hwb,
  hsv2cmyk: hsv2cmyk,
  hsv2ключевое_слово: hsv2ключевое_слово,

  hwb2rgb: hwb2rgb,
  hwb2hsl: hwb2hsl,
  hwb2hsv: hwb2hsv,
  hwb2cmyk: hwb2cmyk,
  hwb2keyword: hwb2keyword,

  cmyk2rgb: cmyk2rgb,
  cmyk2hsl: cmyk2hsl,
  cmyk2hsv: cmyk2hsv,
  cmyk2hwb: cmyk2hwb,
  cmyk2keyword: cmyk2keyword,

  ключевое слово2rgb: ключевое слово2rgb,
  ключевое слово2hsl: ключевое слово2hsl,
  ключевое слово2hsv: ключевое слово2hsv,
  ключевое слово2hwb: ключевое слово2hwb,
  ключевое слово2cmyk: ключевое слово2cmyk,
  ключевое слово2lab: ключевое слово2lab,
  ключевое слово2xyz: ключевое слово2xyz,

  xyz2rgb: xyz2rgb,
  xyz2lab: xyz2lab,
  xyz2lch: xyz2lch,

  лаб2ксуз: лаб2ксуз,
  lab2rgb: lab2rgb,
  lab2lch: lab2lch,

  lch2lab: lch2lab,
  lch2xyz: lch2xyz,
  lch2rgb: lch2rgb
}


функция rgb2hsl(rgb) {
  вар r = rgb[0]/255,
      г = rgb[1]/255,
      б = rgb[2]/255,
      мин = Матем.мин(r, g, b),
      макс = Матем.макс(r, g, b),
      дельта = макс - мин,
      ч, с, л;

  если (макс == мин)
    ч = 0;
  иначе если (r == макс)
    h = (g - b) / дельта;
  иначе если (g == макс)
    h = 2 + (b - r) / дельта;
  иначе если (b == макс)
    h = 4 + (r - g)/ дельта;

  h = Матем.мин(h * 60, 360);

  если (h < 0)
    ч += 360;

  л = (мин + макс) / 2;

  если (макс == мин)
    с = 0;
  иначе если (л <= 0,5)
    s = дельта / (макс + мин);
  еще
    s = дельта / (2 - макс - мин);

  вернуть [ч, с * 100, л * 100];
}

функция rgb2hsv(rgb) {
  вар р = rgb[0],
      г = rgb[1],
      б = rgb[2],
      мин = Матем.мин(r, g, b),
      макс = Матем.макс(r, g, b),
      дельта = макс - мин,
      ч, с, в;

  если (макс == 0)
    с = 0;
  еще
    s = (дельта/макс * 1000)/10;

  если (макс == мин)
    ч = 0;
  иначе если (r == макс)
    h = (g - b) / дельта;
  иначе если (g == макс)
    h = 2 + (b - r) / дельта;
  иначе если (b == макс)
    h = 4 + (r - g) / дельта;

  h = Матем.мин(h * 60, 360);

  если (h < 0)
    ч += 360;

  v = ((макс / 255) * 1000) / 10;

  вернуть [ч, с, в];
}

функция rgb2hwb(rgb) {
  вар р = rgb[0],
      г = rgb[1],
      б = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1/255 * Матем.мин(r, Матем.мин(g, b)),
      b = 1 - 1/255 * Math.max(r, Math.max(g, b));

  вернуть [ч, ш * 100, б * 100];
}

функция rgb2cmyk(rgb) {
  вар r = rgb[0] / 255,
      г = rgb[1] / 255,
      б = rgb[2] / 255,
      с, м, у, к;

  k = Матем.мин(1 - r, 1 - g, 1 - b);
  с = (1 - г - к) / (1 - к) || 0;
  м = (1 - г - к) / (1 - к) || 0;
  у = (1 - b - k) / (1 - k) || 0;
  вернуть [c * 100, m * 100, y * 100, k * 100];
}

функция rgb2keyword(rgb) {
  вернуть обратныеКлючевыеСлова[JSON.stringify(rgb)];
}

функция rgb2xyz(rgb) {
  вар r = rgb[0] / 255,
      г = rgb[1] / 255,
      б = rgb[2] / 255;

  // предположим sRGB
  r = r > 0,04045 ? Math.pow(((r + 0,055) / 1,055), 2,4) : (r / 12,92);
  g = g > 0,04045 ? Math.pow(((g + 0,055) / 1,055), 2,4) : (g / 12,92);
  b = b > 0,04045 ? Math.pow(((b + 0,055) / 1,055), 2,4) : (b / 12,92);

  вар х = (г * 0,4124) + (г * 0,3576) + (б * 0,1805);
  var y = (r*0,2126)+(g*0,7152)+(b*0,0722);
  вар z = (r*0,0193)+(g*0,1192)+(b*0,9505);

  вернуть [x * 100, y * 100, z * 100];
}

функция rgb2lab(rgb) {
  вар xyz = rgb2xyz(rgb),
        х = хyz[0],
        у = хуz[1],
        z = xyz[2],
        л, а, б;

  х /= 95,047;
  у /= 100;
  z /= 108,883;

  x = x > 0,008856 ? Math.pow(x, 1/3) : (7,787 * x) + (16 / 116);
  y = y > 0,008856 ? Math.pow(y, 1/3) : (7,787 * y) + (16 / 116);
  г = г > 0,008856 ? Math.pow(z, 1/3): (7,787 * z) + (16/116);

  л = (116 * у) - 16;
  а = 500 * (х - у);
  б = 200 * (у - z);

  вернуть [л, а, б];
}

функция rgb2lch(аргументы) {
  вернуть lab2lch(rgb2lab(args));
}

функция hsl2rgb(hsl) {
  вар h = hsl[0] / 360,
      с = hsl[1] / 100,
      л = hsl[2] / 100,
      t1, t2, t3, rgb, val;

  если (с == 0) {
    значение = l * 255;
    возврат [значение, значение, значение];
  }

  если (л < 0,5)
    t2 = l * (1 + s);
  еще
    t2 = л + с - л * с;
  t1 = 2 * l - t2;

  rgb = [0, 0, 0];
  для (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * - (i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;

    если (6 * t3 < 1)
      val = t1 + (t2 – t1) * 6 * t3;
    иначе если (2 * t3 < 1)
      значение = t2;
    иначе если (3 * t3 < 2)
      val = t1 + (t2 – t1) * (2/3 – t3) * 6;
    еще
      значение = t1;

    rgb[i] = значение * 255;
  }

  вернуть rgb;
}

функция hsl2hsv(hsl) {
  вар h = hsl[0],
      с = hsl[1] / 100,
      л = hsl[2] / 100,
      св, в;

  если(л === 0) {
      // нет необходимости делать расчет на черном
      // также позволяет избежать ошибки деления на 0
      вернуть [0, 0, 0];
  }

  л *= 2;
  с *= (л <= 1) ? л : 2 - л;
  v = (л + с) / 2;
  св = (2 * с) / (л + с);
  вернуть [h, sv * 100, v * 100];
}

функция hsl2hwb(аргументы) {
  вернуть rgb2hwb(hsl2rgb(args));
}

функция hsl2cmyk(аргументы) {
  вернуть rgb2cmyk(hsl2rgb(args));
}

функция hsl2keyword(аргументы) {
  вернуть rgb2keyword(hsl2rgb(args));
}


функция hsv2rgb(hsv) {
  вар h = hsv[0] / 60,
      с = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;

  var f = h - Math.floor(h),
      р = 255 * v * (1 - s),
      q = 255 * v * (1 - (с * ф)),
      т = 255 * в * (1 - (с * (1 - ф))),
      v = 255 * v;

  переключатель(привет) {
    случай 0:
      вернуть [v, t, p];
    случай 1:
      вернуть [q, v, p];
    случай 2:
      вернуть [п, в, т];
    случай 3:
      вернуть [p, q, v];
    случай 4:
      вернуть [т, п, в];
    случай 5:
      вернуть [v, p, q];
  }
}

функция hsv2hsl(hsv) {
  вар h = hsv[0],
      с = hsv[1] / 100,
      v = hsv[2] / 100,
      сл, л;

  л = (2 - с) * v;
  сл = с * в;
  сл /= (л <= 1) ? л : 2 - л;
  сл = сл || 0;
  л /= 2;
  вернуть [h, sl * 100, l * 100];
}

функция hsv2hwb(аргументы) {
  вернуть rgb2hwb(hsv2rgb(args))
}

функция hsv2cmyk(аргументы) {
  вернуть rgb2cmyk(hsv2rgb(args));
}

функция hsv2keyword(аргументы) {
  вернуть rgb2keyword(hsv2rgb(args));
}

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
функция hwb2rgb(hwb) {
  вар h = hwb[0] / 360,
      wh = hwb[1] / 100,
      бл = hwb[2] / 100,
      отношение = wh + bl,
      и, в, ж, н;

  // wh + bl не может быть > 1
  если (соотношение > 1) {
    wh /= отношение;
    bl /= отношение;
  }

  i = Матем.этаж(6 * h);
  в = 1 - бл;
  f = 6 * h - i;
  если ((я и 0x01) != 0) {
    ф = 1 - ф;
  }
  n = wh + f * (v - wh); // линейная интерполяция

  переключатель (я) {
    по умолчанию:
    случай 6:
    случай 0: г = в; г = н; б = бел; перерыв;
    случай 1: r = n; g = v; b = wh; перерыв;
    случай 2: r = wh; g = v; b = n; перерыв;
    случай 3: r = wh; g = n; b = v; перерыв;
    случай 4: r = n; g = wh; b = v; перерыв;
    случай 5: r = v; g = wh; b = n; перерыв;
  }

  возврат [r * 255, g * 255, b * 255];
}

функция hwb2hsl(аргументы) {
  вернуть rgb2hsl(hwb2rgb(args));
}

функция hwb2hsv(аргументы) {
  вернуть rgb2hsv(hwb2rgb(args));
}

функция hwb2cmyk(аргументы) {
  вернуть rgb2cmyk(hwb2rgb(args));
}

функция hwb2keyword(аргументы) {
  вернуть rgb2keyword(hwb2rgb(args));
}

функция cmyk2rgb(cmyk) {
  вар с = cmyk[0] / 100,
      м = cmyk[1] / 100,
      у = cmyk[2] / 100,
      к = cmyk[3] / 100,
      г, г, б;

  r = 1 - Матем.мин(1, c * (1 - k) + k);
  g = 1 - Матем.мин(1, m * (1 - k) + k);
  b = 1 - Матем.мин(1, y * (1 - k) + k);
  возврат [r * 255, g * 255, b * 255];
}

функция cmyk2hsl(аргументы) {
  вернуть rgb2hsl(cmyk2rgb(args));
}

функция cmyk2hsv(аргументы) {
  вернуть rgb2hsv(cmyk2rgb(args));
}

функция cmyk2hwb(аргументы) {
  вернуть rgb2hwb(cmyk2rgb(args));
}

функция cmyk2keyword(аргументы) {
  вернуть rgb2keyword(cmyk2rgb(args));
}


функция xyz2rgb(xyz) {
  вар х = хyz[0] / 100,
      у = xyz[1] / 100,
      z = xyz[2] / 100,
      г, г, б;

  г = (х * 3,2406) + (у * -1,5372) + (z * -0,4986);
  г = (х * -0,9689) + (у * 1,8758) + (z * 0,0415);
  б = (х * 0,0557) + (у * -0,2040) + (z * 1,0570);

  // предположим sRGB
  r = r > 0,0031308 ? ((1,055 * Math.pow(r, 1,0 / 2,4)) - 0,055)
    : г = (г * 12,92);

  g = g > 0,0031308 ? ((1,055 * Math.pow(g, 1,0 / 2,4)) - 0,055)
    : г = (г * 12,92);

  b = b > 0,0031308 ? ((1,055 * Math.pow(b, 1,0 / 2,4)) - 0,055)
    : б = (б * 12,92);

  r = Матем.мин(Матем.макс(0, r), 1);
  g = Матем.мин(Матем.макс(0, g), 1);
  b = Матем.мин(Матем.макс(0, b), 1);

  возврат [r * 255, g * 255, b * 255];
}

функция xyz2lab(xyz) {
  вар х = хуz[0],
      у = хуz[1],
      z = xyz[2],
      л, а, б;

  х /= 95,047;
  у /= 100;
  z /= 108,883;

  x = x > 0,008856 ? Math.pow(x, 1/3) : (7,787 * x) + (16 / 116);
  y = y > 0,008856 ? Math.pow(y, 1/3) : (7,787 * y) + (16 / 116);
  г = г > 0,008856 ? Math.pow(z, 1/3): (7,787 * z) + (16/116);

  л = (116 * у) - 16;
  а = 500 * (х - у);
  б = 200 * (у - z);

  вернуть [л, а, б];
}

функция xyz2lch(аргументы) {
  вернуть lab2lch(xyz2lab(args));
}

функция lab2xyz(lab) {
  var l = lab[0],
      а = лаборатория[1],
      б = лаборатория[2],
      х, у, z, у2;

  если (л <= 8) {
    у = (л * 100) / 903,3;
    у2 = (7,787 * (у/100)) + (16/116);
  } еще {
    y = 100 * Math.pow((l + 16) / 116, 3);
    y2 = Math.pow(y / 100, 1/3);
  }

  x = x / 95,047 <= 0,008856 ? x = (95,047 * ((a / 500) + y2 - (16 / 116))) / 7,787 : 95,047 * Math.pow((a / 500) + y2, 3);

  z = z / 108,883 <= 0,008859 ? z = (108,883 * (y2 - (b / 200) - (16 / 116))) / 7,787 : 108,883 * Math.pow(y2 - (b / 200), 3);

  вернуть [x, y, z];
}

функция lab2lch(lab) {
  var l = lab[0],
      а = лаборатория[1],
      б = лаборатория[2],
      ч, ч, с;

  hr = Math.atan2(b, a);
  h = hr * 360 / 2 / Матем.ПИ;
  если (h < 0) {
    ч += 360;
  }
  c = Матем.sqrt(a * a + b * b);
  вернуть [л, с, ч];
}

функция lab2rgb(args) {
  вернуть xyz2rgb(lab2xyz(args));
}

функция lch2lab(lch) {
  вар l = lch[0],
      с = лч[1],
      ч = лч[2],
      а, б, ч;

  hr = h / 360 * 2 * Матем.ПИ;
  а = с * Математика.cos(hr);
  b = c * Math.sin(hr);
  вернуть [л, а, б];
}

функция lch2xyz(аргументы) {
  вернуть lab2xyz(lch2lab(args));
}

функция lch2rgb(аргументы) {
  вернуть lab2rgb(lch2lab(args));
}

функция keyword2rgb(ключевое слово) {
  вернуть cssKeywords[ключевое слово];
}

функция keyword2hsl(args) {
  вернуть rgb2hsl(keyword2rgb(args));
}

функция keyword2hsv(args) {
  вернуть rgb2hsv(keyword2rgb(args));
}

функция keyword2hwb(args) {
  вернуть rgb2hwb(keyword2rgb(args));
}

функция keyword2cmyk(args) {
  вернуть rgb2cmyk(keyword2rgb(args));
}

функция keyword2lab(args) {
  вернуть rgb2lab(keyword2rgb(args));
}

функция keyword2xyz(args) {
  вернуть rgb2xyz(keyword2rgb(args));
}

var cssKeywords = {
  алисаблу: [240,248,255],
  античныйбелый: [250,235,215],
  аква: [0,255,255],
  аквамарин: [127,255,212],
  лазурный: [240,255,255],
  бежевый: [245,245,220],
  бисквит: [255,228,196],
  черный: [0,0,0],
  бланшированный миндаль: [255,235,205],
  синий: [0,0,255],
  сине-фиолетовый: [138,43,226],
  коричневый: [165,42,42],
  бурливуд: [222,184,135],
  кадетсиний: [95,158,160],
  шартрез: [127,255,0],
  шоколад: [210,105,30],
  коралл: [255,127,80],
  васильковый: [100,149,237],
  кукурузные рыльца: [255,248,220],
  малиновый: [220,20,60],
  голубой: [0,255,255],
  темно-синий: [0,0,139],
  темно-голубой: [0,139,139],
  темно-золотой: [184,134,11],
  темно-серый: [169,169,169],
  темно-зеленый: [0,100,0],
  темно-серый: [169,169,169],
  темные хаки: [189,183,107],
  темно-пурпурный: [139,0,139],
  темно-оливковыйзеленый: [85,107,47],
  темно-оранжевый: [255,140,0],
  темная орхидея: [153,50,204],
  темно-красный: [139,0,0],
  темно-лососевый: [233,150,122],
  темно-зеленый: [143,188,143],
  темно-синий: [72,61,139],
  темно-серый: [47,79,79],
  темно-серый: [47,79,79],
  темно-бирюзовый: [0,206,209],
  темно-фиолетовый: [148,0,211],
  темно-розовый: [255,20,147],
  темно-синий: [0,191,255],
  тусклый серый: [105,105,105],
  тусклый серый: [105,105,105],
  доджерблю: [30,144,255],
  огнеупорный кирпич: [178,34,34],
  цветочно-белый: [255,250,240],
  лесной зеленый: [34,139,34],
  фуксия: [255,0,255],
  гейнсборо: [220,220,220],
  призрачный белый: [248,248,255],
  золото: [255,215,0],
  золотарник: [218,165,32],
  серый: [128,128,128],
  зеленый: [0,128,0],
  зелено-желтый: [173,255,47],
  серый: [128,128,128],
  медвяная роса: [240,255,240],
  ярко-розовый: [255,105,180],
  индийский: [205,92,92],
  индиго: [75,0,130],
  слоновая кость: [255,255,240],
  хаки: [240,230,140],
  лаванда: [230,230,250],
  лавандовый румянец: [255,240,245],
  газон зеленый: [124,252,0],
  лимонный шифон: [255,250,205],
  светло-голубой: [173,216,230],
  светло-коралловый: [240,128,128],
  светло-голубой: [224,255,255],
  светло-золотисто-желтый: [250,250,210],
  светло-серый: [211,211,211],
  светло-зеленый: [144,238,144],
  светло-серый: [211,211,211],
  светло-розовый: [255,182,193],
  светлыйлосось: [255,160,122],
  светло-зеленый: [32,178,170],
  светло-голубой: [135,206,250],
  lightslategray: [119,136,153],
  lightslategrey: [119,136,153],
  светло-стально-синий: [176,196,222],
  светло-желтый: [255,255,224],
  известь: [0,255,0],
  лаймово-зеленый: [50,205,50],
  лен: [250,240,230],
  пурпурный: [255,0,255],
  бордовый: [128,0,0],
  среднийаквамарин: [102,205,170],
  средне-синий: [0,0,205],
  средняя орхидея: [186,85,211],
  среднефиолетовый: [147,112,219],
  средне-зеленый: [60,179,113],
  среднийсланцевыйсиний: [123,104,238],
  среднийвесенне-зеленый: [0,250,154],
  среднебирюзовый: [72,209,204],
  среднефиолетовый: [199,21,133],
  полуночно-синий: [25,25,112],
  мятный крем: [245,255,250],
  туманная роза: [255,228,225],
  мокасины: [255,228,181],
  навахоуайт: [255,222,173],
  флот: [0,0,128],
  старый шнурок: [253,245,230],
  оливковый: [128,128,0],
  оливедраба: [107,142,35],
  оранжевый: [255,165,0],
  оранжево-красный: [255,69,0],
  орхидея: [218,112,214],
  бледный золотарник: [238,232,170],
  бледно-зеленый: [152,251,152],
  бледно-бирюзовый: [175,238,238],
  бледно-фиолетово-красный: [219,112,147],
  папайякнут: [255,239,213],
  персиковый пуфф: [255,218,185],
  перу: [205,133,63],
  розовый: [255,192,203],
  слива: [221,160,221],
  пудрово-голубой: [176,224,230],
  фиолетовый: [128,0,128],
  rebeccapurple: [102, 51, 153],
  красный: [255,0,0],
  розово-коричневый: [188,143,143],
  королевский синий: [65,105,225],
  седло-коричневый: [139,69,19],
  лосось: [250,128,114],
  песочно-коричневый: [244,164,96],
  цвет морской волны: [46,139,87],
  ракушка: [255,245,238],
  сиена: [160,82,45],
  серебро: [192,192,192],
  небесно-голубой: [135,206,235],
  сланцево-голубой: [106,90,205],
  сланцево-серый: [112,128,144],
  сланцево-серый: [112,128,144],
  снег: [255,250,250],
  весенне-зеленый: [0,255,127],
  стальной синий: [70,130,180],
  загар: [210,180,140],
  бирюзовый: [0,128,128],
  чертополох: [216,191,216],
  помидор: [255,99,71],
  бирюзовый: [64,224,208],
  фиолетовый: [238,130,238],
  пшеница: [245,222,179],
  белый: [255,255,255],
  белый дым: [245,245,245],
  желтый: [255,255,0],
  желто-зеленый: [154,205,50]
};

var reverseKeywords = {};
для (var key в cssKeywords) {
  reverseKeywords[JSON.stringify(cssKeywords[ключ])] = ключ;
}

},{}],5:[function(require,module,exports){
var преобразования = require(4);

var convert = функция() {
   вернуть новый Преобразователь();
}

для (var func в преобразованиях) {
  // экспортировать сырые версии
  convert[func + "Raw"] = (function(func) {
    // принимаем массив или простые аргументы
    функция возврата(аргумент) {
      если (тип аргумента == "число")
        arg = Массив.прототип.срез.вызов(аргументы);
      возвращаемые преобразования[func](arg);
    }
  })(функ);

  пара var = /(\w+)2(\w+)/.exec(func),
      из = пара[1],
      к = пара[2];

  // экспорт rgb2hsl и ["rgb"]["hsl"]
  преобразовать[из] = преобразовать[из] || {};

  преобразовать[из][в] = преобразовать[функ] = (функция(функ) {
    функция возврата(аргумент) {
      если (тип аргумента == "число")
        arg = Массив.прототип.срез.вызов(аргументы);
      
      вар val = преобразования [функ] (аргумент);
      если (typeof val == "string" || val === не определено)
        return val; // ключевое слово

      для (var i = 0; i < val.length; i++)
        val[i] = Math.round(val[i]);
      возврат значения;
    }
  })(функ);
}


/* Конвертер выполняет ленивое преобразование и кэширование */
var Конвертер = функция() {
   это.convs = {};
};

/* Либо получить значения для пробела, либо
  задайте значения для пробела в зависимости от аргументов */
Converter.prototype.routeSpace = функция(пространство, аргументы) {
   значения переменной = args[0];
   если (значения === не определены) {
      // цвет.rgb()
      вернуть this.getValues(пробел);
   }
   // цвет.rgb(10, 10, 10)
   если (тип значений == "число") {
      значения = Массив.прототип.срез.вызов(аргументы);        
   }

   вернуть this.setValues(пространство, значения);
};
  
/* Задаем значения для пробела, делая кэш недействительным */
Converter.prototype.setValues ​​= функция(пространство, значения) {
   это.пространство = пространство;
   это.convs = {};
   this.convs[пространство] = значения;
   верните это;
};

/* Получить значения для пробела. Если уже есть
  преобразование для пространства, извлечь его, в противном случае
  вычислить это */
Converter.prototype.getValues ​​= функция(пространство) {
   var vals = this.convs[пробел];
   если (!vals) {
      var fspace = это.пространство,
          из = это.convs[fspace];
      vals = convert[fspace][space](из);

      this.convs[пробел] = значения;
   }
  возврат значений;
};

["rgb", "hsl", "hsv", "cmyk", "ключевое слово"].forEach(function(space) {
   Преобразователь.прототип[пробел] = функция(значения) {
      вернуть this.routeSpace(пространство, аргументы);
   }
});

модуль.экспорты = конвертировать;
},{"4":4}],6:[function(require,module,exports){
«использовать строго»

модуль.экспорты = {
	"aliceblue": [240, 248, 255],
	"античныйбелый": [250, 235, 215],
	"аква": [0, 255, 255],
	"аквамарин": [127, 255, 212],
	"лазурный": [240, 255, 255],
	"бежевый": [245, 245, 220],
	"бисквит": [255, 228, 196],
	"черный": [0, 0, 0],
	"бланшированный миндаль": [255, 235, 205],
	"синий": [0, 0, 255],
	"сине-фиолетовый": [138, 43, 226],
	"коричневый": [165, 42, 42],
	"бурливуд": [222, 184, 135],
	"кадетсиний": [95, 158, 160],
	"шартрез": [127, 255, 0],
	"шоколад": [210, 105, 30],
	"коралл": [255, 127, 80],
	"васильковый": [100, 149, 237],
	"кукурузные рыльца": [255, 248, 220],
	"малиновый": [220, 20, 60],
	"голубой": [0, 255, 255],
	"темно-синий": [0, 0, 139],
	"темно-голубой": [0, 139, 139],
	"темно-золотой стержень": [184, 134, 11],
	"темно-серый": [169, 169, 169],
	"темно-зеленый": [0, 100, 0],
	"темно-серый": [169, 169, 169],
	"темные хаки": [189, 183, 107],
	"темно-пурпурный": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"темно-оранжевый": [255, 140, 0],
	"темнокорчид": [153, 50, 204],
	"темно-красный": [139, 0, 0],
	"темный лосось": [233, 150, 122],
	"темно-зеленый": [143, 188, 143],
	"темно-синий": [72, 61, 139],
	"темно-серый": [47, 79, 79],
	"темно-серый": [47, 79, 79],
	"темно-бирюзовый": [0, 206, 209],
	"темно-фиолетовый": [148, 0, 211],
	"глубокий розовый": [255, 20, 147],
	"глубокийнебесно-голубой": [0, 191, 255],
	"тусклого серого": [105, 105, 105],
	"тусклого серого": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"огненный кирпич": [178, 34, 34],
	"цветочно-белый": [255, 250, 240],
	"зеленый лес": [34, 139, 34],
	"фуксия": [255, 0, 255],
	"Гейнсборо": [220, 220, 220],
	"призрачно-белый": [248, 248, 255],
	"золото": [255, 215, 0],
	"золотарник": [218, 165, 32],
	"серый": [128, 128, 128],
	"зеленый": [0, 128, 0],
	"зелено-желтый": [173, 255, 47],
	"серый": [128, 128, 128],
	"медвяная роса": [240, 255, 240],
	"ярко-розовый": [255, 105, 180],
	"индийский красный": [205, 92, 92],
	"индиго": [75, 0, 130],
	"слоновая кость": [255, 255, 240],
	"хаки": [240, 230, 140],
	"лаванда": [230, 230, 250],
	"лавандовый румянец": [255, 240, 245],
	"газонгрин": [124, 252, 0],
	«лимоншифон»: [255, 250, 205],
	"светло-голубой": [173, 216, 230],
	"светло-коралловый": [240, 128, 128],
	"светло-голубой": [224, 255, 255],
	"светло-золотисто-желтый": [250, 250, 210],
	"светло-серый": [211, 211, 211],
	«светло-зеленый»: [144, 238, 144],
	"светло-серый": [211, 211, 211],
	"светло-розовый": [255, 182, 193],
	"светлосось": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"светло-голубой": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"светло-стально-голубой": [176, 196, 222],
	"светло-желтый": [255, 255, 224],
	"лайм": [0, 255, 0],
	"лаймово-зеленый": [50, 205, 50],
	"лен": [250, 240, 230],
	"пурпурный": [255, 0, 255],
	"бордовый": [128, 0, 0],
	"среднеаквамарин": [102, 205, 170],
	"средне-синий": [0, 0, 205],
	"средняя орхидея": [186, 85, 211],
	"среднефиолетовый": [147, 112, 219],
	"средне-зеленый": [60, 179, 113],
	"средне-сланцево-синий": [123, 104, 238],
	"средневесеннезеленый": [0, 250, 154],
	"среднебирюзовый": [72, 209, 204],
	"среднефиолетово-красный": [199, 21, 133],
	"полночно-синий": [25, 25, 112],
	"мятный крем": [245, 255, 250],
	"туманная роза": [255, 228, 225],
	"мокасины": [255, 228, 181],
	"навахоуайт": [255, 222, 173],
	"флот": [0, 0, 128],
	"старый шнурок": [253, 245, 230],
	"оливковый": [128, 128, 0],
	"оливедраб": [107, 142, 35],
	"оранжевый": [255, 165, 0],
	"оранжевый": [255, 69, 0],
	"орхидея": [218, 112, 214],
	"бледно-золотой": [238, 232, 170],
	"бледно-зеленый": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"палевиолетред": [219, 112, 147],
	«папайавип»: [255, 239, 213],
	"персиковый пух": [255, 218, 185],
	"перу": [205, 133, 63],
	"розовый": [255, 192, 203],
	"слива": [221, 160, 221],
	"пудрово-синий": [176, 224, 230],
	"фиолетовый": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"красный": [255, 0, 0],
	"розово-коричневый": [188, 143, 143],
	"королевский синий": [65, 105, 225],
	"седло-коричневый": [139, 69, 19],
	"лосось": [250, 128, 114],
	"песчано-коричневый": [244, 164, 96],
	"зеленый": [46, 139, 87],
	"ракушка": [255, 245, 238],
	"сиена": [160, 82, 45],
	"серебро": [192, 192, 192],
	"небесно-голубой": [135, 206, 235],
	"сланцево-голубой": [106, 90, 205],
	"сланцево-серый": [112, 128, 144],
	"сланцево-серый": [112, 128, 144],
	"снег": [255, 250, 250],
	"весенне-зеленый": [0, 255, 127],
	"стально-голубой": [70, 130, 180],
	"загар": [210, 180, 140],
	"бирюзовый": [0, 128, 128],
	"чертополох": [216, 191, 216],
	"помидор": [255, 99, 71],
	"бирюзовый": [64, 224, 208],
	"фиолетовый": [238, 130, 238],
	"пшеница": [245, 222, 179],
	"белый": [255, 255, 255],
	"белый дым": [245, 245, 245],
	"желтый": [255, 255, 0],
	"желто-зеленый": [154, 205, 50]
};

},{}],7:[function(require,module,exports){
/**
 * @namespace Диаграмма
 */
var Chart = require(29)();

Chart.helpers = require(45);

// @todo отправляет эти помощники в соответствующие файлы helpers/helpers.* и пишет модульные тесты!
требуется(27)(Диаграмма);

Chart.defaults = require(25);
Элемент диаграммы = require(26);
Элементы диаграммы = require(40);
Диаграмма.Взаимодействие = требуется(28);
Диаграмма.layouts = require(30);
Chart.platform = требуется(48);
Chart.plugins = require(31);
Диаграмма.Тики = требуется(34);

требуется(22)(Диаграмма);
требуется(23)(Диаграмма);
требуется(24)(Диаграмма);
требуется(33)(Диаграмма);
требуется(32)(Диаграмма);
требуется(35)(Диаграмма);

требуется(55)(Диаграмма);
требуется(53)(Диаграмма);
требуется(54)(Диаграмма);
требуется(56)(Диаграмма);
требуется(57)(Диаграмма);
требуется(58)(Диаграмма);

// Контроллеры должны быть загружены после элементов
// См. Chart.core.datasetController.dataElementType
требуется(15)(Диаграмма);
требуется(16)(Диаграмма);
требуется(17)(Диаграмма);
требуется(18)(Диаграмма);
требуется(19)(Диаграмма);
требуется(20)(Диаграмма);
требуется(21)(Диаграмма);

требуется(8)(Диаграмма);
требуется(9)(Диаграмма);
требуется(10)(Диаграмма);
требуется(11)(Диаграмма);
требуется(12)(Диаграмма);
требуется(13)(Диаграмма);
требуется(14)(Диаграмма);

// Загрузка встроенных плагинов
var плагины = require(49);
для (var k в плагинах) {
	если (plugins.hasOwnProperty(k)) {
		Chart.plugins.register(plugins[k]);
	}
}

Chart.platform.initialize();

module.exports = Диаграмма;
если (тип окна !== 'не определен') {
	окно.Диаграмма = Диаграмма;
}

// УСТАРЕНИЕ

/**
 * Предоставлено для обратной совместимости, больше не доступно
 * @namespace Диаграмма.Легенда
 * @deprecated с версии 2.1.5
 * @todo удалено в версии 3
 * @частный
 */
Chart.Legend = plugins.legend._element;

/**
 * Предоставлено для обратной совместимости, больше не доступно
 * @namespace Название.диаграммы
 * @deprecated с версии 2.1.5
 * @todo удалено в версии 3
 * @частный
 */
Chart.Title = plugins.title._element;

/**
 * Предоставлено для обратной совместимости, вместо этого используйте Chart.plugins
 * @namespace Chart.pluginService
 * @deprecated с версии 2.1.5
 * @todo удалено в версии 3
 * @частный
 */
Chart.pluginService = Chart.plugins;

/**
 * Предусмотрено для обратной совместимости, наследование от Chart.PlugingBase не имеет
 * эффект, вместо этого просто создавайте/регистрируйте плагины через простые объекты JavaScript.
 * @interface Chart.PluginBase
 * @deprecated с версии 2.5.0
 * @todo удалено в версии 3
 * @частный
 */
Chart.PluginBase = Chart.Element.extend({});

/**
 * Предоставлено для обратной совместимости, вместо этого используйте Chart.helpers.canvas.
 * @namespace Chart.canvasHelpers
 * @deprecated с версии 2.6.0
 * @todo удалено в версии 3
 * @частный
 */
Chart.canvasHelpers = Chart.helpers.canvas;

/**
 * Предоставлено для обратной совместимости, вместо этого используйте Chart.layouts.
 * @namespace Chart.layoutService
 * @deprecated с версии 2.8.0
 * @todo удалено в версии 3
 * @частный
 */
Chart.layoutService = Chart.layouts;

},{"10":10,"11":11,"12":12,"13":13,"14":14,"15":15,"16":16,"17":17 ,"18":18,"19":19,"2 0":20","21":21,"22":22,"23":23,"24":24,"25":25,"26":26,"27":27,"28" :28,"29":29,"30":30 ,"31":31,"32":32,"33":33,"34":34,"35":35,"40":40,"45":45,"48":48," 49":49,"53":53,"54":54,"55":55,"56":56,"57":57,"58":58,"8":8,"9" :9}],8:[function(require,module,exports){
«использовать строго»;

модуль.экспорты = функция(Диаграмма) {

	Chart.Bar = функция(контекст, конфигурация) {
		тип конфигурации = 'bar';

		вернуть новый Chart(контекст, конфигурация);
	};

};

},{}],9:[function(require,module,exports){
«использовать строго»;

модуль.экспорты = функция(Диаграмма) {

	Chart.Bubble = функция(контекст, конфигурация) {
		config.type = 'пузырь';
		вернуть новый Chart(контекст, конфигурация);
	};

};

},{}],10:[function(require,module,exports){
«использовать строго»;

модуль.экспорты = функция(Диаграмма) {

	Диаграмма.Пончик = функция(контекст, конфигурация) {
		config.type = 'пончик';

		вернуть новый Chart(контекст, конфигурация);
	};

};

},{}],11:[function(require,module,exports){
«использовать строго»;

модуль.экспорты = функция(Диаграмма) {

	Диаграмма.Линия = функция(контекст, конфигурация) {
		тип конфигурации = 'линия';

		вернуть новый Chart(контекст, конфигурация);
	};

};

},{}],12:[функция(требуется,модуль,экспорты){
«использовать строго»;

модуль.экспорты = функция(Диаграмма) {

	Chart.PolarArea = функция(контекст, конфигурация) {
		config.type = 'polarArea';

		вернуть новый Chart(контекст, конфигурация);
	};

};

},{}],13:[function(require,module,exports){
«использовать строго»;

модуль.экспорты = функция(Диаграмма) {

	Chart.Radar = функция(контекст, конфигурация) {
		config.type = 'радар';

		вернуть новый Chart(контекст, конфигурация);
	};

};

},{}],14:[function(require,module,exports){
«использовать строго»;

модуль.экспорты = функция(Диаграмма) {
	Диаграмма.Разброс = функция(контекст, конфигурация) {
		config.type = 'разброс';
		вернуть новый Chart(контекст, конфигурация);
	};
};

},{}],15:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
элементы переменной = require(40);
var helpers = require(45);

defaults._set('bar', {
	наведите курсор: {
		режим: «метка»
	},

	весы: {
		xAxes: [{
			тип: «категория»,

			// Специально для контроллера бара
			категорияПроцент: 0.8,
			barПроцент: 0,9,

			// настройки смещения
			смещение: истинное,

			// настройки линии сетки
			Линии сетки: {
				offsetGridLines: правда
			}
		}],

		yAxes: [{
			тип: «линейный»
		}]
	}
});

defaults._set('horizontalBar', {
	наведите курсор: {
		режим: «индекс»,
		ось: 'y'
	},

	весы: {
		xAxes: [{
			тип: «линейный»,
			позиция: «внизу»
		}],

		yAxes: [{
			позиция: «слева»,
			тип: «категория»,

			// Специально для контроллера горизонтальной полосы
			категорияПроцент: 0.8,
			barПроцент: 0,9,

			// настройки смещения
			смещение: истинное,

			// настройки линии сетки
			Линии сетки: {
				offsetGridLines: правда
			}
		}]
	},

	элементы: {
		прямоугольник: {
			borderПропущено: 'left'
		}
	},

	подсказки: {
		обратные вызовы: {
			заголовок: функция(элемент, данные) {
				// Выберите первый xLabel на данный момент
				var title = '';

				если (длина элемента > 0) {
					если (item[0].yLabel) {
						заголовок = элемент[0].yLabel;
					} иначе если (data.labels.length > 0 && item[0].index < data.labels.length) {
						заголовок = данные.метки[элемент[0].индекс];
					}
				}

				вернуть заголовок;
			},

			метка: функция(элемент, данные) {
				var datasetLabel = data.datasets[item.datasetIndex].label || '';
				return datasetLabel + ': ' + item.xLabel;
			}
		},
		режим: «индекс»,
		ось: 'y'
	}
});

/**
 * Вычисляет «оптимальный» размер выборки, чтобы поддерживать одинаковый размер столбцов и при этом не допускать перекрытия.
 * @частный
 */
функция computeMinSampleSize(масштаб, пиксели) {
	var min = scale.isHorizontal() ? scale.width : scale.height;
	var ticks = scale.getTicks();
	var prev, curr, i, ilen;

	для (i = 1, ilen = пикселей.длина; i < ilen; ++i) {
		min = Math.min(min, пиксели[i] - пиксели[i - 1]);
	}

	для (i = 0, ilen = ticks.length; i < ilen; ++i) {
		curr = scale.getPixelForTick(i);
		min = i > 0 ? Math.min(min, curr - prev) : min;
		предыдущая = текущая;
	}

	возврат мин.;
}

/**
 * Вычисляет «идеальную» категорию на основе абсолютной толщины стержня или, если не определено или равно нулю,
 * использует наименьший интервал (см. computeMinSampleSize), который предотвращает перекрытие полос. Это
 * в настоящее время режим всегда генерирует полосы одинакового размера (пока мы не добавим возможности скриптования?).
 * @частный
 */
функция computeFitCategoryTraits(индекс, линейка, параметры) {
	var толщина = параметры.barThickness;
	var count = правитель.stackCount;
	var curr = линейка.пиксели[индекс];
	размер переменной, отношение;

	если (helpers.isNullOrUndef(толщина)) {
		размер = линейка.мин * параметры.категорияПроцент;
		соотношение = options.barPercentage;
	} еще {
		// Если задана толщина столбца, категория и проценты столбца игнорируются.
		// Примечание(SB): мы могли бы добавить поддержку относительной толщины стержня (например, barThickness: '50%')
		// и исключите barPercentage, так как это значение игнорируется, если толщина абсолютная.
		размер = толщина * количество;
		отношение = 1;
	}

	возвращаться {
		кусок: размер/количество,
		соотношение: соотношение,
		начало: curr - (размер / 2)
	};
}

/**
 * Вычисляет «оптимальную» категорию, которая глобально располагает столбцы рядом (без зазоров, когда
 * процентные параметры 1), основанные на предыдущей и следующей категориях. Этот режим
 * создает столбцы разной ширины, если данные распределены неравномерно.
 * @частный
 */
функция computeFlexCategoryTraits(индекс, линейка, параметры) {
	var пиксели = линейка.пиксели;
	var curr = пиксели[индекс];
	вар предыдущая = индекс > 0? пикселей [индекс - 1]: ноль;
	var next = индекс < пикс.длина - 1 ? пикс[индекс + 1] : null;
	var процент = параметры.categoryPercentage;
	начало переменной, размер;

	если (предыдущий === null) {
		// первые данные: их размер удваивается в зависимости от следующей точки или,
		// если это также последние данные, мы используем конечную точку шкалы.
		prev = curr - (next === null ? rule.end - curr : next - curr);
	}

	если (следующий === null) {
		// последние данные: их размер также удваивается по сравнению с предыдущей точкой.
		следующий = текущий + текущий - предыдущий;
	}

	начало = текущий - ((текущий - предыдущий) / 2) * процент;
	размер = ((следующий - предыдущий) / 2) * процент;

	возвращаться {
		кусок: размер / правитель.stackCount,
		соотношение: options.barPercentage,
		начало: начало
	};
}

модуль.экспорты = функция(Диаграмма) {

	Chart.controllers.bar = Chart.DatasetController.extend({

		dataElementType: элементы.Прямоугольник,

		инициализировать: функция() {
			var me = это;
			вар мета;

			Chart.DatasetController.prototype.initialize.apply(я, аргументы);

			мета = я.getMeta();
			meta.стек = me.getDataset().стек;
			мета.bar = истина;
		},

		обновление: функция(сброс) {
			var me = это;
			var rects = me.getMeta().data;
			вар i, илен;

			я._линейка = я.получитьЛинейку();

			для (i = 0, ilen = rects.length; i < ilen; ++i) {
				я.updateElement(rects[i], i, reset);
			}
		},

		updateElement: функция(прямоугольник, индекс, сброс) {
			var me = это;
			var chart = я.диаграмма;
			var meta = me.getMeta();
			набор данных вар = me.getDataset();
			var custom = прямоугольник.custom || {};
			var прямоугольникПараметры = диаграмма.параметры.элементы.прямоугольник;

			прямоугольник._xScale = me.getScaleForId(meta.xAxisID);
			прямоугольник._yScale = me.getScaleForId(meta.yAxisID);
			прямоугольник._datasetIndex = я.индекс;
			прямоугольник._индекс = индекс;

			прямоугольник._модель = {
				Метка_набора_данных: метка_набора_данных,
				метка: chart.data.labels[индекс],
				borderSkipped: custom.borderSkipped ? custom.borderSkipped : прямоугольникOptions.borderSkipped,
				backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
				borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
				borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
			};

			me.updateElementGeometry(прямоугольник, индекс, сброс);

			прямоугольник.pivot();
		},

		/**
		 * @частный
		 */
		updateElementGeometry: функция(прямоугольник, индекс, сброс) {
			var me = это;
			var model = прямоугольник._модель;
			var vscale = me.getValueScale();
			вар база = vscale.getBasePixel();
			var horizontal = vscale.isHorizontal();
			вар правитель = me._ruler || me.getRuler();
			var vpixels = me.calculateBarValuePixels(me.index, index);
			var ipixels = me.calculateBarIndexPixels(me.index, index, rule);

			модель.горизонтальная = горизонтальная;
			model.base = сброс ? base : vpixels.base;
			model.x = горизонтальный ? сброс ? основание : vpixels.head : ipixels.center;
			model.y = по горизонтали ? ipixels.center : сброс ? base : vpixels.head;
			model.height = по горизонтали ? ipixels.size : не определено;
			model.width = по горизонтали ? undefined : ipixels.size;
		},

		/**
		 * @частный
		 */
		получитьValueScaleId: функция() {
			вернуть this.getMeta().yAxisID;
		},

		/**
		 * @частный
		 */
		getIndexScaleId: функция() {
			вернуть this.getMeta().xAxisID;
		},

		/**
		 * @частный
		 */
		получитьЗначениеScale: функция() {
			вернуть this.getScaleForId(this.getValueScaleId());
		},

		/**
		 * @частный
		 */
		getIndexScale: функция() {
			вернуть this.getScaleForId(this.getIndexScaleId());
		},

		/**
		 * Возвращает стеки на основе групп и видимости столбцов.
		 * @param {Number} [last] — индекс набора данных
		 * @returns {Array} Список стека
		 * @частный
		 */
		_getStacks: функция(последняя) {
			var me = это;
			var chart = я.диаграмма;
			вар масштаб = me.getIndexScale();
			var stacked = scale.options.stacked;
			var ilen = last === undefined ? chart.data.datasets.length : last + 1;
			var стеки = [];
			вар i, мета;

			для (i = 0; i < ilen; ++i) {
				мета = диаграмма.getDatasetMeta(i);
				если (meta.bar && chart.isDatasetVisible(i) &&
					(сложенный === ложь ||
					(стек === истина && стеки.индекс(мета.стек) === -1) ||
					(стек === не определено && (мета.стек === не определено || стеки.индекс(мета.стек) === -1)))) {
					стеки.push(мета.стек);
				}
			}

			возврат стеков;
		},

		/**
		 * Возвращает эффективное количество стеков на основе групп и видимости столбцов.
		 * @частный
		 */
		getStackCount: функция() {
			вернуть this._getStacks().length;
		},

		/**
		 * Возвращает индекс стека для указанного набора данных на основе групп и видимости столбцов.
		 * @param {Number} [datasetIndex] — индекс набора данных
		 * @param {String} [name] — Имя стека, которое нужно найти
		 * @returns {Number} Индекс стека
		 * @частный
		 */
		getStackIndex: функция(datasetIndex, имя) {
			var stacks = this._getStacks(datasetIndex);
			var index = (имя !== не определено)
				? stacks.indexOf(имя)
				: -1; // indexOf возвращает -1, если элемент отсутствует

			возврат (индекс === -1)
				? длина стека - 1
				: индекс;
		},

		/**
		 * @частный
		 */
		получитьПравитель: функция() {
			var me = это;
			вар масштаб = me.getIndexScale();
			var stackCount = me.getStackCount();
			var datasetIndex = me.index;
			var isHorizontal = scale.isHorizontal();
			var start = isHorizontal ? масштаб.left : масштаб.top;
			var end = start + (isHorizontal ? scale.width : scale.height);
			var пикселей = [];
			вар i, илен, мин;

			для (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
				пиксели.push(scale.getPixelForValue(null, i, datasetIndex));
			}

			min = helpers.isNullOrUndef(масштаб.опции.толщинабарщины)
				? computeMinSampleSize(масштаб, пиксели)
				: -1;

			возвращаться {
				мин: мин,
				пиксели: пиксели,
				начать: начать,
				конец: конец,
				Количество стеков: Количество стеков,
				масштаб: масштаб
			};
		},

		/**
		 * Примечание: значения пикселей не привязаны к области шкалы.
		 * @частный
		 */
		calculateBarValuePixels: функция(datasetIndex, index) {
			var me = это;
			var chart = я.диаграмма;
			var meta = me.getMeta();
			var scale = me.getValueScale();
			наборы данных вар =chart.data.datasets;
			var value = scale.getRightValue(datasets[datasetIndex].data[index]);
			var stacked = scale.options.stacked;
			var stack = meta.стек;
			начало переменной = 0;
			var i, imeta, ivalue, база, заголовок, размер;

			если (стек || (стек === не определено && стек !== не определено)) {
				для (i = 0; i < datasetIndex; ++i) {
					imeta =chart.getDatasetMeta(i);

					если (имета.бар &&
						имета.стек === стек &&
						imeta.controller.getValueScaleId() === масштаб.id &&
						диаграмма.isDatasetVisible(i)) {

						ivalue = scale.getRightValue(наборы данных[i].данные[индекс]);
						если ((значение < 0 && ivalue < 0) || (значение >= 0 && ivalue > 0)) {
							начало += ivalue;
						}
					}
				}
			}

			база = масштаб.getPixelForValue(начало);
			голова = масштаб.getPixelForValue(начало + значение);
			размер = (головка - основание) / 2;

			возвращаться {
				размер: размер,
				база: база,
				голова: голова,
				центр: голова + размер / 2
			};
		},

		/**
		 * @частный
		 */
		calculateBarIndexPixels: функция(datasetIndex, индекс, линейка) {
			var me = это;
			var options = линейка.шкала.опции;
			var range = options.barThickness === 'flex'
				? computeFlexCategoryTraits(индекс, линейка, параметры)
				: computeFitCategoryTraits(индекс, линейка, параметры);

			var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
			var center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
			размер переменной = Математика.min(
				helpers.valueOrDefault(options.maxBarThickness, Infinity),
				диапазон.частей * диапазон.соотношение);

			возвращаться {
				основание: центр - размер / 2,
				голова: центр + размер / 2,
				центр: центр,
				размер: размер
			};
		},

		рисовать: функция() {
			var me = это;
			var chart = я.диаграмма;
			var scale = me.getValueScale();
			var rects = me.getMeta().data;
			набор данных вар = me.getDataset();
			var ilen = rects.length;
			переменная i = 0;

			helpers.canvas.clipArea(chart.ctx, chart.chartArea);

			для (; i < ilen; ++i) {
				если (!isNaN(scale.getRightValue(dataset.data[i]))) {
					прямоугольники[i].draw();
				}
			}

			helpers.canvas.unclipArea(chart.ctx);
		},

		setHoverStyle: функция(прямоугольник) {
			var dataset = this.chart.data.datasets[rectangle._datasetIndex];
			var index = прямоугольник._индекс;
			var custom = прямоугольник.custom || {};
			var model = прямоугольник._модель;

			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
		},

		removeHoverStyle: функция(прямоугольник) {
			var dataset = this.chart.data.datasets[rectangle._datasetIndex];
			var index = прямоугольник._индекс;
			var custom = прямоугольник.custom || {};
			var model = прямоугольник._модель;
			var прямоугольникПараметрыЭлемента = эта.диаграмма.опции.элементы.прямоугольник;

			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index,rectangleElementOptions.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index,rectangleElementOptions.borderWidth);
		}
	});

	Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
		/**
		 * @частный
		 */
		получитьValueScaleId: функция() {
			вернуть this.getMeta().xAxisID;
		},

		/**
		 * @частный
		 */
		getIndexScaleId: функция() {
			вернуть this.getMeta().yAxisID;
		}
	});
};

},{"25":25,"40":40,"45":45}],16:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
элементы переменной = require(40);
var helpers = require(45);

defaults._set('пузырь', {
	наведите курсор: {
		режим: «одиночный»
	},

	весы: {
		xAxes: [{
			тип: 'linear', // пузырь, вероятно, должен использовать линейную шкалу по умолчанию
			положение: «внизу»,
			id: 'x-axis-0' // нужен идентификатор, чтобы наборы данных могли ссылаться на шкалу
		}],
		yAxes: [{
			тип: «линейный»,
			позиция: «слева»,
			идентификатор: 'y-ось-0'
		}]
	},

	подсказки: {
		обратные вызовы: {
			заголовок: функция() {
				// Заголовок не имеет смысла для scatter, так как мы форматируем данные как точку
				возвращаться '';
			},
			метка: функция(элемент, данные) {
				var datasetLabel = data.datasets[item.datasetIndex].label || '';
				var dataPoint = data.datasets[item.datasetIndex].data[item.index];
				return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
			}
		}
	}
});


модуль.экспорты = функция(Диаграмма) {

	Chart.controllers.bubble = Chart.DatasetController.extend({
		/**
		 * @защищено
		 */
		dataElementType: элементы.Point,

		/**
		 * @защищено
		 */
		обновление: функция(сброс) {
			var me = это;
			var meta = me.getMeta();
			var points = метаданные;

			// Обновление точек
			помощники.каждый(точки, функция(точка, индекс) {
				me.updateElement(точка, индекс, сброс);
			});
		},

		/**
		 * @защищено
		 */
		updateElement: функция(точка, индекс, сброс) {
			var me = это;
			var meta = me.getMeta();
			var custom = point.custom || {};
			var xScale = me.getScaleForId(meta.xAxisID);
			var yScale = me.getScaleForId(meta.yAxisID);
			var options = me._resolveElementOptions(точка, индекс);
			var data = me.getDataset().data[index];
			var dsIndex = me.index;

			var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
			вар y = сброс? yScale.getBasePixel(): yScale.getPixelForValue(данные, индекс, dsIndex);

			точка._xScale = xScale;
			точка._yScale = yScale;
			точка._опции = опции;
			point._datasetIndex = dsIndex;
			точка._индекс = индекс;
			точка._модель = {
				Цвет фона: параметры.Цвет фона,
				borderColor: параметры.borderColor,
				borderWidth: параметры.borderWidth,
				hitRadius: параметры.hitRadius,
				pointStyle: параметры.pointStyle,
				радиус: сброс ? 0 : параметры.радиус,
				пропустить: custom.skip || isNaN(x) || isNaN(у),
				х: х,
				у: у,
			};

			точка.pivot();
		},

		/**
		 * @защищено
		 */
		setHoverStyle: функция(точка) {
			var model = точка._модель;
			var options = point._options;

			model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
			model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
			model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
			модель.радиус = параметры.радиус + параметры.hoverRadius;
		},

		/**
		 * @защищено
		 */
		removeHoverStyle: функция(точка) {
			var model = точка._модель;
			var options = point._options;

			модель.цвет_фона = параметры.цвет_фона;
			модель.цвет границы = параметры.цвет границы;
			модель.ширина границы = параметры.ширина границы;
			модель.радиус = параметры.радиус;
		},

		/**
		 * @частный
		 */
		_resolveElementOptions: функция(точка, индекс) {
			var me = это;
			var chart = я.диаграмма;
			наборы данных вар =chart.data.datasets;
			var dataset = datasets[me.index];
			var custom = point.custom || {};
			var options = chart.options.elements.point;
			var resolve = helpers.options.resolve;
			вар данные = dataset.data[индекс];
			значения переменной = {};
			вар i, илен, ключ;

			// Параметры скрипта
			переменная контекста = {
				диаграмма: диаграмма,
				dataIndex: индекс,
				набор данных: набор данных,
				Индекс набора данных: me.index
			};

			var ключи = [
				'Цвет фона',
				'цвет границы',
				'ширина границы',
				'hoverBackgroundColor',
				'hoverBorderColor',
				'hoverBorderWidth',
				'hoverRadius',
				'hitRadius',
				'pointStyle'
			];

			for (i = 0, ilen =keys.length; i < ilen; ++i) {
				ключ = ключи[i];
				значения[ключ] = разрешить([
					пользовательский[ключ],
					набор данных[ключ],
					параметры[ключ]
				], контекст, индекс);
			}

			// Пользовательское разрешение радиуса
			значения.радиус = разрешение([
				пользовательский радиус,
				данные ? данные.r : не определено,
				набор данных.радиус,
				параметры.радиус
			], контекст, индекс);

			возвращаемые значения;
		}
	});
};

},{"25":25,"40":40,"45":45}],17:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
элементы переменной = require(40);
var helpers = require(45);

defaults._set('пончик', {
	анимация: {
		// Boolean - Анимируем ли мы вращение пончика
		animateRotate: правда,
		// Boolean - Анимируем ли мы масштабирование пончика от центра
		animateScale: ложь
	},
	наведите курсор: {
		режим: «одиночный»
	},
	legendCallback: функция(диаграмма) {
		переменная текст = [];
		text.push('<ul class="' + chart.id + '-legend">');

		var data = chart.data;
		var datasets = данные.datasets;
		var labels = данные.метки;

		если (наборы данных.длина) {
			для (var i = 0; i < datasets[0].data.length; ++i) {
				text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
				если (метки[i]) {
					текст.push(метки[i]);
				}
				текст.push('</li>');
			}
		}

		текст.push('</ul>');
		вернуть текст.join('');
	},
	легенда: {
		метки: {
			generateLabels: функция(диаграмма) {
				var data = chart.data;
				если (data.labels.length && data.datasets.length) {
					вернуть данные.метки.карта(функция(метка, i) {
						вар мета =chart.getDatasetMeta(0);
						var ds = data.datasets[0];
						var arc = meta.data[i];
						var custom = arc && arc.custom || {};
						var значениеПоИндексуИлиПоУмолчанию = helpers.значениеПоИндексуИлиПоУмолчанию;
						var arcOpts = chart.options.elements.arc;
						var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
						var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
						var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

						возвращаться {
							текст: этикетка,
							fillStyle: заполнить,
							strokeStyle: инсульт,
							Ширина линии: ч/б,
							скрытый: isNaN(ds.data[i]) || meta.data[i].hidden,

							// Дополнительные данные, используемые для переключения правильного элемента
							индекс: я
						};
					});
				}
				возвращаться [];
			}
		},

		onClick: функция(e, legendItem) {
			var index = legendItem.index;
			var chart = эта.диаграмма;
			вар i, илен, мета;

			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
				мета = диаграмма.getDatasetMeta(i);
				// переключить видимость индекса, если он существует
				если (мета.данные[индекс]) {
					метаданные[индекс].скрытый = !мета.данные[индекс].скрытый;
				}
			}

			диаграмма.обновление();
		}
	},

	// Процент диаграммы, который мы вырезаем из середины.
	вырезПроцент: 50,

	// Поворот диаграммы, где начинается первая дуга данных.
	вращение: Матем.ПИ * -0,5,

	// Общая окружность диаграммы.
	окружность: Матем.ПИ * 2,0,

	// Необходимо переопределить их, чтобы задать удобные значения по умолчанию
	подсказки: {
		обратные вызовы: {
			заголовок: функция() {
				возвращаться '';
			},
			метка: функция(tooltipItem, данные) {
				вар dataLabel = data.labels[tooltipItem.index];
				var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

				если (helpers.isArray(dataLabel)) {
					// показать значение на первой строке многострочной метки
					// нужно клонировать, потому что мы меняем значение
					dataLabel = dataLabel.slice();
					dataLabel[0] += значение;
				} еще {
					dataLabel += значение;
				}

				вернуть данныеLabel;
			}
		}
	}
});

defaults._set('pie', helpers.clone(defaults.doughnut));
defaults._set('пирог', {
	вырезПроцент: 0
});

модуль.экспорты = функция(Диаграмма) {

	Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({

		dataElementType: элементы.Arc,

		ссылкаВесы: helpers.noop,

		// Получить индекс набора данных относительно видимых наборов данных. Это позволяет правильно определить внутренний и внешний радиус
		getRingIndex: функция(datasetIndex) {
			var ringIndex = 0;

			for (var j = 0; j <datasetIndex; ++j) {
				если (эта.диаграмма.isDatasetVisible(j)) {
					++ringIndex;
				}
			}

			вернуть индекс кольца;
		},

		обновление: функция(сброс) {
			var me = это;
			var chart = я.диаграмма;
			варchartArea =chart.chartArea;
			var opts = chart.options;
			var arcOpts = opts.elements.arc;
			var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
			var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
			var minSize = Math.min(доступнаяШирина, доступнаяВысота);
			переменная offset = {x: 0, y: 0};
			var meta = me.getMeta();
			var cutoutPercentage = opts.cutoutPercentage;
			var окружность = opts.окружность;

			// Если окружность диаграммы не является полным кругом, вычислите minSize как отношение ширины к высоте дуги
			если (окружность < Матем.ПИ * 2,0) {
				вар startAngle = opts.rotation % (Math.PI * 2.0);
				startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
				вар endAngle = startAngle + окружность;
				var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};
				var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};
				var contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);
				var contains90 = (startAngle <= Math.PI * 0,5 && Math.PI * 0,5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);
				var contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);
				var contains270 = (начальныйУгол <= -Математический.ПИ * 0.5 && -Математический.ПИ * 0.5 <= конечныйУгол) || (начальныйУгол <= Математический.ПИ * 1.5 && Математический.ПИ * 1.5 <= конечныйУгол);
				var cutout = cutoutPercentage / 100.0;
				var min = {x: содержит180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : вырез), end.x * (end.x < 0 ? 1 : вырез)), y: содержит270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : вырез), end.y * (end.y < 0 ? 1 : вырез))};
				var max = {x: содержит0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : вырез), end.x * (end.x > 0 ? 1 : вырез)), y: содержит90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : вырез), end.y * (end.y > 0 ? 1 : вырез))};
				var size = {ширина: (макс.x - мин.x) * 0,5, высота: (макс.y - мин.y) * 0,5};
				minSize = Math.min(доступнаяШирина / размер.ширина, доступнаяВысота / размер.высота);
				смещение = {x: (макс.x + мин.x) * -0,5, y: (макс.y + мин.y) * -0,5};
			}

			chart.borderWidth = me.getMaxBorderWidth(meta.data);
			chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
			chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);
			chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
			смещение.диаграммыX = смещение.x * внешний.радиус диаграммы;
			смещение.диаграммыY = смещение.y * внешний.радиус диаграммы;

			meta.total = me.calculateTotal();

			я.внешнийРадиус = диаграмма.внешнийРадиус - (диаграмма.радиусДлина * я.получитьИндексКольца(я.индекс));
			me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);

			помощники.каждый(мета.данные, функция(дуга, индекс) {
				me.updateElement(дуга, индекс, сброс);
			});
		},

		updateElement: функция(дуга, индекс, сброс) {
			var me = это;
			var chart = я.диаграмма;
			варchartArea =chart.chartArea;
			var opts = chart.options;
			var animationOpts = opts.animation;
			var centerX = (chartArea.left +chartArea.right)/2;
			var centerY = (chartArea.top +chartArea.bottom)/2;
			var startAngle = opts.rotation; // случай без сброса обрабатывается позже
			var endAngle = opts.rotation; // случай без сброса обрабатывается позже
			набор данных вар = me.getDataset();
			var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
			var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
			var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
			var значениеAtIndexOrDefault = helpers.значениеAtIndexOrDefault;

			помощники.расширить(дуга, {
				// Утилита
				_datasetIndex: я.индекс,
				_index: индекс,

				// Желаемые свойства вида
				_модель: {
					x: centerX + chart.offsetX,
					y: centerY + chart.offsetY,
					начальныйУгол: начальныйУгол,
					КонечныйУгол: КонечныйУгол,
					окружность: окружность,
					внешнийРадиус: внешнийРадиус,
					внутреннийРадиус: внутреннийРадиус,
					метка: значениеAtIndexOrDefault(набор_данных.метка, индекс, диаграмма.данные.метки[индекс])
				}
			});

			var model = arc._model;
			// Сбрасывает визуальные стили
			this.removeHoverStyle(дуга);

			// Установите правильные углы, если не выполнялся сброс
			если (!сброс || !animationOpts.animateRotate) {
				если (индекс === 0) {
					model.startAngle = opts.rotation;
				} еще {
					model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
				}

				модель.endAngle = модель.startAngle + модель.окружность;
			}

			дуга.pivot();
		},

		removeHoverStyle: функция(дуга) {
			Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
		},

		рассчитатьВсего: функция() {
			var dataset = this.getDataset();
			var meta = this.getMeta();
			общая переменная = 0;
			значение переменной;

			helpers.each(meta.data, function(element, index) {
				значение = набор данных.данные[индекс];
				если (!isNaN(значение) && !элемент.скрытый) {
					итого += Math.abs(значение);
				}
			});

			/* если (всего === 0) {
				всего = NaN;
			}*/

			общая сумма возврата;
		},

		рассчитатьОкружность: функция(значение) {
			var total = this.getMeta().total;
			if (всего > 0 && !isNaN(значение)) {
				вернуть (Math.PI * 2.0) * (Math.abs(значение) / итог);
			}
			возврат 0;
		},

		// получает максимальную ширину границы или наведения для правильного масштабирования круговых диаграмм
		getMaxBorderWidth: функция(дуги) {
			вар макс = 0;
			var index = этот.индекс;
			var длина = arcs.длина;
			var borderWidth;
			var hoverWidth;

			для (var i = 0; i < длина; i++) {
				borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
				hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;

				макс = borderWidth > макс ? borderWidth : макс;
				макс = hoverWidth > макс ? hoverWidth : макс;
			}
			возврат макс;
		}
	});
};

},{"25":25,"40":40,"45":45}],18:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
элементы переменной = require(40);
var helpers = require(45);

defaults._set('строка', {
	showLines: правда,
	spanGaps: ложь,

	наведите курсор: {
		режим: «метка»
	},

	весы: {
		xAxes: [{
			тип: «категория»,
			идентификатор: 'x-axis-0'
		}],
		yAxes: [{
			тип: «линейный»,
			идентификатор: 'y-ось-0'
		}]
	}
});

модуль.экспорты = функция(Диаграмма) {

	функция lineEnabled(набор данных, параметры) {
		return helpers.valueOrDefault(dataset.showLine, options.showLines);
	}

	Chart.controllers.line = Chart.DatasetController.extend({

		datasetElementType: элементы.Линия,

		dataElementType: элементы.Point,

		обновление: функция(сброс) {
			var me = это;
			var meta = me.getMeta();
			var line = meta.dataset;
			var points = meta.data || [];
			var options = me.chart.options;
			var lineElementOptions = options.elements.line;
			var scale = me.getScaleForId(meta.yAxisID);
			вар i, илен, обычай;
			набор данных вар = me.getDataset();
			var showLine = lineEnabled(набор данных, параметры);

			// Обновить строку
			если (показатьСтроку) {
				custom = строка.custom || {};

				// Совместимость: если свойства определены только со старым именем, используйте эти значения
				если ((dataset.tension !== не определено) && (dataset.lineTension === не определено)) {
					dataset.lineTension = dataset.tension;
				}

				// Утилита
				линия._масштаб = масштаб;
				line._datasetIndex = me.index;
				// Данные
				линия._дети = точки;
				// Модель
				линия._модель = {
					// Появление
					// По умолчанию линии обрываются при нулевых значениях, согласно
					// на https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
					// Эта опция дает линиям возможность перекрывать пробелы
					spanGaps: dataset.spanGaps ? dataset.spanGaps: options.spanGaps,
					натяжение: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
					borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
					borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
					borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
					borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
					borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
					fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
					steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
					cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),
				};

				линия.pivot();
			}

			// Обновление точек
			для (i = 0, ilen = точек.длина; i < ilen; ++i) {
				я.обновитьЭлемент(точки[i], i, сброс);
			}

			если (showLine && линия._модель.напряжение !== 0) {
				я.updateBezierControlPoints();
			}

			// Теперь поверните точку для анимации
			для (i = 0, ilen = точек.длина; i < ilen; ++i) {
				точки[i].pivot();
			}
		},

		getPointBackgroundColor: функция(точка, индекс) {
			var backgroundColor = this.chart.options.elements.point.backgroundColor;
			var dataset = this.getDataset();
			var custom = point.custom || {};

			если (пользовательский.цвет фона) {
				Цвет фона = пользовательский.Цвет фона;
			} Еще если (dataset.pointBackgroundColor) {
				backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
			} иначе если (набор данных.цвет_фона) {
				фоновый цвет = набор данных.фоновый цвет;
			}

			вернуть фоновый цвет;
		},

		getPointBorderColor: функция(точка, индекс) {
			var borderColor = this.chart.options.elements.point.borderColor;
			var dataset = this.getDataset();
			var custom = point.custom || {};

			если (пользовательский.цвет границы) {
				borderColor = пользовательский.borderColor;
			} иначе если (dataset.pointBorderColor) {
				borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
			} иначе если (dataset.borderColor) {
				borderColor = набор данных.borderColor;
			}

			вернуть borderColor;
		},

		getPointBorderWidth: функция(точка, индекс) {
			var borderWidth = this.chart.options.elements.point.borderWidth;
			var dataset = this.getDataset();
			var custom = point.custom || {};

			если (!isNaN(пользовательская.ширина границы)) {
				borderWidth = custom.borderWidth;
			} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
				borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
			} иначе если (!isNaN(набор_данных.ширина_границы)) {
				borderWidth = набор данных.borderWidth;
			}

			вернуть borderWidth;
		},

		updateElement: функция(точка, индекс, сброс) {
			var me = это;
			var meta = me.getMeta();
			var custom = point.custom || {};
			набор данных вар = me.getDataset();
			var datasetIndex = me.index;
			значение var = dataset.data[индекс];
			var yScale = me.getScaleForId(meta.yAxisID);
			var xScale = me.getScaleForId(meta.xAxisID);
			var pointOptions = me.chart.options.elements.point;
			переменная x, y;

			// Совместимость: если свойства определены только со старым именем, используйте эти значения
			если ((dataset.radius !== не определено) && (dataset.pointRadius === не определено)) {
				dataset.pointRadius = dataset.radius;
			}
			если ((dataset.hitRadius !== не определено) && (dataset.pointHitRadius === не определено)) {
				dataset.pointHitRadius = dataset.hitRadius;
			}

			x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
			y = сброс ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);

			// Утилита
			точка._xScale = xScale;
			точка._yScale = yScale;
			point._datasetIndex = datasetIndex;
			точка._индекс = индекс;

			// Желаемые свойства вида
			точка._модель = {
				х: х,
				у: у,
				пропустить: custom.skip || isNaN(x) || isNaN(у),
				// Появление
				радиус: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
				pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
				Цвет фона: me.getPointBackgroundColor(точка, индекс),
				borderColor: me.getPointBorderColor(точка, индекс),
				borderWidth: me.getPointBorderWidth(точка, индекс),
				натяжение: meta.dataset._model ? meta.dataset._model.натяжение : 0,
				steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
				// Подсказка
				hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
			};
		},

		calculatePointY: функция(значение, индекс, datasetIndex) {
			var me = это;
			var chart = я.диаграмма;
			var meta = me.getMeta();
			var yScale = me.getScaleForId(meta.yAxisID);
			var sumPos = 0;
			var sumNeg = 0;
			var i, ds, dsMeta;

			если (yScale.options.stacked) {
				для (i = 0; i < datasetIndex; i++) {
					ds = chart.data.datasets[i];
					dsMeta =chart.getDatasetMeta(i);
					если (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
						var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
						если (stackedRightValue < 0) {
							sumNeg += stackedRightValue || 0;
						} еще {
							sumPos += stackedRightValue || 0;
						}
					}
				}

				var rightValue = Number(yScale.getRightValue(value));
				если (правильноеЗначение < 0) {
					вернуть yScale.getPixelForValue(sumNeg + rightValue);
				}
				вернуть yScale.getPixelForValue(sumPos + rightValue);
			}

			вернуть yScale.getPixelForValue(значение);
		},

		updateBezierControlPoints: функция() {
			var me = это;
			var meta = me.getMeta();
			область вар = me.chart.chartArea;
			var Points = (meta.data || []);
			вар я, ilen, точка, модель, controlPoints;

			// Учитывать только те точки, которые нарисованы в случае использования опции spanGaps
			если (meta.dataset._model.spanGaps) {
				точки = точки.фильтр(функция(pt) {
					возврат !pt._model.skip;
				});
			}

			функция capControlPoint(pt, min, max) {
				вернуть Math.max(Math.min(pt, max), min);
			}

			если (meta.dataset._model.cubicInterpolationMode === 'монотонный') {
				helpers.splineCurveMonotone(точки);
			} еще {
				для (i = 0, ilen = точек.длина; i < ilen; ++i) {
					точка = точки[i];
					модель = точка._модель;
					controlPoints = helpers.splineCurve(
						helpers.previousItem(точки, i)._model,
						модель,
						helpers.nextItem(точки, i)._модель,
						meta.dataset._model.tension
					);
					модель.controlPointPreviousX = controlPoints.previous.x;
					модель.controlPointPreviousY = controlPoints.previous.y;
					модель.controlPointNextX = controlPoints.next.x;
					модель.controlPointNextY = controlPoints.next.y;
				}
			}

			если (me.chart.options.elements.line.capBezierPoints) {
				для (i = 0, ilen = точек.длина; i < ilen; ++i) {
					модель = точки[i]._модель;
					model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
					model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
					model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
					model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
				}
			}
		},

		рисовать: функция() {
			var me = это;
			var chart = я.диаграмма;
			var meta = me.getMeta();
			var points = meta.data || [];
			var area = chart.chartArea;
			var ilen = точки.длина;
			переменная i = 0;

			helpers.canvas.clipArea(chart.ctx, area);

			если (lineEnabled(me.getDataset(), chart.options)) {
				meta.dataset.draw();
			}

			helpers.canvas.unclipArea(chart.ctx);

			// Нарисуем точки
			для (; i < ilen; ++i) {
				точки[i].draw(площадь);
			}
		},

		setHoverStyle: функция(точка) {
			// Точка
			var dataset = this.chart.data.datasets[point._datasetIndex];
			var индекс = точка._индекс;
			var custom = point.custom || {};
			var model = точка._модель;

			model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
			model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
		},

		removeHoverStyle: функция(точка) {
			var me = это;
			var dataset = me.chart.data.datasets[point._datasetIndex];
			var индекс = точка._индекс;
			var custom = point.custom || {};
			var model = точка._модель;

			// Совместимость: если свойства определены только со старым именем, используйте эти значения
			если ((dataset.radius !== не определено) && (dataset.pointRadius === не определено)) {
				dataset.pointRadius = dataset.radius;
			}

			model.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
			model.backgroundColor = me.getPointBackgroundColor(точка, индекс);
			model.borderColor = me.getPointBorderColor(точка, индекс);
			model.borderWidth = me.getPointBorderWidth(точка, индекс);
		}
	});
};

},{"25":25,"40":40,"45":45}],19:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
элементы переменной = require(40);
var helpers = require(45);

defaults._set('polarArea', {
	шкала: {
		тип: 'radialLinear',
		Угловые линии: {
			дисплей: ложь
		},
		Линии сетки: {
			круговой: истинный
		},
		pointМетки: {
			дисплей: ложь
		},
		тики: {
			beginAtZero: правда
		}
	},

	// Boolean - Анимировать ли вращение диаграммы
	анимация: {
		animateRotate: правда,
		animateScale: правда
	},

	начальный угол: -0,5 * Матем.ПИ,
	legendCallback: функция(диаграмма) {
		переменная текст = [];
		text.push('<ul class="' + chart.id + '-legend">');

		var data = chart.data;
		var datasets = данные.datasets;
		var labels = данные.метки;

		если (наборы данных.длина) {
			для (var i = 0; i < datasets[0].data.length; ++i) {
				text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
				если (метки[i]) {
					текст.push(метки[i]);
				}
				текст.push('</li>');
			}
		}

		текст.push('</ul>');
		вернуть текст.join('');
	},
	легенда: {
		метки: {
			generateLabels: функция(диаграмма) {
				var data = chart.data;
				если (data.labels.length && data.datasets.length) {
					вернуть данные.метки.карта(функция(метка, i) {
						вар мета =chart.getDatasetMeta(0);
						var ds = data.datasets[0];
						var arc = meta.data[i];
						var custom = arc.custom || {};
						var значениеПоИндексуИлиПоУмолчанию = helpers.значениеПоИндексуИлиПоУмолчанию;
						var arcOpts = chart.options.elements.arc;
						var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
						var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
						var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

						возвращаться {
							текст: этикетка,
							fillStyle: заполнить,
							strokeStyle: инсульт,
							Ширина линии: ч/б,
							скрытый: isNaN(ds.data[i]) || meta.data[i].hidden,

							// Дополнительные данные, используемые для переключения правильного элемента
							индекс: я
						};
					});
				}
				возвращаться [];
			}
		},

		onClick: функция(e, legendItem) {
			var index = legendItem.index;
			var chart = эта.диаграмма;
			вар i, илен, мета;

			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
				мета = диаграмма.getDatasetMeta(i);
				метаданные[индекс].скрытый = !мета.данные[индекс].скрытый;
			}

			диаграмма.обновление();
		}
	},

	// Необходимо переопределить их, чтобы задать удобные значения по умолчанию
	подсказки: {
		обратные вызовы: {
			заголовок: функция() {
				возвращаться '';
			},
			метка: функция(элемент, данные) {
				return data.labels[item.index] + ': ' + item.yLabel;
			}
		}
	}
});

модуль.экспорты = функция(Диаграмма) {

	Chart.controllers.polarArea = Chart.DatasetController.extend({

		dataElementType: элементы.Arc,

		ссылкаВесы: helpers.noop,

		обновление: функция(сброс) {
			var me = это;
			var chart = я.диаграмма;
			варchartArea =chart.chartArea;
			var meta = me.getMeta();
			var opts = chart.options;
			var arcOpts = opts.elements.arc;
			var minSize = Math.min(chartArea.right -chartArea.left,chartArea.bottom -chartArea.top);
			chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
			chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
			chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();

			я.внешнийРадиус = диаграмма.внешнийРадиус - (диаграмма.радиусДлина * я.индекс);
			me.innerRadius = me.outerRadius - chart.radiusLength;

			meta.count = me.countVisibleElements();

			помощники.каждый(мета.данные, функция(дуга, индекс) {
				me.updateElement(дуга, индекс, сброс);
			});
		},

		updateElement: функция(дуга, индекс, сброс) {
			var me = это;
			var chart = я.диаграмма;
			набор данных вар = me.getDataset();
			var opts = chart.options;
			var animationOpts = opts.animation;
			var scale = chart.scale;
			var labels = chart.data.labels;

			var circumference = me.calculateCircumference(dataset.data[index]);
			var centerX = scale.xCenter;
			var centerY = scale.yCenter;

			// Если перед нами NaN-данные, нам необходимо правильно рассчитать начальный угол.
			// Мы могли бы быть здесь гораздо более эффективными, но маловероятно, что полярная диаграмма будет содержать много данных
			var visibleCount = 0;
			var meta = me.getMeta();
			для (var i = 0; i < индекс; ++i) {
				если (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {
					++visibleCount;
				}
			}

			// var negHalfPI = -0.5 * Math.PI;
			вар datasetStartAngle = opts.startAngle;
			var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
			вар startAngle = datasetStartAngle + (окружность * видимыйCount);
			вар endAngle = startAngle + (arc.hidden? 0: окружность);

			var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);

			помощники.расширить(дуга, {
				// Утилита
				_datasetIndex: я.индекс,
				_index: индекс,
				_масштаб: масштаб,

				// Желаемые свойства вида
				_модель: {
					x: центрX,
					y: центрY,
					Внутренний радиус: 0,
					outerRadius: сброс ? resetRadius : расстояние,
					startAngle: сброс && анимацииOpts.animateRotate? набор данныхStartAngle: startAngle,
					endAngle: сброс && animationOpts.animateRotate ? datasetStartAngle : endAngle,
					метка: helpers.valueAtIndexOrDefault(метки, индекс, метки[индекс])
				}
			});

			// Применить стиль границы и заливки
			я.removeHoverStyle(дуга);

			дуга.pivot();
		},

		removeHoverStyle: функция(дуга) {
			Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
		},

		countVisibleElements: функция() {
			var dataset = this.getDataset();
			var meta = this.getMeta();
			количество переменных = 0;

			helpers.each(meta.data, function(element, index) {
				если (!isNaN(набор_данных.данные[индекс]) && !элемент.скрытый) {
					количество++;
				}
			});

			количество возвратов;
		},

		рассчитатьОкружность: функция(значение) {
			var count = this.getMeta().count;
			если (количество > 0 && !isNaN(значение)) {
				вернуть (2 * Математика.ПИ) / количество;
			}
			возврат 0;
		}
	});
};

},{"25":25,"40":40,"45":45}],20:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
элементы переменной = require(40);
var helpers = require(45);

defaults._set('радар', {
	шкала: {
		тип: 'radialLinear'
	},
	элементы: {
		линия: {
			натяжение: 0 // нет Безье в радаре
		}
	}
});

модуль.экспорты = функция(Диаграмма) {

	Chart.controllers.radar = Chart.DatasetController.extend({

		datasetElementType: элементы.Линия,

		dataElementType: элементы.Point,

		ссылкаВесы: helpers.noop,

		обновление: функция(сброс) {
			var me = это;
			var meta = me.getMeta();
			var line = meta.dataset;
			var points = метаданные;
			var custom = строка.custom || {};
			набор данных вар = me.getDataset();
			var lineElementOptions = me.chart.options.elements.line;
			var scale = me.chart.scale;

			// Совместимость: если свойства определены только со старым именем, используйте эти значения
			если ((dataset.tension !== не определено) && (dataset.lineTension === не определено)) {
				dataset.lineTension = dataset.tension;
			}

			helpers.extend(meta.dataset, {
				// Утилита
				_datasetIndex: я.индекс,
				_масштаб: масштаб,
				// Данные
				_дети: баллы,
				_цикл: правда,
				// Модель
				_модель: {
					// Появление
					натяжение: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
					borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
					fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
					borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
					borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
					borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
					borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
				}
			});

			meta.dataset.pivot();

			// Обновление точек
			помощники.каждый(точки, функция(точка, индекс) {
				me.updateElement(точка, индекс, сброс);
			}, мне);

			// Обновить контрольные точки Безье
			я.updateBezierControlPoints();
		},
		updateElement: функция(точка, индекс, сброс) {
			var me = это;
			var custom = point.custom || {};
			набор данных вар = me.getDataset();
			var scale = me.chart.scale;
			var pointElementOptions = me.chart.options.elements.point;
			var pointPosition = Scale.getPointPositionForValue(index, dataset.data[index]);

			// Совместимость: если свойства определены только со старым именем, используйте эти значения
			если ((dataset.radius !== не определено) && (dataset.pointRadius === не определено)) {
				dataset.pointRadius = dataset.radius;
			}
			если ((dataset.hitRadius !== не определено) && (dataset.pointHitRadius === не определено)) {
				dataset.pointHitRadius = dataset.hitRadius;
			}

			помощники.расширить(точка, {
				// Утилита
				_datasetIndex: я.индекс,
				_index: индекс,
				_масштаб: масштаб,

				// Желаемые свойства вида
				_модель: {
					x: сброс ? scale.xCenter : pointPosition.x, // значение не используется в масштабе набора данных, но нам нужен согласованный API между масштабами
					y: сброс ? scale.yCenter : pointPosition.y,

					// Появление
					натяжение: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
					радиус: пользовательский.радиус ? пользовательский.радиус : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
					backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
					borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
					borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
					pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),

					// Подсказка
					hitRadius: custom.hitRadius? custom.hitRadius: helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
				}
			});

			точка._модель.пропустить = пользовательский.пропустить ? пользовательский.пропустить : (isNaN(точка._модель.x) || isNaN(точка._модель.y));
		},
		updateBezierControlPoints: функция() {
			варchartArea = this.chart.chartArea;
			var meta = this.getMeta();

			помощники.каждый(мета.данные, функция(точка, индекс) {
				var model = точка._модель;
				вар controlPoints = helpers.splineCurve(
					helpers.previousItem(мета.данные, индекс, правда)._модель,
					модель,
					helpers.nextItem(мета.данные, индекс, правда)._модель,
					модель.напряжение
				);

				// Не допускаем выхода кривой Безье за ​​пределы графика
				model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
				model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);

				model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
				model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);

				// Теперь поверните точку для анимации
				точка.pivot();
			});
		},

		setHoverStyle: функция(точка) {
			// Точка
			var dataset = this.chart.data.datasets[point._datasetIndex];
			var custom = point.custom || {};
			var индекс = точка._индекс;
			var model = точка._модель;

			model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
		},

		removeHoverStyle: функция(точка) {
			var dataset = this.chart.data.datasets[point._datasetIndex];
			var custom = point.custom || {};
			var индекс = точка._индекс;
			var model = точка._модель;
			var pointElementOptions = this.chart.options.elements.point;

			model.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);
			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
		}
	});
};

},{"25":25,"40":40,"45":45}],21:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);

defaults._set('scatter', {
	наведите курсор: {
		режим: «одиночный»
	},

	весы: {
		xAxes: [{
			id: 'x-axis-1', // нужен идентификатор, чтобы наборы данных могли ссылаться на шкалу
			тип: 'linear', // рассеивание не должно использовать ось категории
			позиция: «внизу»
		}],
		yAxes: [{
			идентификатор: 'y-ось-1',
			тип: «линейный»,
			позиция: «левая»
		}]
	},

	showLines: ложь,

	подсказки: {
		обратные вызовы: {
			заголовок: функция() {
				return ''; // не имеет смысла для scatter, так как данные отформатированы как точка
			},
			метка: функция(элемент) {
				вернуть '(' + item.xLabel + ', ' + item.yLabel + ')';
			}
		}
	}
});

модуль.экспорты = функция(Диаграмма) {

	// Диаграммы рассеяния используют линейные контроллеры
	Диаграмма.контроллеров.рассеивание = Диаграмма.контроллеров.линия;

};

},{"25":25}],22:[function(require,module,exports){
/* глобальное окно: ложь */
«использовать строго»;

переменные по умолчанию = require(25);
Элемент var = require(26);
var helpers = require(45);

defaults._set('глобальный', {
	анимация: {
		продолжительность: 1000,
		смягчение: 'easeOutQuart',
		onProgress: помощники.noop,
		onComplete: помощники.noop
	}
});

модуль.экспорты = функция(Диаграмма) {

	Диаграмма.Анимация = Элемент.расширить({
		диаграмма: null, // экземпляр диаграммы, связанный с анимацией
		currentStep: 0, // текущий шаг анимации
		numSteps: 60, // количество шагов по умолчанию
		easing: '', // замедление, используемое для этой анимации
		render: null, // функция рендеринга, используемая службой анимации

		onAnimationProgress: null, // указанный пользователем обратный вызов для срабатывания на каждом шаге анимации
		onAnimationComplete: null, // указанный пользователем обратный вызов, который будет срабатывать после завершения анимации
	});

	Chart.animationService = {
		Продолжительность кадра: 17,
		анимации: [],
		dropFrames: 0,
		запрос: нулевой,

		/**
		 * @param {Chart} chart — диаграмма для анимации.
		 * @param {Chart.Animation} animation — анимация, которую мы будем анимировать.
		 * @param {Number} продолжительность — продолжительность анимации в мс.
		 * @param {Boolean} lazy — если true, диаграмма не помечается как анимированная, чтобы обеспечить более отзывчивое взаимодействие
		 */
		addAnimation: функция(диаграмма, анимация, длительность, ленивый) {
			var animations = this.animations;
			вар i, илен;

			анимация.диаграмма = диаграмма;

			если (!ленивый) {
				диаграмма.анимация = правда;
			}

			для (i = 0, ilen = анимация.длина; i < ilen; ++i) {
				если (анимации[i].chart === chart) {
					анимации[i] = анимация;
					возвращаться;
				}
			}

			анимации.push(анимация);

			// Если в очереди нет анимаций, вручную запустите дайджест, за неимением лучшего слова
			если (анимация.длина === 1) {
				этот.requestAnimationFrame();
			}
		},

		ОтменаАнимации: функция(диаграмма) {
			var index = helpers.findIndex(this.animations, function(animation) {
				вернуть анимацию.диаграмма === диаграмма;
			});

			если (индекс !== -1) {
				эта.анимация.сращивание(индекс, 1);
				диаграмма.анимация = ложь;
			}
		},

		requestAnimationFrame: функция() {
			var me = это;
			если (я.запрос === null) {
				// Пропускать запросы кадров анимации, пока не будет выполнен активный.
				// Это может произойти при обработке событий мыши, например 'mousemove'
				// и события 'mouseout' вызовут несколько рендеров.
				я.запрос = помощники.запросAnimFrame.вызов(окно, функция() {
					я.запрос = null;
					я.startDigest();
				});
			}
		},

		/**
		 * @частный
		 */
		startDigest: функция() {
			var me = это;
			var startTime = Дата.сейчас();
			var framesToDrop = 0;

			если (я.dropFrames > 1) {
				framesToDrop = Math.floor(me.dropFrames);
				я.dropFrames = я.dropFrames % 1;
			}

			я.advance(1 + framesToDrop);

			var endTime = Дата.сейчас();

			me.dropFrames += (endTime - startTime) / me.frameDuration;

			// Есть ли у нас еще что-то для анимации?
			если (me.animations.length > 0) {
				я.requestAnimationFrame();
			}
		},

		/**
		 * @частный
		 */
		продвижение: функция(количество) {
			var animations = this.animations;
			var анимация, диаграмма;
			переменная i = 0;

			в то время как (i < анимация.длина) {
				анимация = анимации[i];
				диаграмма = анимация.диаграмма;

				анимация.текущийШаг = (анимация.текущийШаг || 0) + количество;
				анимация.текущийШаг = Математика.мин(анимация.текущийШаг, анимация.числоШагов);

				helpers.callback(animation.render, [диаграмма, анимация], диаграмма);
				helpers.callback(animation.onAnimationProgress, [анимация], диаграмма);

				если (анимация.текущийШаг >= анимация.числоШагов) {
					helpers.callback(animation.onAnimationComplete, [анимация], диаграмма);
					диаграмма.анимация = ложь;
					анимации.splice(i, 1);
				} еще {
					++я;
				}
			}
		}
	};

	/**
	 * Предоставлено для обратной совместимости, вместо этого используйте Chart.Animation
	 * @prop Chart.Анимация#animationObject
	 * @deprecated с версии 2.6.0
	 * @todo удалено в версии 3
	 */
	Object.defineProperty(Диаграмма.Анимация.прототип, 'animationObject', {
		получить: функция() {
			верните это;
		}
	});

	/**
	 * Предоставлено для обратной совместимости, вместо этого используйте Chart.Animation#chart
	 * @prop Chart.Animation#chartInstance
	 * @deprecated с версии 2.6.0
	 * @todo удалено в версии 3
	 */
	Object.defineProperty(Chart.Animation.prototype, 'chartInstance', {
		получить: функция() {
			вернуть эту.диаграмму;
		},
		набор: функция(значение) {
			эта.диаграмма = значение;
		}
	});

};

},{"25":25,"26":26,"45":45}],23:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
var helpers = require(45);
var Взаимодействие = require(28);
var layouts = require(30);
var platform = require(48);
var плагины = require(31);

модуль.экспорты = функция(Диаграмма) {

	// Создать словарь типов диаграмм, чтобы разрешить расширение существующих типов
	Типы.диаграмм = {};

	// Сохраняем ссылку на каждый экземпляр, что позволяет нам глобально изменять размер экземпляров диаграммы при изменении размера окна.
	// Метод Destroy на диаграмме удалит экземпляр диаграммы из этой ссылки.
	Chart.instances = {};

	// Доступны контроллеры для визуализации набора данных, например, столбчатая диаграмма, линия, срез и т. д.
	Chart.controllers = {};

	/**
	 * Инициализирует заданную конфигурацию с глобальными и диаграммными значениями по умолчанию.
	 */
	функция initConfig(config) {
		конфиг = конфиг || {};

		// НЕ используйте configMerge() для объекта данных, поскольку этот метод объединяет массивы
		// и, таким образом, изменятся ссылки на метки и наборы данных, что сделает невозможным обновление данных.
		var data = config.data = config.data || {};
		данные.наборы_данных = данные.наборы_данных || [];
		данные.метки = данные.метки || [];

		config.options = helpers.configMerge(
			defaults.глобальные,
			по умолчанию[config.type],
			параметры конфигурации || {});

		вернуть конфигурацию;
	}

	/**
	 * Обновляет конфигурацию диаграммы
	 * @param chart {Chart} диаграмма для обновления параметров
	 */
	функция updateConfig(диаграмма) {
		вар newOptions =chart.options;

		помощники.каждый(диаграмма.масштабы, функция(масштаб) {
			layouts.removeBox(диаграмма, масштаб);
		});

		newOptions = helpers.configMerge(
			Chart.defaults.global,
			Chart.defaults[chart.config.type],
			новыеПараметры);

		параметры.диаграммы = параметры.конфигурации.диаграммы = новыеПараметры;
		диаграмма.ensureScalesHaveIDs();
		диаграмма.buildOrUpdateScales();
		// Подсказка
		chart.tooltip._options = newOptions.tooltips;
		chart.tooltip.initialize();
	}

	функция positionIsHorizontal(позиция) {
		возврат позиции === 'верх' || позиции === 'низ';
	}

	helpers.extend(Chart.prototype, /** @lends Chart */ {
		/**
		 * @частный
		 */
		конструкция: функция(элемент, конфигурация) {
			var me = это;

			конфигурация = initConfig(конфигурация);

			var context = platform.acquireContext(item, config);
			var холст = контекст && контекст.холст;
			var height = холст && Canvas.height;
			var width = холст && холст.ширина;

			я.id = помощники.uid();
			я.ctx = контекст;
			я.холст = холст;
			я.config = конфигурация;
			я.ширина = ширина;
			я.рост = высота;
			me.aspectRatio = высота ? ширина / высота : null;
			мои.опции = конфигурационные.опции;
			я._bufferedRender = false;

			/**
			 * Для обеспечения обратной совместимости Chart и Chart.Controller были объединены,
			 * «экземпляр» все еще необходимо определить, поскольку он может вызываться из плагинов.
			 * @prop Диаграмма#диаграмма
			 * @deprecated с версии 2.6.0
			 * @todo удалено в версии 3
			 * @частный
			 */
			я.диаграмма = я;
			я.контроллер = я; // диаграмма.контроллер диаграммы #начало

			// Добавить экземпляр диаграммы в глобальное пространство имен
			Chart.instances[me.id] = me;

			// Определить псевдоним для данных конфигурации: `chart.data === chart.config.data`
			Объект.defineProperty(я, 'данные', {
				получить: функция() {
					вернуть мне.config.data;
				},
				набор: функция(значение) {
					me.config.data = значение;
				}
			});

			если (!контекст || !холст) {
				// Данный элемент не является совместимым элементом context2d, давайте вернемся перед финализацией
				// инициализация диаграммы, но после установки основных свойств диаграммы/контроллера, которые
				// может помочь выяснить, что диаграмма недействительна (например, chart.canvas !== null);
				// https://github.com/chartjs/Chart.js/issues/2807
				console.error("Не удалось создать диаграмму: невозможно получить контекст из указанного элемента");
				возвращаться;
			}

			я.инициализировать();
			я.обновление();
		},

		/**
		 * @частный
		 */
		инициализировать: функция() {
			var me = это;

			// Перед уведомлением плагина init
			плагины.notify(me, 'beforeInit');

			helpers.retinaScale(я, я.options.devicePixelRatio);

			я.bindEvents();

			если (я.опции.отзывчивый) {
				// Первоначальное изменение размера перед рисованием диаграммы (должно быть тихим, чтобы сохранить начальную анимацию).
				я.изменить размер(истина);
			}

			// Убедитесь, что весы имеют идентификаторы и созданы, прежде чем создавать какие-либо контроллеры.
			я.ensureScalesHaveIDs();
			я.buildOrUpdateScales();
			я.initToolTip();

			// После уведомления плагина init
			плагины.notify(me, 'afterInit');

			верни меня;
		},

		очистить: функция() {
			помощники.холст.очистить(это);
			верните это;
		},

		остановка: функция() {
			// Останавливает любой текущий цикл анимации
			Chart.animationService.cancelAnimation(это);
			верните это;
		},

		изменить размер: функция(тихая) {
			var me = это;
			var options = me.options;
			var холст = я.холст;
			var aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;

			// ширина и высота рендеринга холста будут преобразованы в целые числа, поэтому убедитесь, что
			// стиль отображения холста использует те же целочисленные значения, чтобы избежать эффекта размытия.

			// Установите 0 вместо canvas.size, поскольку размер по умолчанию равен 300x150, если элемент сжат
			var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
			var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectsRatio : helpers.getMaximumHeight(canvas)));

			если (я.ширина === новаяШирина && я.высота === новаяВысота) {
				возвращаться;
			}

			холст.ширина = моя.ширина = новаяШирина;
			холст.высота = моя.высота = новаяВысота;
			холст.стиль.ширина = новаяШирина + 'px';
			холст.стиль.высота = новаяВысота + 'px';

			helpers.retinaScale(я, параметры.devicePixelRatio);

			если (!тихий) {
				// Уведомить все плагины об изменении размера
				var newSize = {ширина: новаяШирина, высота: новаяВысота};
				plugins.notify(me, 'resize', [newSize]);

				// Уведомить об изменении размера
				если (me.options.onResize) {
					я.опции.onResize(я, новыйРазмер);
				}

				я.стоп();
				я.обновить(я.опции.адаптивнаяАнимацияПродолжительность);
			}
		},

		ensureScalesHaveIDs: функция() {
			var options = this.options;
			var scalesOptions = options.scales || {};
			var scaleOptions = параметры.масштаб;

			helpers.each(scalesOptions.xAxes, функция(xAxisOptions, индекс) {
				xAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);
			});

			helpers.each(scalesOptions.yAxes, функция(yAxisOptions, индекс) {
				yAxisOptions.id = yAxisOptions.id || ('y-ось-' + индекс);
			});

			если (scaleOptions) {
				scaleOptions.id = scaleOptions.id || 'масштаб';
			}
		},

		/**
		 * Создает карту идентификаторов масштаба для масштабируемого объекта для будущего поиска.
		 */
		buildOrUpdateScales: функция() {
			var me = это;
			var options = me.options;
			var scales = me.scales || {};
			var элементы = [];
			var обновлено = Object.keys(scales).reduce(function(obj, id) {
				объект[id] = ложь;
				вернуть объект;
			}, {});

			если (опции.масштабы) {
				элементы = элементы.concat(
					(options.scales.xAxes || []).map(function(xAxisOptions) {
						вернуть {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};
					}),
					(options.scales.yAxes || []).map(function(yAxisOptions) {
						return {options: yAxisOptions, dtype: 'linear', dposition: 'left'};
					})
				);
			}

			если (параметры.масштаб) {
				элементы.push({
					параметры: параметры.масштаб,
					dtype: 'radialLinear',
					isDefault: правда,
					позиция: 'chartArea'
				});
			}

			помощники.каждый(элементы, функция(элемент) {
				var scaleOptions = item.options;
				var id = scaleOptions.id;
				var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);

				если (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
					scaleOptions.position = item.dposition;
				}

				обновлено[id] = true;
				переменная шкала = null;
				если (id в весах && весы[id].type === scaleType) {
					масштаб = масштабы[id];
					масштаб.options = scaleOptions;
					масштаб.ctx = я.ctx;
					масштаб.диаграмма = я;
				} еще {
					var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);
					если (!scaleClass) {
						возвращаться;
					}
					масштаб = новый класс масштаба({
						я сделал,
						тип: scaleType,
						параметры: scaleOptions,
						ctx: я.ctx,
						диаграмма: я
					});
					весы[масштаб.id] = масштаб;
				}

				масштаб.mergeTicksOptions();

				// TODO(SB): Я думаю, мы должны иметь возможность удалить этот пользовательский случай (options.scale)
				// и рассматривать его как обычную часть масштаба карты "масштабов"! Это было бы
				// сделать логику проще и удалить часть бесполезного? пользовательского кода.
				если (item.isDefault) {
					я.масштаб = масштаб;
				}
			});
			// очистить отброшенные весы
			помощники.каждый(обновлено, функция(hasUpdated, id) {
				если (!hasUpdated) {
					удалить весы[id];
				}
			});

			я.весы = весы;

			Chart.scaleService.addScalesToLayout(this);
		},

		buildOrUpdateControllers: функция() {
			var me = это;
			типы переменных = [];
			var newControllers = [];

			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				вар мета = me.getDatasetMeta(datasetIndex);
				var type = dataset.type || me.config.type;

				если (мета.тип && мета.тип !== тип) {
					me.destroyDatasetMeta(datasetIndex);
					мета = me.getDatasetMeta(datasetIndex);
				}
				мета.тип = тип;

				типы.push(мета.тип);

				если (мета.контроллер) {
					meta.controller.updateIndex(datasetIndex);
					meta.controller.linkScales();
				} еще {
					var ControllerClass = Chart.controllers[meta.type];
					если (ControllerClass === не определено) {
						throw new Error('"' + meta.type + '" не является типом диаграммы.');
					}

					meta.controller = new ControllerClass(me, datasetIndex);
					newControllers.push(мета.контроллер);
				}
			}, мне);

			вернуть новыеКонтроллеры;
		},

		/**
		 * Сбросить элементы всех наборов данных
		 * @частный
		 */
		resetElements: функция() {
			var me = это;
			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				я.getDatasetMeta(datasetIndex).controller.reset();
			}, мне);
		},

		/**
		* Возвращает диаграмму в состояние до начальной анимации.
		*/
		сброс: функция() {
			этот.сброситьЭлементы();
			эта.подсказка.инициализация();
		},

		обновление: функция(config) {
			var me = это;

			если (!config || typeof config !== 'object') {
				// обратная совместимость
				конфигурация = {
					продолжительность: конфигурация,
					ленивый: аргументы[1]
				};
			}

			обновитьКонфигурацию(я);

			// ссылки на параметры плагинов могли измениться, давайте сделаем кэш недействительным
			// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
			плагины._invalidate(я);

			если (plugins.notify(me, 'beforeUpdate') === false) {
				возвращаться;
			}

			// В случае изменения всего объекта данных
			me.tooltip._data = me.data;

			// Убедитесь, что контроллеры набора данных обновлены и новые контроллеры сброшены
			вар newControllers = me.buildOrUpdateControllers();

			// Убедитесь, что все контроллеры наборов данных имеют правильные счетчики метаданных
			helpers.each(me.data.datasets, function(dataset, datasetIndex) {
				я.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
			}, мне);

			я.updateLayout();

			// Сбросить настройки новых контроллеров можно только после обновления весов.
			если (я.опции.анимация && я.опции.анимация.продолжительность) {
				helpers.each(newControllers, функция(контроллер) {
					контроллер.сброс();
				});
			}

			я.updateDatasets();

			// Необходимо сбросить подсказку, если она отображается с удаленными элементами
			// после обновления.
			я.подсказка.инициализация();

			// Последний активный содержит элементы, которые ранее были в подсказке.
			// Когда мы сбрасываем подсказку, нам нужно ее очистить
			я.lastActive = [];

			// Сделайте это перед рендерингом, чтобы любые плагины, которым нужны финальные обновления масштаба, могли его использовать
			plugins.notify(me, 'afterUpdate');

			если (я._bufferedRender) {
				я._bufferedRequest = {
					продолжительность: config.duration,
					смягчение: config.easing,
					ленивый: config.lazy
				};
			} еще {
				я.рендер(конфигурация);
			}
		},

		/**
		 * Обновляет макет диаграммы, если плагин не возвращает `false` в `beforeLayout`
		 * хук, в этом случае плагины не будут вызываться в `afterLayout`.
		 * @частный
		 */
		updateLayout: функция() {
			var me = это;

			если (plugins.notify(me, 'beforeLayout') === false) {
				возвращаться;
			}

			layouts.update(это, эта.ширина, эта.высота);

			/**
			 * Предусмотрено для обратной совместимости, вместо этого используйте `afterLayout`.
			 * @метод IPlugin#afterScaleUpdate
			 * @deprecated с версии 2.5.0
			 * @todo удалено в версии 3
			 * @частный
			 */
			plugins.notify(me, 'afterScaleUpdate');
			плагины.notify(me, 'afterLayout');
		},

		/**
		 * Обновляет все наборы данных, если плагин не возвращает `false` в `beforeDatasetsUpdate`
		 * хук, в этом случае плагины не будут вызываться при `afterDatasetsUpdate`.
		 * @частный
		 */
		updateDatasets: функция() {
			var me = это;

			если (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
				возвращаться;
			}

			for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
				я.updateDataset(i);
			}

			plugins.notify(me, 'afterDatasetsUpdate');
		},

		/**
		 * Обновляет набор данных по индексу, если плагин не возвращает `false` в `beforeDatasetUpdate`
		 * хук, в этом случае плагины не будут вызываться при `afterDatasetUpdate`.
		 * @частный
		 */
		updateDataset: функция(индекс) {
			var me = это;
			вар мета = me.getDatasetMeta(индекс);
			переменная аргументы = {
				мета: мета,
				индекс: индекс
			};

			если (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
				возвращаться;
			}

			meta.controller.update();

			plugins.notify(me, 'afterDatasetUpdate', [args]);
		},

		рендер: функция(config) {
			var me = это;

			если (!config || typeof config !== 'object') {
				// обратная совместимость
				конфигурация = {
					продолжительность: конфигурация,
					ленивый: аргументы[1]
				};
			}

			var продолжительность = config.duration;
			var lazy = config.lazy;

			если (plugins.notify(me, 'beforeRender') === false) {
				возвращаться;
			}

			var animationOptions = me.options.animation;
			var onComplete = функция(анимация) {
				плагины.notify(me, 'afterRender');
				helpers.callback(animationOptions && animationOptions.onComplete, [анимация], я);
			};

			если (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {
				вар анимация = новый Chart.Animation({
					numSteps: (duration || animationOptions.duration) / 16.66, // 60 кадров в секунду
					смягчение: config.easing || animationOptions.easing,

					рендер: функция(диаграмма, анимационныйобъект) {
						var easingFunction = helpers.easing.effects[animationObject.easing];
						var currentStep = animationObject.currentStep;
						var stepDecimal = currentStep / animationObject.numSteps;

						chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
					},

					onAnimationProgress: animationOptions.onProgress,
					onAnimationComplete: onComplete
				});

				Chart.animationService.addAnimation(я, анимация, длительность, ленивый);
			} еще {
				я.рисовать();

				// См. https://github.com/chartjs/Chart.js/issues/3781
				onComplete(new Chart.Animation({numSteps: 0, chart: me}));
			}

			верни меня;
		},

		рисовать: функция(easingValue) {
			var me = это;

			я.очистить();

			если (helpers.isNullOrUndef(easingValue)) {
				Значение смягчения = 1;
			}

			я.переход(easingValue);

			если (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
				возвращаться;
			}

			// Нарисуем все чешуйки
			помощники.каждый(я.ящики, функция(ящик) {
				box.draw(me.chartArea);
			}, мне);

			если (я.масштаб) {
				я.масштаб.рисовать();
			}

			me.drawDatasets(easingValue);
			me._drawTooltip(easingValue);

			plugins.notify(me, 'afterDraw', [easingValue]);
		},

		/**
		 * @частный
		 */
		переход: функция(easingValue) {
			var me = это;

			for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
				если (я.isDatasetVisible(i)) {
					me.getDatasetMeta(i).controller.transition(easingValue);
				}
			}

			me.tooltip.transition(easingValue);
		},

		/**
		 * Рисует все наборы данных, если плагин не возвращает `false` в `beforeDatasetsDraw`
		 * хук, в этом случае плагины не будут вызываться в `afterDatasetsDraw`.
		 * @частный
		 */
		drawDatasets: функция(easingValue) {
			var me = это;

			если (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
				возвращаться;
			}

			// Рисуем наборы данных в обратном порядке для поддержки правильного размещения строк
			для (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
				если (я.isDatasetVisible(i)) {
					я.drawDataset(i, easingValue);
				}
			}

			plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
		},

		/**
		 * Рисует набор данных по индексу, если плагин не возвращает `false` в `beforeDatasetDraw`
		 * хук, в этом случае плагины не будут вызываться в `afterDatasetDraw`.
		 * @частный
		 */
		drawDataset: функция (индекс, easingValue) {
			var me = это;
			вар мета = me.getDatasetMeta(индекс);
			переменная аргументы = {
				мета: мета,
				индекс: индекс,
				easingValue: easingValue
			};

			если (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
				возвращаться;
			}

			meta.controller.draw(easingValue);

			plugins.notify(me, 'afterDatasetDraw', [args]);
		},

		/**
		 * Рисует подсказку, если плагин не возвращает `false` в `beforeTooltipDraw`
		 * хук, в этом случае плагины не будут вызываться при `afterTooltipDraw`.
		 * @частный
		 */
		_drawTooltip: функция(easingValue) {
			var me = это;
			var tooltip = me.tooltip;
			переменная аргументы = {
				подсказка: подсказка,
				easingValue: easingValue
			};

			если (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
				возвращаться;
			}

			подсказка.draw();

			plugins.notify(me, 'afterTooltipDraw', [args]);
		},

		// Получить один элемент, по которому был сделан щелчок
		// @return : Объект, содержащий индекс набора данных и индекс элемента соответствующего элемента. Также содержит прямоугольник, который был нарисован
		getElementAtEvent: функция(e) {
			вернуть Взаимодействие.режимы.одиночный(это, е);
		},

		getElementsAtEvent: функция(e) {
			вернуть Interaction.modes.label(this, e, {intersect: true});
		},

		getElementsAtXAxis: функция(e) {
			return Interaction.modes['x-axis'](this, e, {intersect: true});
		},

		getElementsAtEventForMode: функция(e, режим, параметры) {
			var method = Взаимодействие.режимы[режим];
			если (тип метода === 'функция') {
				метод возврата(это, е, параметры);
			}

			возвращаться [];
		},

		getDatasetAtEvent: функция(e) {
			вернуть Interaction.modes.dataset(this, e, {intersect: true});
		},

		getDatasetMeta: функция(datasetIndex) {
			var me = это;
			var dataset = me.data.datasets[datasetIndex];
			если (!dataset._meta) {
				набор данных._meta = {};
			}

			вар мета = dataset._meta[me.id];
			если (!мета) {
				мета = набор данных._мета[me.id] = {
					тип: ноль,
					данные: [],
					набор данных: нуль,
					контроллер: нуль,
					скрытый: null, // См. комментарий isDatasetVisible()
					xAxisID: ноль,
					yAxisID: нуль
				};
			}

			вернуть мета;
		},

		getVisibleDatasetCount: функция() {
			количество переменных = 0;
			для (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
				если (этот.isDatasetVisible(i)) {
					количество++;
				}
			}
			количество возвратов;
		},

		isDatasetVisible: функция(datasetIndex) {
			вар мета = this.getDatasetMeta(datasetIndex);

			// meta.hidden — это переопределение скрытого флага для каждого набора данных диаграммы с 3 состояниями: если true или false,
			// значение dataset.hidden игнорируется, иначе, если null, возвращается скрытое состояние набора данных.
			return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
		},

		generateLegend: функция() {
			вернуть this.options.legendCallback(this);
		},

		/**
		 * @частный
		 */
		destroyDatasetMeta: функция(datasetIndex) {
			var id = этот.id;
			var dataset = this.data.datasets[datasetIndex];
			вар мета = dataset._meta && dataset._meta[id];

			если (мета) {
				meta.controller.destroy();
				удалить набор данных._meta[id];
			}
		},

		уничтожить: функция() {
			var me = это;
			var холст = я.холст;
			вар i, илен;

			я.стоп();

			// контроллеры набора данных должны очистить связанные данные
			для (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
				я.destroyDatasetMeta(i);
			}

			если (холст) {
				я.unbindEvents();
				помощники.холст.очистить(я);
				platform.releaseContext(me.ctx);
				я.холст = null;
				я.ctx = null;
			}

			plugins.notify(me, 'destroy');

			удалить Chart.instances[me.id];
		},

		toBase64Image: функция() {
			вернуть this.canvas.toDataURL.apply(this.canvas, arguments);
		},

		initToolTip: функция() {
			var me = это;
			me.tooltip = new Chart.Tooltip({
				_диаграмма: я,
				_chartInstance: me, // устарело, обратная совместимость
				_данные: мои.данные,
				_options: мои.опции.подсказки
			}, мне);
		},

		/**
		 * @частный
		 */
		bindEvents: функция() {
			var me = это;
			вар слушатели = me._listeners = {};
			var прослушиватель = функция() {
				я.eventHandler.apply(я, аргументы);
			};

			помощники.каждый(я.опции.события, функция(тип) {
				platform.addEventListener(я, тип, слушатель);
				слушатели[тип] = слушатель;
			});

			// Элементы, используемые для обнаружения изменения размера, не следует вставлять в неадаптивные диаграммы.
			// См. https://github.com/chartjs/Chart.js/issues/2210
			если (я.опции.отзывчивый) {
				прослушиватель = функция() {
					я.изменить размер();
				};

				platform.addEventListener(me, 'resize', listener);
				слушатели.resize = слушатель;
			}
		},

		/**
		 * @частный
		 */
		unbindEvents: функция() {
			var me = это;
			вар слушатели = me._listeners;
			если (!слушатели) {
				возвращаться;
			}

			удалить меня._слушатели;
			помощники.каждый(слушатели, функция(слушатель, тип) {
				platform.removeEventListener(я, тип, слушатель);
			});
		},

		updateHoverStyle: функция(элементы, режим, включено) {
			var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
			элемент var, i, ilen;

			для (i = 0, ilen = элементы.длина; i < ilen; ++i) {
				элемент = элементы[i];
				если (элемент) {
					this.getDatasetMeta(element._datasetIndex).controller[метод](элемент);
				}
			}
		},

		/**
		 * @частный
		 */
		eventHandler: функция(e) {
			var me = это;
			var tooltip = me.tooltip;

			если (plugins.notify(me, 'beforeEvent', [e]) === false) {
				возвращаться;
			}

			// Буферизуем все вызовы обновлений, чтобы не происходило рендеринга
			я._bufferedRender = true;
			я._bufferedRequest = null;

			переменная изменена = me.handleEvent(e);
			// для плавной анимации подсказок проблема #4989
			// подсказка должна быть источником изменения
			// Обходной путь проверки анимации:
			// tooltip._start будет равен null, если подсказка не анимирована
			если (подсказка) {
				изменено = подсказка._старт
					? tooltip.handleEvent(e)
					: изменено | tooltip.handleEvent(e);
			}

			плагины.notify(me, 'afterEvent', [e]);

			var bufferedRequest = me._bufferedRequest;
			если (bufferedRequest) {
				// Если у нас есть обновление, которое было запущено, нам нужно выполнить обычный рендеринг
				я.рендер(bufferedRequest);
			} иначе если (изменено && !me.animating) {
				// При входе, выходе или изменении элементов анимируйте изменение с помощью опорной точки
				я.стоп();

				// Нам нужно только отрисовать на этом этапе. Обновление приведет к тому, что масштабы будут
				// пересчет, создающий мерцание и использующий больше памяти, чем необходимо.
				я.render(я.options.hover.animationDuration, true);
			}

			я._bufferedRender = false;
			я._bufferedRequest = null;

			верни меня;
		},

		/**
		 * Обработка события
		 * @частный
		 * @param {IEvent} event событие для обработки
		 * @return {Boolean} true, если диаграмму необходимо перерисовать
		 */
		handleEvent: функция(e) {
			var me = это;
			var options = me.options || {};
			вар hoverOptions = options.hover;
			переменная изменена = ложь;

			я.последнийАктивный = я.последнийАктивный || [];

			// Найти активные элементы для наведения и подсказок
			если (e.type === 'mouseout') {
				я.активный = [];
			} еще {
				я.active = я.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
			}

			// Вызвать хук onHover
			// Здесь необходимо вызвать собственное событие, чтобы не нарушить обратную совместимость
			helpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

			если (e.type === 'mouseup' || e.type === 'click') {
				если (опции.onClick) {
					// Используйте e.native здесь для обратной совместимости
					options.onClick.call(я, e.native, я.active);
				}
			}

			// Удалить стиль для последнего активного элемента (даже если он все еще активен)
			если (я.lastActive.длина) {
				me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
			}

			// Встроенный стиль наведения
			если (me.active.length && hoverOptions.mode) {
				я.обновитьHoverStyle(я.активный, hoverOptions.режим, правда);
			}

			изменено = !helpers.arrayEquals(me.active, me.lastActive);

			// Запомнить последние действия
			я.последнийАктивный = я.активный;

			возвращение изменено;
		}
	});

	/**
	 * Предоставлено для обратной совместимости, вместо этого используйте Chart.
	 * @class Диаграмма.Контроллер
	 * @deprecated с версии 2.6.0
	 * @todo удалено в версии 3
	 * @частный
	 */
	Диаграмма.Контроллер = Диаграмма;
};

},{"25":25,"28":28,"30":30,"31":31,"45":45,"48":48}],24:[function(require,module,exports){
«использовать строго»;

var helpers = require(45);

модуль.экспорты = функция(Диаграмма) {

	var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];

	/**
	 * Подключает методы массива, которые добавляют или удаляют значения ('push', pop', 'shift', 'splice',
	 * 'unshift') и уведомить слушателя ПОСЛЕ того, как массив был изменен. Слушатели
	 * вызывается в обратных вызовах onData* (например, onDataPush и т. д.) с теми же аргументами.
	 */
	функция listenArrayEvents(массив, слушатель) {
		если (array._chartjs) {
			массив._chartjs.listeners.push(слушатель);
			возвращаться;
		}

		Объект.defineProperty(массив, '_chartjs', {
			настраиваемый: правда,
			перечислимый: ложный,
			ценить: {
				слушатели: [слушатель]
			}
		});

		arrayEvents.forEach(функция(ключ) {
			метод var = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
			var base = массив[ключ];

			Объект.defineProperty(массив, ключ, {
				настраиваемый: правда,
				перечислимый: ложный,
				значение: функция() {
					var args = Массив.прототип.срез.вызов(аргументы);
					var res = base.apply(this, args);

					помощники.каждый(массив._chartjs.слушатели, функция(объект) {
						если (тип объекта[метод] === 'функция') {
							объект[метод].apply(объект, аргументы);
						}
					});

					возврат рез;
				}
			});
		});
	}

	/**
	 * Удаляет указанный прослушиватель событий массива и очищает дополнительные прикрепленные свойства (такие как
	 * заглушка _chartjs и переопределенные методы), если у массива больше нет прослушивателей.
	 */
	функция unlistenArrayEvents(массив, слушатель) {
		var stub = array._chartjs;
		если (!заглушка) {
			возвращаться;
		}

		вар слушатели = stub.listeners;
		индекс вар = Listeners.indexOf(слушатель);
		если (индекс !== -1) {
			слушатели.splice(индекс, 1);
		}

		если (слушатели.длина > 0) {
			возвращаться;
		}

		arrayEvents.forEach(функция(ключ) {
			удалить массив[ключ];
		});

		удалить массив._chartjs;
	}

	// Базовый класс для всех контроллеров набора данных (линия, столбец и т. д.)
	Chart.DatasetController = function(chart, datasetIndex) {
		this.initialize(chart, datasetIndex);
	};

	helpers.extend(Chart.DatasetController.prototype, {

		/**
		 * Тип элемента, используемый для генерации набора метаданных (например, Chart.element.Line).
		 * @type {Chart.core.element}
		 */
		datasetElementType: нулевой,

		/**
		 * Тип элемента, используемый для генерации метаданных (например, Chart.element.Point).
		 * @type {Chart.core.element}
		 */
		dataElementType: нулевой,

		инициализировать: функция(диаграмма, datasetIndex) {
			var me = это;
			я.диаграмма = диаграмма;
			me.index = datasetIndex;
			я.ссылкаScales();
			я.addElements();
		},

		updateIndex: функция(datasetIndex) {
			этот.индекс = datasetIndex;
		},

		ссылкаScales: функция() {
			var me = это;
			var meta = me.getMeta();
			набор данных вар = me.getDataset();

			если (meta.xAxisID === null || !(meta.xAxisID в me.chart.scales)) {
				meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
			}
			если (meta.yAxisID === null || !(meta.yAxisID в me.chart.scales)) {
				meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
			}
		},

		получитьDataset: функция() {
			вернуть this.chart.data.datasets[this.index];
		},

		getMeta: функция() {
			вернуть this.chart.getDatasetMeta(this.index);
		},

		getScaleForId: функция (scaleID) {
			вернуть this.chart.scales[scaleID];
		},

		сброс: функция() {
			это.обновление(истина);
		},

		/**
		 * @частный
		 */
		уничтожить: функция() {
			если (эти._данные) {
				unlistenArrayEvents(this._data, this);
			}
		},

		создатьMetaDataset: функция() {
			var me = это;
			тип вар = me.datasetElementType;
			возвращаемый тип && новый тип({
				_chart: я.chart,
				_datasetIndex: я.индекс
			});
		},

		createMetaData: функция(индекс) {
			var me = это;
			тип вар = me.dataElementType;
			возвращаемый тип && новый тип({
				_chart: я.chart,
				_datasetIndex: я.индекс,
				_index: индекс
			});
		},

		добавитьЭлементы: функция() {
			var me = это;
			var meta = me.getMeta();
			var data = me.getDataset().data || [];
			var metaData = meta.data;
			вар i, илен;

			for (i = 0, ilen = data.length; i < ilen; ++i) {
				metaData[i] = metaData[i] || me.createMetaData(i);
			}

			meta.dataset = meta.dataset || me.createMetaDataset();
		},

		addElementAndReset: функция (индекс) {
			var элемент = this.createMetaData(index);
			this.getMeta().data.splice(индекс, 0, элемент);
			this.updateElement(элемент, индекс, правда);
		},

		buildOrUpdateElements: функция() {
			var me = это;
			набор данных вар = me.getDataset();
			var data = dataset.data || (набор данных.данные = []);

			// Для того чтобы правильно обрабатывать анимацию добавления/удаления данных (имитируя таким образом
			// графики в реальном времени), нам необходимо отслеживать эти изменения данных и синхронизировать
			// внутренние метаданные соответственно.
			если (я._данные !== данные) {
				если (я._данные) {
					// Этот случай происходит, когда пользователь заменил экземпляр массива данных.
					unlistenArrayEvents(me._data, me);
				}

				listenArrayEvents(данные, я);
				я._данные = данные;
			}

			// Повторная синхронизация метаданных в случае, если пользователь заменил массив данных или если мы пропустили
			// любые обновления и поэтому убедитесь, что мы обрабатываем изменение количества точек данных.
			я.resyncElements();
		},

		обновление: helpers.noop,

		переход: функция(easingValue) {
			var meta = this.getMeta();
			элементы вар = мета.данные || [];
			var ilen = элементы.длина;
			переменная i = 0;

			для (; i < ilen; ++i) {
				элементы[i].transition(easingValue);
			}

			если (мета.набор данных) {
				meta.dataset.transition(easingValue);
			}
		},

		рисовать: функция() {
			var meta = this.getMeta();
			элементы вар = мета.данные || [];
			var ilen = элементы.длина;
			переменная i = 0;

			если (мета.набор данных) {
				meta.dataset.draw();
			}

			для (; i < ilen; ++i) {
				элементы[i].draw();
			}
		},

		removeHoverStyle: функция(элемент, elementOpts) {
			var dataset = this.chart.data.datasets[element._datasetIndex];
			var index = элемент._index;
			var custom = элемент.custom || {};
			var valueOrDefault = helpers.valueAtIndexOrDefault;
			var model = элемент._model;

			model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
			model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
			model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
		},

		setHoverStyle: функция(элемент) {
			var dataset = this.chart.data.datasets[element._datasetIndex];
			var index = элемент._index;
			var custom = элемент.custom || {};
			var valueOrDefault = helpers.valueAtIndexOrDefault;
			var getHoverColor = helpers.getHoverColor;
			var model = элемент._model;

			model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
			model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
			model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
		},

		/**
		 * @частный
		 */
		resyncElements: функция() {
			var me = это;
			var meta = me.getMeta();
			вар данные = me.getDataset().data;
			вар numMeta = мета.данные.длина;
			var numData = data.length;

			если (numData < numMeta) {
				мета.данные.splice(numData, numMeta - numData);
			} иначе если (numData > numMeta) {
				я.insertElements(numMeta, numData - numMeta);
			}
		},

		/**
		 * @частный
		 */
		вставитьЭлементы: функция(начало, количество) {
			для (var i = 0; i < count; ++i) {
				this.addElementAndReset(start + i);
			}
		},

		/**
		 * @частный
		 */
		onDataPush: функция() {
			this.insertElements(this.getDataset().data.length - 1, arguments.length);
		},

		/**
		 * @частный
		 */
		onDataPop: функция() {
			это.getMeta().data.pop();
		},

		/**
		 * @частный
		 */
		onDataShift: функция() {
			это.getMeta().data.shift();
		},

		/**
		 * @частный
		 */
		onDataSplice: функция(начало, количество) {
			this.getMeta().data.splice(начало, количество);
			this.insertElements(начало, аргументы.длина - 2);
		},

		/**
		 * @частный
		 */
		onDataUnshift: функция() {
			this.insertElements(0, arguments.length);
		}
	});

	Chart.DatasetController.extend = helpers.inherits;
};

},{"45":45}],25:[function(require,module,exports){
«использовать строго»;

var helpers = require(45);

модуль.экспорты = {
	/**
	 * @частный
	 */
	_set: функция(область, значения) {
		return helpers.merge(this[scope] || (this[scope] = {}), значения);
	}
};

},{"45":45}],26:[function(require,module,exports){
«использовать строго»;

переменная цвета = требуется(3);
var helpers = require(45);

функция интерполяции(начало, вид, модель, простота) {
	var keys = Object.keys(модель);
	var i, ilen, ключ, фактический, источник, цель, тип, c0, c1;

	for (i = 0, ilen =keys.length; i < ilen; ++i) {
		ключ = ключи[i];

		цель = модель[ключ];

		// если значение добавляется в модель после вызова pivot(), представление
		// не содержит его, поэтому давайте инициализируем представление целевым значением.
		если (!view.hasOwnProperty(ключ)) {
			вид[ключ] = цель;
		}

		фактический = вид[ключ];

		если (фактическое === цель || ключ[0] === '_') {
			продолжать;
		}

		если (!start.hasOwnProperty(ключ)) {
			начало[ключ] = фактический;
		}

		начало = начало[ключ];

		тип = тип цели;

		если (тип === тип происхождения) {
			если (тип === 'строка') {
				c0 = цвет(источник);
				если (c0.действительный) {
					c1 = цвет(цель);
					если (c1.действительный) {
						view[key] = c1.mix(c0, ease).rgbString();
						продолжать;
					}
				}
			} иначе если (тип === 'число' && isFinite(исходное значение) && isFinite(целевое значение)) {
				вид[ключ] = происхождение + (цель - происхождение) * простота;
				продолжать;
			}
		}

		вид[ключ] = цель;
	}
}

var Элемент = функция(конфигурация) {
	helpers.extend(это, конфигурация);
	this.initialize.apply(this, аргументы);
};

helpers.extend(Элемент.prototype, {

	инициализировать: функция() {
		это.скрыто = ложь;
	},

	ось: функция() {
		var me = это;
		если (!me._view) {
			я._вид = помощники.клон(я._модель);
		}
		я._старт = {};
		верни меня;
	},

	переход: функция(легкость) {
		var me = это;
		var model = я._модель;
		var start = я._start;
		var view = me._view;

		// Нет анимации -> Нет перехода
		если (!модель || простота === 1) {
			я._вид = модель;
			я._старт = ноль;
			верни меня;
		}

		если (!просмотр) {
			вид = я._вид = {};
		}

		если (!старт) {
			начать = я._начать = {};
		}

		интерполировать(начало, вид, модель, упрощение);

		верни меня;
	},

	подсказкаPosition: function() {
		возвращаться {
			х: эта._модель.х,
			y: эта._модель.y
		};
	},

	имеетЗначение: функция() {
		вернуть helpers.isNumber(эта._модель.x) && helpers.isNumber(эта._модель.y);
	}
});

Элемент.расширить = помощники.наследовать;

module.exports = Элемент;

},{"3":3,"45":45}],27:[function(require,module,exports){
/* глобальное окно: ложь */
/* глобальный документ: ложь */
«использовать строго»;

переменная цвета = требуется(3);
переменные по умолчанию = require(25);
var helpers = require(45);

модуль.экспорты = функция(Диаграмма) {

	// -- Базовые методы утилиты js

	helpers.configMerge = function(/* объекты ... */) {
		вернуть помощников.объединить(помощников.клонировать(аргументы[0]), [].slice.вызвать(аргументы, 1), {
			слияние: функция(ключ, цель, источник, параметры) {
				var tval = target[ключ] || {};
				var sval = источник[ключ];

				если (ключ === 'весы') {
					// масштабирование конфигурации слияния является сложным. Добавьте нашу собственную функцию здесь для этого
					цель[ключ] = помощники.scaleMerge(tval, sval);
				} иначе если (ключ === 'масштаб') {
					// используется в полярных и радиарных картах, поскольку существует только один масштаб
					target[key] = helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);
				} еще {
					helpers._merger(ключ, цель, источник, параметры);
				}
			}
		});
	};

	helpers.scaleMerge = функция(/* объекты ... */) {
		вернуть помощников.объединить(помощников.клонировать(аргументы[0]), [].slice.вызвать(аргументы, 1), {
			слияние: функция(ключ, цель, источник, параметры) {
				если (ключ === 'xAxes' || ключ === 'yAxes') {
					var slen = источник[ключ].длина;
					вар i, тип, масштаб;

					если (!цель[ключ]) {
						цель[ключ] = [];
					}

					для (i = 0; i < slen; ++i) {
						масштаб = источник[ключ][i];
						тип = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');

						если (i >= цель[ключ].длина) {
							цель[ключ].push({});
						}

						если (!цель[ключ][i].тип || (масштаб.тип && масштаб.тип !== цель[ключ][i].тип)) {
							// новый/нетипизированный масштаб или измененный тип: применим новые значения по умолчанию
							// затем объедините исходный масштаб, чтобы правильно перезаписать значения по умолчанию.
							helpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);
						} еще {
							// тип весов тот же
							helpers.merge(цель[ключ][i], масштаб);
						}
					}
				} еще {
					helpers._merger(ключ, цель, источник, параметры);
				}
			}
		});
	};

	helpers.where = function(collection, filterCallback) {
		если (helpers.isArray(коллекция) && Массив.прототип.фильтр) {
			вернуть коллекцию.фильтр(filterCallback);
		}
		var отфильтровано = [];

		помощники.каждый(коллекция, функция(элемент) {
			если (filterCallback(элемент)) {
				отфильтровано.push(элемент);
			}
		});

		возврат отфильтрован;
	};
	helpers.findIndex = Array.prototype.findIndex ?
		функция(массив, обратный вызов, область действия) {
			вернуть массив.findIndex(обратный вызов, область действия);
		} :
		функция(массив, обратный вызов, область действия) {
			область действия = область действия === не определено ? массив : область действия;
			for (var i = 0, ilen = array.length; i < ilen; ++i) {
				если (callback.call(область, массив[i], i, массив)) {
					вернуть i;
				}
			}
			возврат -1;
		};
	helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
		// По умолчанию начало массива
		если (helpers.isNullOrUndef(startIndex)) {
			начальныйИндекс = -1;
		}
		для (var i = startIndex + 1; i < arrayToSearch.length; i++) {
			var currentItem = arrayToSearch[i];
			если (filterCallback(currentItem)) {
				вернуть текущий элемент;
			}
		}
	};
	helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
		// По умолчанию конец массива
		если (helpers.isNullOrUndef(startIndex)) {
			startIndex = arrayToSearch.length;
		}
		for (var i = startIndex - 1; я >= 0; я--) {
			var currentItem = arrayToSearch[i];
			если (filterCallback(currentItem)) {
				вернуть текущий элемент;
			}
		}
	};

	// -- Математические методы
	helpers.isNumber = функция(n) {
		вернуть !isNaN(parseFloat(n)) && isFinite(n);
	};
	helpers.almostEquals = функция(x, y, эпсилон) {
		вернуть Math.abs(x - y) < эпсилон;
	};
	helpers.almostWhole = функция(x, эпсилон) {
		var rounded = Math.round(x);
		return (((округлено - эпсилон) < x) && ((округлено + эпсилон) > x));
	};
	helpers.max = функция(массив) {
		вернуть массив.reduce(функция(макс, значение) {
			если (!isNaN(значение)) {
				вернуть Math.max(макс, значение);
			}
			возврат макс;
		}, Число.ОТРИЦАТЕЛЬНАЯ_БЕСКОНЕЧНОСТЬ);
	};
	helpers.min = функция(массив) {
		вернуть массив.reduce(функция(min, value) {
			если (!isNaN(значение)) {
				вернуть Math.min(min, значение);
			}
			возврат мин.;
		}, Число.ПОЛОЖИТЕЛЬНАЯ_БЕСКОНЕЧНОСТЬ);
	};
	помощники.знак = Математический.знак ?
		функция(х) {
			вернуть Math.sign(x);
		} :
		функция(х) {
			x = +x; // преобразовать в число
			если (x === 0 || isNaN(x)) {
				вернуть х;
			}
			вернуть x > 0 ? 1 : -1;
		};
	помощники.log10 = Математика.log10 ?
		функция(х) {
			вернуть Math.log10(x);
		} :
		функция(х) {
			var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
			// Проверка на целые степени числа 10,
			// которую необходимо исправить из-за ошибки округления чисел с плавающей точкой.
			вар powerOf10 = Math.round(показатель);
			вар isPowerOf10 = x === Math.pow(10, powerOf10);

			вернуть isPowerOf10 ? powerOf10 : показатель степени;
		};
	helpers.toRadians = функция(градусы) {
		вернуть градусы * (Math.PI / 180);
	};
	helpers.toDegrees = функция (радианы) {
		вернуть радианы * (180 / Math.PI);
	};
	// Получает угол от вертикали до точки относительно центра.
	helpers.getAngleFromPoint = функция(centrePoint, anglePoint) {
		var distanceFromXCenter = anglePoint.x - centrePoint.x;
		var distanceFromYCenter = anglePoint.y - centrePoint.y;
		var radialDistanceFromCenter = Math.sqrt(расстояниеОтXЦентра * расстояниеОтXЦентра + расстояниеОтYЦентра * расстояниеОтYЦентра);

		var angle = Math.atan2(расстояниеотYцентра, расстояниеотXцентра);

		если (угол < (-0,5 * Матем.ПИ)) {
			угол += 2.0 * Math.PI; // убедитесь, что возвращаемый угол находится в диапазоне (-PI/2, 3PI/2]
		}

		возвращаться {
			угол: угол,
			расстояние: радиальноеРасстояниеОтЦентра
		};
	};
	помощники.расстояниеМеждуТочками = функция(pt1, pt2) {
		вернуть Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
	};
	helpers.aliasPixel = функция(пиксельШирина) {
		вернуть (pixelWidth % 2 === 0) ? 0 : 0.5;
	};
	helpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
		// Респект Робу Спенсеру из Scaled Innovation за его пост о сплайнинге между точками
		// http://scaledinnovation.com/analytics/splines/aboutSplines.html

		// Эта функция также должна учитывать «пропущенные» точки

		вар предыдущий = firstPoint.skip? средняя точка: первая точка;
		var current = middlePoint;
		var next = afterPoint.skip ? middlePoint : afterPoint;

		var d01 = Math.sqrt(Math.pow(текущий.x - предыдущий.x, 2) + Math.pow(текущий.y - предыдущий.y, 2));
		var d12 = Math.sqrt(Math.pow(следующий.x - текущий.x, 2) + Math.pow(следующий.y - текущий.y, 2));

		вар s01 = d01 / (d01 + d12);
		вар s12 = d12 / (d01 + d12);

		// Если все точки одинаковы, s01 и s02 будут inf
		s01 = isNaN(s01) ? 0 : s01;
		s12 = isNaN(s12) ? 0 : s12;

		var fa = t * s01; // коэффициент масштабирования для треугольника Ta
		var fb = t * s12;

		возвращаться {
			предыдущий: {
				x: текущий.x - fa * (следующий.x - предыдущий.x),
				y: текущий.y - fa * (следующий.y - предыдущий.y)
			},
			следующий: {
				x: текущий.x + fb * (следующий.x - предыдущий.x),
				y: текущий.y + fb * (следующий.y - предыдущий.y)
			}
		};
	};
	helpers.EPSILON = Число.EPSILON || 1e-14;
	helpers.splineCurveMonotone = функция(точки) {
		// Эта функция вычисляет контрольные точки Безье аналогично |splineCurve|,
		// но сохраняет монотонность предоставленных данных и гарантирует отсутствие добавления локальных экстремумов
		// между дискретными точками набора данных из-за интерполяции.
		// См.: https://en.wikipedia.org/wiki/Monotone_cubic_interpolation

		var pointsWithTangents = (точки || []).map(function(point) {
			возвращаться {
				модель: точка._модель,
				дельтаК: 0,
				мК: 0
			};
		});

		// Рассчитать наклоны (deltaK) и инициализировать касательные (mK)
		var pointsLen = pointsWithTangents.length;
		вар я, pointBefore, pointCurrent, pointAfter;
		для (i = 0; i < pointsLen; ++i) {
			pointCurrent = pointsWithTangents[i];
			если (pointCurrent.model.skip) {
				продолжать;
			}

			pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
			pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
			if (pointAfter && !pointAfter.model.skip) {
				var slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);

				// В случае двух точек, которые появляются в одном и том же пикселе x, slopeDeltaX равен 0
				pointCurrent.deltaK = наклонDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y)/slopeDeltaX: 0;
			}

			if (!pointBefore || pointBefore.model.skip) {
				pointCurrent.mK = pointCurrent.deltaK;
			} else if (!pointAfter || pointAfter.model.skip) {
				pointCurrent.mK = pointBefore.deltaK;
			} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
				pointCurrent.mK = 0;
			} еще {
				pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK)/2;
			}
		}

		// Отрегулируйте касательные, чтобы обеспечить монотонные свойства
		вар альфаК, бетаК, тауК, квадратная величина;
		для (i = 0; i < pointsLen - 1; ++i) {
			pointCurrent = pointsWithTangents[i];
			pointAfter = pointsWithTangents[i + 1];
			если (pointCurrent.model.skip || pointAfter.model.skip) {
				продолжать;
			}

			если (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
				pointCurrent.mK = pointAfter.mK = 0;
				продолжать;
			}

			альфаК = pointCurrent.mK / pointCurrent.deltaK;
			betaK = pointAfter.mK / pointCurrent.deltaK;
			squaredMagnitude = Math.pow(альфаК, 2) + Math.pow(бетаК, 2);
			если (квадратМагнитуды <= 9) {
				продолжать;
			}

			тауК = 3 / Матем.кв.(квадратМаксимума);
			pointCurrent.mK = альфаK * tauK * pointCurrent.deltaK;
			pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
		}

		// Вычислить контрольные точки
		var deltaX;
		для (i = 0; i < pointsLen; ++i) {
			pointCurrent = pointsWithTangents[i];
			если (pointCurrent.model.skip) {
				продолжать;
			}

			pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
			pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
			if (pointBefore && !pointBefore.model.skip) {
				deltaX = (pointCurrent.model.x - pointBefore.model.x)/3;
				pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
				pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
			}
			if (pointAfter && !pointAfter.model.skip) {
				deltaX = (точкаПосле.модели.x - точкаТекущая.модели.x) / 3;
				pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
				pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
			}
		}
	};
	helpers.nextItem = функция(коллекция, индекс, цикл) {
		если (цикл) {
			вернуть индекс >= коллекция.длина - 1 ? коллекция[0] : коллекция[индекс + 1];
		}
		вернуть индекс >= коллекция.длина - 1 ? коллекция[коллекция.длина - 1] : коллекция[индекс + 1];
	};
	helpers.previousItem = функция(коллекция, индекс, цикл) {
		если (цикл) {
			возвращаемый индекс <= 0 ? коллекция[коллекция.длина - 1] : коллекция[индекс - 1];
		}
		возврат индекса <= 0 ? коллекция[0] : коллекция[индекс - 1];
	};
	// Реализация алгоритма хороших чисел, используемого для определения того, где будут располагаться метки осей
	helpers.niceNum = функция(диапазон, округление) {
		var exponent = Math.floor(helpers.log10(range));
		var дробь = диапазон / Math.pow(10, показатель степени);
		var niceFraction;

		если (круглый) {
			если (дробь < 1,5) {
				хорошаяФракция = 1;
			} иначе если (дробь < 3) {
				хорошаяФракция = 2;
			} иначе если (дробь < 7) {
				хорошаяФракция = 5;
			} еще {
				хорошаяФракция = 10;
			}
		} иначе если (дробь <= 1.0) {
			хорошаяФракция = 1;
		} иначе если (дробь <= 2) {
			хорошаяФракция = 2;
		} иначе если (дробь <= 5) {
			хорошаяФракция = 5;
		} еще {
			хорошаяФракция = 10;
		}

		вернуть niceFraction * Math.pow(10, exponent);
	};
	// Запросить анимационный полифилл - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
	helpers.requestAnimFrame = (function() {
		если (тип окна === 'не определен') {
			функция возврата (обратный вызов) {
				перезвонить();
			};
		}
		вернуть окно.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			функция(обратный вызов) {
				return window.setTimeout(callback, 1000 / 60);
			};
	}());
	// -- методы DOM
	helpers.getRelativePosition = функция(evt, chart) {
		var mouseX, mouseY;
		var e = evt.originalEvent || эвт;
		вар холст = evt.currentTarget || evt.srcElement;
		варboundingRect = Canvas.getBoundingClientRect();

		var касания = e.касания;
		если (касается && касается.длина > 0) {
			mouseX = касания[0].clientX;
			mouseY = касания[0].clientY;

		} еще {
			mouseX = e.clientX;
			мышьY = e.clientY;
		}

		// Масштабировать координаты мыши в координаты холста
		// следуя шаблону, изложенному 'jerryj' в комментариях
		// http://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
		var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
		var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
		var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
		var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
		var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
		var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

		// Мы делим на текущее соотношение пикселей устройства, потому что холст масштабируется на эту величину в каждом направлении. Однако
		// модель бэкэнда находится в немасштабированных координатах. Поскольку мы собираемся иметь дело с нашими модельными координатами, мы возвращаемся сюда
		mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (ширина) * canvas.width / chart.currentDevicePixelRatio);
		mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (высота) * canvas.height / chart.currentDevicePixelRatio);

		возвращаться {
			х: мышьX,
			y: мышьY
		};

	};

	// Частная вспомогательная функция для преобразования значений максимальной ширины/максимальной высоты, которые могут быть процентами, в число
	функция parseMaxStyle(styleValue, узел, parentProperty) {
		var valueInPixels;
		если (typeof styleValue === 'строка') {
			значениеВПикселях = parseInt(styleValue, 10);

			если (styleValue.indexOf('%') !== -1) {
				// процент * размер в измерении
				значениеВПикселях = значениеВПикселях / 100 * узел.родительскийУзел[родительскоеСвойство];
			}
		} еще {
			значениеВПикселях = ЗначениеСтиля;
		}

		возвращаемое значениеInPixels;
	}

	/**
	 * Возвращает, если заданное значение содержит эффективное ограничение.
	 * @частный
	 */
	функция isConstrainedValue(значение) {
		возвращаемое значение !== неопределено && значение !== null && значение !== 'none';
	}

	// Частный помощник для получения измерения ограничения
	// @param domNode : узел для проверки ограничения
	// @param maxStyle : стиль, который определяет максимум для направления, которое мы используем (maxWidth / maxHeight)
	// @param percentageProperty : свойство родителя, используемое при расчете ширины в процентах
	// @see http://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser
	функция getConstraintDimension(domNode, maxStyle, percentageProperty) {
		var view = document.defaultView;
		вар родительский узел = domNode.parentNode;
		var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
		var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
		вар hasCNode = isConstrainedValue(constrainedNode);
		вар hasCContainer = isConstrainedValue (constrainedContainer);
		var infinity = Число.ПОЛОЖИТЕЛЬНАЯ_БЕСКОНЕЧНОСТЬ;

		если (hasCNode || hasCContainer) {
			вернуть Математика.мин(
				hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : бесконечность,
				имеетCContainer? parseMaxStyle (constrainedContainer, родительский узел, процентное свойство): бесконечность);
		}

		вернуть «нет»;
	}
	// возвращает Number или undefined, если ограничений нет
	helpers.getConstraintWidth = функция(domNode) {
		return getConstraintDimension(domNode, 'max-width', 'clientWidth');
	};
	// возвращает Number или undefined, если ограничений нет
	helpers.getConstraintHeight = функция(domNode) {
		return getConstraintDimension(domNode, 'max-height', 'clientHeight');
	};
	helpers.getMaximumWidth = функция(domNode) {
		вар контейнер = domNode.parentNode;
		если (!контейнер) {
			вернуть domNode.clientWidth;
		}

		var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);
		var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);
		var w = container.clientWidth - paddingLeft - paddingRight;
		var cw = helpers.getConstraintWidth(domNode);
		вернуть isNaN(cw) ? w : Math.min(w, cw);
	};
	helpers.getMaximumHeight = функция(domNode) {
		вар контейнер = domNode.parentNode;
		если (!контейнер) {
			вернуть domNode.clientHeight;
		}

		var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);
		var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);
		var h = container.clientHeight - paddingTop - paddingBottom;
		var ch = helpers.getConstraintHeight(domNode);
		вернуть isNaN(ch) ? h : Math.min(h, ch);
	};
	helpers.getStyle = функция(el, свойство) {
		вернуть el.currentStyle ?
			el.currentStyle[свойство] :
			document.defaultView.getComputedStyle(el, null).getPropertyValue(свойство);
	};
	helpers.retinaScale = функция(диаграмма, forceRatio) {
		var pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;
		если (pixelRatio === 1) {
			возвращаться;
		}

		var холст = диаграмма.холст;
		var height = высота диаграммы;
		var width = ширина диаграммы;

		холст.высота = высота * пиксельное отношение;
		холст.ширина = ширина * пиксельное отношение;
		диаграмма.ctx.scale(pixelRatio, pixelRatio);

		// Если на холсте не установлен стиль, размер рендеринга используется как размер отображения,
		// делаем диаграмму визуально больше, поэтому давайте принудительно приведем ее к «правильным» значениям.
		// См. https://github.com/chartjs/Chart.js/issues/3575
		если (!высота.стиля.холста && !ширина.стиля.холста) {
			холст.стиль.высота = высота + 'px';
			холст.стиль.ширина = ширина + 'px';
		}
	};
	// -- Методы холста
	helpers.fontString = function(pixelSize, fontStyle, fontFamily) {
		вернуть fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
	};
	helpers.longestText = функция (ctx, шрифт, arrayOfThings, кэш) {
		кэш = кэш || {};
		var данные = кэш.данные = кэш.данные || {};
		var gc = cache.garbageCollect = cache.garbageCollect || [];

		если (кэш.шрифт !== шрифт) {
			данные = кэш.данные = {};
			gc = cache.garbageCollect = [];
			кэш.шрифт = шрифт;
		}

		ctx.шрифт = шрифт;
		самая длинная переменная = 0;
		помощники.каждый(массивВещей, функция(вещь) {
			// Неопределенные строки и массивы не должны измеряться
			если (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
				самый длинный = helpers.measureText(ctx, data, gc, самый длинный, thing);
			} иначе если (helpers.isArray(thing)) {
				// если это массив, давайте измерим каждый элемент
				// может быть, немного упростить эту функцию, чтобы мы могли сделать это более рекурсивно?
				помощники.каждый(вещь, функция(вложеннаяВещь) {
					// Неопределенные строки и массивы не должны измеряться
					если (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
						самый длинный = helpers.measureText(ctx, data, gc, самый длинный, nestedThing);
					}
				});
			}
		});

		var gcLen = gc.length / 2;
		если (gcLen > arrayOfThings.length) {
			для (вар я = 0; я <gcLen; я++) {
				удалить данные[gc[i]];
			}
			gc.splice(0, gcLen);
		}
		возвращение самого длинного;
	};
	helpers.measureText = function(ctx, data, gc, longest, string) {
		var textWidth = данные[строка];
		если (!textWidth) {
			textWidth = data[string] = ctx.measureText(string).width;
			gc.push(строка);
		}
		если (textWidth > самый длинный) {
			самая длинная = ширина текста;
		}
		возвращение самого длинного;
	};
	helpers.numberOfLabelLines = функция(arrayOfThings) {
		var numberOfLines = 1;
		помощники.каждый(массивВещей, функция(вещь) {
			если (helpers.isArray(thing)) {
				если (вещь.длина > числоСтрок) {
					числоСтрок = вещь.длина;
				}
			}
		});
		вернуть число строк;
	};

	helpers.color = !цвет ?
		функция(значение) {
			console.error('Color.js не найден!');
			возвращаемое значение;
		} :
		функция(значение) {
			/* глобальный CanvasGradient */
			если (значение экземпляра CanvasGradient) {
				значение = defaults.global.defaultColor;
			}

			вернуть цвет(значение);
		};

	helpers.getHoverColor = функция(colorValue) {
		/* глобальный CanvasPattern */
		вернуть (colorValue экземпляр CanvasPattern) ?
			Значение цвета:
			helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
	};
};

},{"25":25,"3":3,"45":45}],28:[function(require,module,exports){
«использовать строго»;

var helpers = require(45);

/**
 * Вспомогательная функция для получения относительного положения события
 * @param {Event|IEvent} event — Событие, для которого необходимо получить позицию
 * @param {Chart} диаграмма - Диаграмма
 * @returns {Point} — позиция события
 */
функция getRelativePosition(e, диаграмма) {
	если (e.native) {
		возвращаться {
			х: бывш.,
			y: эй
		};
	}

	return helpers.getRelativePosition(e, chart);
}

/**
 * Вспомогательная функция для обхода всех видимых элементов на диаграмме
 * @param chart {chart} диаграмма
 * @param handler {Function} обратный вызов, выполняемый для каждого видимого элемента
 */
функция parseVisibleItems(диаграмма, обработчик) {
	наборы данных вар =chart.data.datasets;
	var meta, i, j, ilen, jlen;

	for (i = 0, ilen = datasets.length; i < ilen; ++i) {
		если (!chart.isDatasetVisible(i)) {
			продолжать;
		}

		мета = диаграмма.getDatasetMeta(i);
		for (j = 0, jlen = Meta.data.length; j < jlen; ++j) {
			элемент переменной = meta.data[j];
			если (!element._view.skip) {
				обработчик(элемент);
			}
		}
	}
}

/**
 * Вспомогательная функция для получения элементов, пересекающих позицию события
 * @param items {ChartElement[]} элементы для фильтрации
 * @param position {Point} — ближайшая к вам точка
 * @return {ChartElement[]} ближайшие элементы
 */
функция getIntersectItems(диаграмма, позиция) {
	элементы переменной = [];

	parseVisibleItems(диаграмма, функция(элемент) {
		if (element.inRange(position.x,position.y)) {
			элементы.push(элемент);
		}
	});

	возврат элементов;
}

/**
 * Вспомогательная функция для получения элементов, ближайших к позиции события, с учетом всех видимых элементов в таблице.
 * @param chart {Chart} диаграмма для просмотра элементов
 * @param position {Point} — ближайшая к вам точка
 * @param intersect {Boolean} если true, то рассматриваются только те элементы, которые пересекают позицию
 * Функция @param distanceMetric {Function} для определения расстояния между точками
 * @return {ChartElement[]} ближайшие элементы
 */
функция getNearestItems(диаграмма, положение, пересечение, distanceMetric) {
	var minDistance = Число.ПОЛОЖИТЕЛЬНАЯ_БЕСКОНЕЧНОСТЬ;
	var nearestItems = [];

	parseVisibleItems(диаграмма, функция(элемент) {
		если (intersect && !element.inRange(position.x, position.y)) {
			возвращаться;
		}

		вар центр = element.getCenterPoint();
		var distance = distanceMetric(позиция, центр);

		если (расстояние < minDistance) {
			nearestItems = [элемент];
			minDistance = расстояние;
		} иначе если (расстояние === minDistance) {
			// Может быть несколько элементов на одном расстоянии, в этом случае мы сортируем по размеру
			nearestItems.push(элемент);
		}
	});

	вернуть ближайшие элементы;
}

/**
 * Получить функцию метрики расстояния для двух точек на основе
 * настройка режима оси
 * @param {String} axis режим оси. x|y|xy
 */
функция getDistanceMetricForAxis(ось) {
	var useX = axis.indexOf('x') !== -1;
	var useY = axis.indexOf('y') !== -1;

	функция возврата(pt1, pt2) {
		var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
		вар deltaY = useY ? Math.abs(pt1.y - pt2.y): 0;
		вернуть Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
	};
}

функция indexMode (диаграмма, е, параметры) {
	переменная позиция = getRelativePosition(e, chart);
	// Ось по умолчанию для индексного режима — «x», чтобы соответствовать старому поведению
	параметры.ось = параметры.ось || 'x';
	var distanceMetric = getDistanceMetricForAxis(options.axis);
	var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
	элементы переменной = [];

	если (!элементы.длина) {
		возвращаться [];
	}

	chart.data.datasets.forEach(function(dataset, datasetIndex) {
		если (chart.isDatasetVisible(datasetIndex)) {
			вар мета =chart.getDatasetMeta(datasetIndex);
			var элемент = meta.data[items[0]._index];

			// не учитывать пропущенные элементы (пустые данные)
			если (элемент && !элемент._просмотр.пропустить) {
				элементы.push(элемент);
			}
		}
	});

	возврат элементов;
}

/**
 * @interface IInteractionOptions
 */
/**
 * Если true, то учитываются только те элементы, которые пересекают точку
 * @nameIInterfaceOptions#логическое значение
 * @type Логическое значение
 */

/**
 * Содержит функции, связанные с взаимодействием
 * @namespace Диаграмма.Взаимодействие
 */
модуль.экспорты = {
	// Вспомогательная функция для разных режимов
	режимы: {
		одиночный: функция(диаграмма, е) {
			переменная позиция = getRelativePosition(e, chart);
			элементы переменной = [];

			parseVisibleItems(диаграмма, функция(элемент) {
				if (element.inRange(position.x,position.y)) {
					элементы.push(элемент);
					возврат элементов;
				}
			});

			вернуть элементы.slice(0, 1);
		},

		/**
		 * @function Диаграмма.Взаимодействия.режимы.метка
		 * @deprecated с версии 2.4.0
		 * @todo удалено в версии 3
		 * @частный
		 */
		метка: indexMode,

		/**
		 * Возвращает элементы с тем же индексом. Если параметр options.intersect имеет значение true, мы возвращаем элементы только в том случае, если мы что-то пересекаем
		 * Если режим options.intersect имеет значение false, мы находим ближайший элемент и возвращаем элементы с тем же индексом, что и у этого элемента.
		 * @function Диаграмма.Взаимодействия.режимов.индекс
		 * @начиная с версии 2.4.0
		 * @param chart {chart} — диаграмма, из которой мы возвращаем элементы
		 * @param e {Event} событие, на котором мы находим вещи
		 * @param options {IInteractionOptions} параметры для использования во время взаимодействия
		 * @return {Chart.Element[]} Массив элементов, которые находятся под точкой. Если ничего не найдено, возвращается пустой массив
		 */
		индекс: indexMode,

		/**
		 * Возвращает элементы в том же наборе данных. Если параметр options.intersect имеет значение true, мы возвращаем элементы только в том случае, если мы что-то пересекаем
		 * Если options.intersect имеет значение false, мы находим ближайший элемент и возвращаем элементы в этом наборе данных.
		 * @function Диаграмма.Взаимодействие.режимы.набор.данных
		 * @param chart {chart} — диаграмма, из которой мы возвращаем элементы
		 * @param e {Event} событие, на котором мы находим вещи
		 * @param options {IInteractionOptions} параметры для использования во время взаимодействия
		 * @return {Chart.Element[]} Массив элементов, которые находятся под точкой. Если ничего не найдено, возвращается пустой массив
		 */
		набор данных: функция (диаграмма, e, параметры) {
			переменная позиция = getRelativePosition(e, chart);
			параметры.ось = параметры.ось || 'xy';
			var distanceMetric = getDistanceMetricForAxis(options.axis);
			var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

			если (элементы.длина > 0) {
				элементы = диаграмма.getDatasetMeta(items[0]._datasetIndex).data;
			}

			возврат товара;
		},

		/**
		 * @function Диаграмма.Взаимодействия.режимы.ось x
		 * @deprecated с версии 2.4.0. Использовать режим индекса и пересечение == true
		 * @todo удалено в версии 3
		 * @частный
		 */
		'ось x': функция(диаграмма, e) {
			return indexMode(chart, e, {intersect: false});
		},

		/**
		 * Режим точки возвращает все элементы, которые достигли тестового значения, на основе позиции события
		 * события
		 * @function Диаграмма.Взаимодействия.режимы.пересечения
		 * @param chart {chart} — диаграмма, из которой мы возвращаем элементы
		 * @param e {Event} событие, на котором мы находим вещи
		 * @return {Chart.Element[]} Массив элементов, которые находятся под точкой. Если ничего не найдено, возвращается пустой массив
		 */
		точка: функция(диаграмма, е) {
			переменная позиция = getRelativePosition(e, chart);
			вернуть getIntersectItems (диаграмма, позиция);
		},

		/**
		 * режим Nearest возвращает элемент, ближайший к точке
		 * @function Диаграмма.Взаимодействия.режимы.пересечения
		 * @param chart {chart} — диаграмма, из которой мы возвращаем элементы
		 * @param e {Event} событие, на котором мы находим вещи
		 * @param options {IInteractionOptions} параметры для использования
		 * @return {Chart.Element[]} Массив элементов, которые находятся под точкой. Если ничего не найдено, возвращается пустой массив
		 */
		ближайший: функция(диаграмма, e, параметры) {
			переменная позиция = getRelativePosition(e, chart);
			параметры.ось = параметры.ось || 'xy';
			var distanceMetric = getDistanceMetricForAxis(options.axis);
			var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);

			// У нас есть несколько элементов на одинаковом расстоянии от события. Теперь сортируем по наименьшему
			если (ближайшиеэлементы.длина > 1) {
				ближайшиеЭлементы.сортировка(функция(a, b) {
					var sizeA = a.getArea();
					var sizeB = b.getArea();
					var ret = размерA - размерB;

					если (рет === 0) {
						// если равно, сортировать по индексу набора данных
						ret = a._datasetIndex - b._datasetIndex;
					}

					возвратить обратно;
				});
			}

			// Возвращает только 1 элемент
			вернуть ближайшиеItems.slice(0, 1);
		},

		/**
		 * режим x возвращает элементы, которые проверяются на попадание в текущую координату x
		 * @function Диаграмма.Взаимодействия.режимы.x
		 * @param chart {chart} — диаграмма, из которой мы возвращаем элементы
		 * @param e {Event} событие, на котором мы находим вещи
		 * @param options {IInteractionOptions} параметры для использования
		 * @return {Chart.Element[]} Массив элементов, которые находятся под точкой. Если ничего не найдено, возвращается пустой массив
		 */
		x: функция(диаграмма, e, параметры) {
			переменная позиция = getRelativePosition(e, chart);
			var элементы = [];
			var intersectsItem = false;

			parseVisibleItems(диаграмма, функция(элемент) {
				если (элемент.inXRange(позиция.x)) {
					элементы.push(элемент);
				}

				if (element.inRange(position.x,position.y)) {
					intersectsItem = true;
				}
			});

			// Если мы хотим сработать при пересечении и у нас нет никаких элементов
			// которые пересекают позицию, ничего не возвращают
			если (options.intersect && !intersectsItem) {
				элементы = [];
			}
			возврат товара;
		},

		/**
		 * режим y возвращает элементы, которые проверяются на попадание в текущую координату y
		 * @function Диаграмма.Взаимодействия.режимы.y
		 * @param chart {chart} — диаграмма, из которой мы возвращаем элементы
		 * @param e {Event} событие, на котором мы находим вещи
		 * @param options {IInteractionOptions} параметры для использования
		 * @return {Chart.Element[]} Массив элементов, которые находятся под точкой. Если ничего не найдено, возвращается пустой массив
		 */
		y: функция(диаграмма, e, параметры) {
			переменная позиция = getRelativePosition(e, chart);
			var элементы = [];
			var intersectsItem = false;

			parseVisibleItems(диаграмма, функция(элемент) {
				если (элемент.inYRange(позиция.y)) {
					элементы.push(элемент);
				}

				if (element.inRange(position.x,position.y)) {
					intersectsItem = true;
				}
			});

			// Если мы хотим сработать при пересечении и у нас нет никаких элементов
			// которые пересекают позицию, ничего не возвращают
			если (options.intersect && !intersectsItem) {
				элементы = [];
			}
			возврат товара;
		}
	}
};

},{"45":45}],29:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);

defaults._set('глобальный', {
	отзывчивый: правда,
	responsiveAnimationDuration: 0,
	поддерживатьAspectRatio: правда,
	события: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
	наведите курсор: {
		onHover: ноль,
		режим: «ближайший»,
		пересечение: правда,
		анимацияПродолжительность: 400
	},
	onClick: ноль,
	Цвет по умолчанию: 'rgba(0,0,0,0.1)',
	ЦветШрифтаПо умолчанию: '#666',
	defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
	размер шрифта по умолчанию: 12,
	defaultFontStyle: 'нормальный',
	showLines: правда,

	// Значения элементов по умолчанию определены в расширениях элементов
	элементы: {},

	// Параметры макета, такие как отступы
	макет: {
		отступ: {
			вверху: 0,
			справа: 0,
			внизу: 0,
			осталось: 0
		}
	}
});

модуль.экспорты = функция() {

	// Занимаем глобальную переменную Chart и создаем простой базовый класс
	var Chart = функция(элемент, конфигурация) {
		this.construct(элемент, конфигурация);
		верните это;
	};

	Диаграмма.Диаграмма = Диаграмма;

	возврат Диаграммы;
};

},{"25":25}],30:[function(require,module,exports){
«использовать строго»;

var helpers = require(45);

функция filterByPosition(массив, позиция) {
	вернуть помощников.где(массив, функция(v) {
		возврат v.position === position;
	});
}

функция sortByWeight(массив, обратный) {
	массив.forEach(функция(v, i) {
		v._tmpIndex_ = i;
		возврат v;
	});
	массив.сортировка(функция(a, b) {
		var v0 = обратный ? b : a;
		var v1 = обратный ? a : b;
		вернуть v0.вес === v1.вес ?
			v0._tmpIndex_ - v1._tmpIndex_ :
			v0.вес - v1.вес;
	});
	массив.forEach(функция(v) {
		удалить v._tmpIndex_;
	});
}

/**
 * @interface ILayoutItem
 * @prop {String} position - Положение элемента в макете диаграммы. Возможные значения:
 * «слева», «сверху», «справа», «снизу» и «chartArea»
 * @prop {Number} weight - Вес, используемый для сортировки элемента. Более высокие веса находятся дальше от области диаграммы
 * @prop {Boolean} fullWidth — если true и элемент горизонтальный, то сдвинуть вертикальные блоки вниз
 * @prop {Function} isHorizontal — возвращает true, если элемент макета горизонтальный (т. е. верхний или нижний)
 * @prop {Function} update - Принимает два параметра: width и height. Возвращает размер элемента
 * @prop {Function} getPadding — возвращает объект с отступами по краям
 * @prop {Number} width - Ширина элемента. Должно быть действительным после update()
 * @prop {Number} height - Высота элемента. Должно быть действительным после update()
 * @prop {Number} left - Левый край элемента. Устанавливается системой макета и не может использоваться при обновлении
 * @prop {Number} top - Верхний край элемента. Устанавливается системой макета и не может использоваться при обновлении
 * @prop {Number} right - Правый край элемента. Устанавливается системой макета и не может использоваться при обновлении
 * @prop {Number} bottom - Нижний край элемента. Устанавливается системой макета и не может использоваться при обновлении
 */

// Служба макета очень понятна. Она отвечает за макет внутри диаграммы.
// Шкалы, легенды и плагины полагаются на службу макетов и могут легко регистрироваться для размещения в любом месте, где им нужно
// Ответственность за реализацию макета лежит на данной службе.
модуль.экспорты = {
	значения по умолчанию: {},

	/**
	 * Зарегистрируйте ящик на диаграмме.
	 * Поле — это просто ссылка на объект, требующий макета. Например, шкалы, легенда, заголовок.
	 * @param {Chart} chart — диаграмма для использования
	 * @param {ILayoutItem} item - элемент, который нужно добавить для размещения
	 */
	addBox: функция(диаграмма, элемент) {
		если (!chart.boxes) {
			диаграмма.boxes = [];
		}

		// инициализируем элемент со значениями по умолчанию
		item.fullWidth = item.fullWidth || false;
		позиция.элемента = позиция.элемента || 'top';
		вес.предмета = вес.предмета || 0;

		диаграмма.boxes.push(элемент);
	},

	/**
	 * Удалить элемент макета из диаграммы
	 * @param {Chart} chart - диаграмма, из которой нужно удалить поле
	 * @param {Object} layoutItem — элемент, который нужно удалить из макета
	 */
	removeBox: функция(диаграмма, layoutItem) {
		var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
		если (индекс !== -1) {
			диаграмма.ящики.сращивание(индекс, 1);
		}
	},

	/**
	 * Устанавливает (или обновляет) параметры указанного `элемента`.
	 * @param {Chart} chart - диаграмма, в которой находится элемент (или будет добавлен)
	 * @param {Object} item — элемент для настройки с заданными параметрами
	 * @param {Object} options - новые параметры элемента.
	 */
	настроить: функция(диаграмма, элемент, параметры) {
		var props = ['fullWidth', 'position', 'weight'];
		var ilen = props.length;
		переменная i = 0;
		вар проп;

		для (; i < ilen; ++i) {
			prop = props[i];
			если (options.hasOwnProperty(prop)) {
				элемент[свойство] = параметры[свойство];
			}
		}
	},

	/**
	 * Подгоняет ячейки заданной диаграммы под заданный размер, измеряя каждую ячейку самостоятельно
	 * затем запускается алгоритм подгонки
	 * @param {Chart} диаграмма - диаграмма
	 * @param {Number} width — ширина, в которую нужно вписаться
	 * @param {Number} height — высота, в которую нужно вписаться
	 */
	обновить: функция(диаграмма, ширина, высота) {
		если (!диаграмма) {
			возвращаться;
		}

		var layoutOptions = chart.options.layout || {};
		var padding = helpers.options.toPadding(layoutOptions.padding);
		var leftPadding = padding.left;
		var rightPadding = padding.right;
		var topPadding = padding.top;
		var bottomPadding = padding.bottom;

		var leftBoxes = filterByPosition(chart.boxes, 'left');
		var rightBoxes = filterByPosition(chart.boxes, 'right');
		var topBoxes = filterByPosition(chart.boxes, 'top');
		var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
		var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');

		// Сортировать коробки по весу. Больший вес находится дальше от области диаграммы
		sortByWeight (leftBoxes, правда);
		sortByWeight (rightBoxes, ложь);
		sortByWeight(topBoxes, true);
		sortByWeight (bottomBoxes, ложь);

		// По сути, теперь у нас есть любое количество коробок на каждой из 4 сторон.
		// Наш холст выглядит следующим образом.
		// Области L1 и L2 — левые оси. R1 — правая ось, T1 — верхняя ось и
		// B1 — нижняя ось
		// Также есть 4 квадрантных расположения (слева направо, а не по часовой стрелке), зарезервированных для наложений диаграмм
		// Эти местоположения являются только местоположениями с одним ящиком, при попытке зарегистрировать местоположение chartArea, которое уже занято,
		// будет выдана ошибка.
		//
		// |----------------------------------------------- -----|
		// | T1 (полная ширина) |
		// |----------------------------------------------- -----|
		// | | | Т2 | |
		// | |----|-------------------------------------|----|
		// | | | С1 | | С2 | |
		// | | |----| |----| |
		// | | | | |
		// | L1 | L2 | Область диаграммы (C0) | R1 |
		// | | | | |
		// | | |----| |----| |
		// | | | С3 | | С4 | |
		// | |----|-------------------------------------|----|
		// | | | В1 | |
		// |----------------------------------------------- -----|
		// | B2 (полная ширина) |
		// |----------------------------------------------- -----|
		//
		// Что мы делаем, чтобы найти лучший размер, мы делаем следующее
		// 1. Определите минимальный размер области диаграммы.
		// 2. Разделите оставшуюся ширину поровну между каждой вертикальной осями
		// 3. Разделите оставшуюся высоту поровну между каждой горизонтальной осями
		// 4. Дайте каждому макету максимальный возможный размер. Макет вернет свой минимальный размер
		// 5. Отрегулируйте размеры каждой оси на основе ее минимального сообщенного размера.
		// 6. Установите каждую ось заново
		// 7. Расположите каждую ось в конечном месте
		// 8. Сообщите диаграмме окончательное местоположение области диаграммы
		// 9. Сообщите всем осям, которые накладываются на область диаграммы, положение области диаграммы

		// Шаг 1
		var chartWidth = width - leftPadding - rightPadding;
		var chartHeight = высота - верхний отступ - нижний отступ;
		варchartAreaWidth =chartWidth/2; // мин 50%
		варchartAreaHeight =chartHeight/2; // мин 50%

		// Шаг 2
		var verticalBoxWidth = (ширина - ширина области диаграммы) / (длина_левых_ящиков + длина_правых_ящиков);

		// Шаг 3
		var horizontalBoxHeight = (высота - высота области диаграммы) / (длина верхних ящиков + длина нижних ящиков);

		// Шаг 4
		var maxChartAreaWidth = ширина_диаграммы;
		var maxChartAreaHeight = высота_диаграммы;
		var minBoxSizes = [];

		функция getMinimumBoxSize(box) {
			var minSize;
			var isHorizontal = box.isHorizontal();

			если (горизонтально) {
				minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
				maxChartAreaHeight -= minSize.height;
			} еще {
				minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
				maxChartAreaWidth -= minSize.width;
			}

			minBoxSizes.push({
				горизонтальный: isHorizontal,
				минРазмер: минРазмер,
				коробка: коробка,
			});
		}

		helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);

		// Если у горизонтального блока есть отступ, мы перемещаем левые блоки, чтобы избежать уродливых диаграмм (см. проблему № 2478)
		вар maxHorizontalLeftPadding = 0;
		вар maxHorizontalRightPadding = 0;
		var maxVerticalTopPadding = 0;
		var maxVerticalBottomPadding = 0;

		helpers.each(topBoxes.concat(bottomBoxes), функция(horizontalBox) {
			если (horizontalBox.getPadding) {
				var boxPadding = horizontalBox.getPadding();
				maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
				maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
			}
		});

		helpers.each(leftBoxes.concat(rightBoxes), функция(verticalBox) {
			если (verticalBox.getPadding) {
				var boxPadding = verticalBox.getPadding();
				maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
				maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
			}
		});

		// На этом этапе maxChartAreaHeight и maxChartAreaWidth — это размер области диаграммы, который может
		// если оси нарисованы в минимальных размерах.
		// Шаги 5 и 6
		var totalLeftBoxesWidth = leftPadding;
		var totalRightBoxesWidth = rightPadding;
		вар totalTopBoxesHeight = topPadding;
		вар TotalBottomBoxesHeight = BottomPadding;

		// Функция для подгонки под размер коробки
		функция fitBox(box) {
			var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {
				вернуть minBox.box === box;
			});

			если (minBoxSize) {
				если (box.isHorizontal()) {
					var scaleMargin = {
						слева: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
						справа: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
						вверху: 0,
						внизу: 0
					};

					// Не используйте здесь минимальный размер из-за вращения этикеток. Когда этикетки вращаются, их вращение сильно зависит
					// на полях. Иногда их нужно немного увеличить в размере
					box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
				} еще {
					box.update(minBoxSize.minSize.width, maxChartAreaHeight);
				}
			}
		}

		// Обновить и рассчитать левое и правое поля для горизонтальных блоков
		helpers.each(leftBoxes.concat(rightBoxes), fitBox);

		помощники.каждый(leftBoxes, функция(box) {
			totalLeftBoxesWidth += ширина_коробки;
		});

		helpers.each(rightBoxes, функция(box) {
			totalRightBoxesWidth += ширина_коробки;
		});

		// Установите левое и правое поля для горизонтальных блоков
		helpers.each(topBoxes.concat(bottomBoxes), fitBox);

		// Выясняем величину полей сверху и снизу вертикальных блоков
		помощники.каждый(topBoxes, функция(box) {
			totalTopBoxesHeight += box.height;
		});

		помощники.каждый(bottomBoxes, функция(box) {
			totalBottomBoxesHeight += box.height;
		});

		функция finalFitVerticalBox(box) {
			var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {
				вернуть minSize.box === box;
			});

			var scaleMargin = {
				осталось: 0,
				справа: 0,
				верх: общая высота верхних ящиков,
				низ: totalBottomBoxesHeight
			};

			если (minBoxSize) {
				box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
			}
		}

		// Дайте левому макету знать конечное поле
		helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);

		// Пересчитать, так как размер каждого макета мог немного измениться из-за полей (например, поворота метки)
		totalLeftBoxesWidth = leftPadding;
		totalRightBoxesWidth = rightPadding;
		totalTopBoxesHeight = topPadding;
		totalBottomBoxesHeight = bottomPadding;

		помощники.каждый(leftBoxes, функция(box) {
			totalLeftBoxesWidth += ширина_коробки;
		});

		helpers.each(rightBoxes, функция(box) {
			totalRightBoxesWidth += ширина_коробки;
		});

		помощники.каждый(topBoxes, функция(box) {
			totalTopBoxesHeight += box.height;
		});
		помощники.каждый(bottomBoxes, функция(box) {
			totalBottomBoxesHeight += box.height;
		});

		// Возможно, нам придется добавить отступы для учета повернутых меток оси X.
		var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
		totalLeftBoxesWidth += leftPaddingAddition;
		totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);

		вар topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
		totalTopBoxesHeight += topPaddingAddition;
		totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);

		// Выясняем, изменилась ли область нашей диаграммы. Это произошло бы, если бы вращение метки макета набора данных
		// изменено из-за применения полей на шаге 6. Поскольку мы можем только увеличиваться, это можно сделать безопасно
		// без повторного вызова `fit`
		var newMaxChartAreaHeight = высота - общая высота верхних ящиков - общая высота нижних ящиков;
		var newMaxChartAreaWidth = ширина - общая ширина левых ящиков - общая ширина правых ящиков;

		если (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
			помощники.каждый(leftBoxes, функция(box) {
				box.height = newMaxChartAreaHeight;
			});

			helpers.each(rightBoxes, функция(box) {
				box.height = newMaxChartAreaHeight;
			});

			помощники.каждый(topBoxes, функция(box) {
				если (!box.fullWidth) {
					box.width = newMaxChartAreaWidth;
				}
			});

			помощники.каждый(bottomBoxes, функция(box) {
				если (!box.fullWidth) {
					box.width = newMaxChartAreaWidth;
				}
			});

			maxChartAreaHeight = newMaxChartAreaHeight;
			maxChartAreaWidth = newMaxChartAreaWidth;
		}

		// Шаг 7 — Расположите коробки
		var left = leftPadding + leftPaddingAddition;
		вар топ = topPadding + topPaddingAddition;

		функция placeBox(box) {
			если (box.isHorizontal()) {
				box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
				box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
				коробка.верх = верх;
				ящик.низ = верх + ящик.высота;

				// Перейти к следующей точке
				верх = коробка.низ;

			} еще {

				ящик.левый = левый;
				box.right = left + box.width;
				box.top = totalTopBoxesHeight;
				box.bottom = totalTopBoxesHeight + maxChartAreaHeight;

				// Перейти к следующей точке
				левое = поле.правое;
			}
		}

		helpers.each(leftBoxes.concat(topBoxes), placeBox);

		// Учитывать ширину и высоту диаграммы
		левый += maxChartAreaWidth;
		верхняя часть += maxChartAreaHeight;

		helpers.each(rightBoxes, placeBox);
		helpers.each(bottomBoxes, placeBox);

		// Шаг 8
		диаграмма.chartArea = {
			слева: totalLeftBoxesWidth,
			верх: общая высота верхних ящиков,
			справа: totalLeftBoxesWidth + maxChartAreaWidth,
			внизу: totalTopBoxesHeight + maxChartAreaHeight
		};

		// Шаг 9
		помощники.каждый(chartAreaBoxes, функция(box) {
			box.left = диаграмма.chartArea.left;
			box.top =chart.chartArea.top;
			box.right = диаграмма.chartArea.right;
			box.bottom = диаграмма.chartArea.bottom;

			box.update(maxChartAreaWidth, maxChartAreaHeight);
		});
	}
};

},{"45":45}],31:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
var helpers = require(45);

defaults._set('глобальный', {
	плагины: {}
});

/**
 * Плагин сервиса singleton
 * @namespace Chart.plugins
 * @с версии 2.1.0
 */
модуль.экспорты = {
	/**
	 * Плагины, зарегистрированные по всему миру.
	 * @частный
	 */
	_плагины: [],

	/**
	 * Этот идентификатор используется для аннулирования кэша дескрипторов, прикрепленного к каждой диаграмме.
	 * когда глобальный плагин зарегистрирован или не зарегистрирован. В этом случае идентификатор кэша равен
	 * увеличивается, а дескрипторы регенерируются во время следующих вызовов API.
	 * @частный
	 */
	_Идентификатор_кэша: 0,

	/**
	 * Регистрирует указанные плагины, если они еще не зарегистрированы.
	 * @param {Array|Object} плагины экземпляр(ы) плагина.
	 */
	регистрация: функция(плагины) {
		var p = this._plugins;
		([]).concat(плагины).forEach(функция(плагин) {
			если (p.indexOf(плагин) === -1) {
				p.push(плагин);
			}
		});

		этот._cacheId++;
	},

	/**
	 * Отменяет регистрацию указанного плагина(ов), только если он зарегистрирован.
	 * @param {Array|Object} плагины экземпляр(ы) плагина.
	 */
	отменить регистрацию: функция(плагины) {
		var p = this._plugins;
		([]).concat(плагины).forEach(функция(плагин) {
			var idx = p.indexOf(плагин);
			если (idx !== -1) {
				p.splice(idx, 1);
			}
		});

		этот._cacheId++;
	},

	/**
	 * Удалить все зарегистрированные плагины.
	 * @с версии 2.1.5
	 */
	очистить: функция() {
		это._плагины = [];
		этот._cacheId++;
	},

	/**
	 * Возвращает количество зарегистрированных плагинов?
	 * @returns {Число}
	 * @с версии 2.1.5
	 */
	количество: функция() {
		вернуть this._plugins.length;
	},

	/**
	 * Возвращает все зарегистрированные экземпляры плагина.
	 * @returns {Array} массив объектов плагина.
	 * @с версии 2.1.5
	 */
	получитьВсе: функция() {
		вернуть this._plugins;
	},

	/**
	 * Вызывает включенные плагины для `chart` по указанному хуку и с заданными аргументами.
	 * Этот метод немедленно возвращает значение, как только плагин явно возвращает false.
	 * возвращаемое значение можно использовать, например, для прерывания текущего действия.
	 * @param {Object} chart — экземпляр диаграммы, для которого следует вызывать плагины.
	 * @param {String} hook — имя вызываемого метода плагина (например, 'beforeUpdate').
	 * @param {Array} [args] — Дополнительные аргументы для применения к вызову хука.
	 * @returns {Boolean} возвращает false, если какой-либо из плагинов возвращает false, в противном случае возвращает true.
	 */
	уведомить: функция(диаграмма, крючок, аргументы) {
		var descriptors = this.descriptors(chart);
		var ilen = дескрипторы.длина;
		var i, дескриптор, плагин, параметры, метод;

		для (i = 0; i < ilen; ++i) {
			дескриптор = дескрипторы[i];
			плагин = дескриптор.плагин;
			метод = плагин[хук];
			если (тип метода === 'функция') {
				параметры = [диаграмма].concat(аргументы || []);
				параметры.push(дескриптор.опции);
				если (метод.применить(плагин, параметры) === ложь) {
					вернуть ложь;
				}
			}
		}

		вернуть истину;
	},

	/**
	 * Возвращает дескрипторы включенных плагинов для данной диаграммы.
	 * @returns {Массив} [{плагин, параметры}]
	 * @частный
	 */
	дескрипторы: функция(диаграмма) {
		var cache = chart.$plugins || (chart.$plugins = {});
		если (кэш.id === этот._кэшId) {
			вернуть кэш.дескрипторы;
		}

		var плагины = [];
		дескрипторы переменных = [];
		var config = (chart && chart.config) || {};
		var options = (config.options && config.options.plugins) || {};

		this._plugins.concat(config.plugins || []).forEach(function(plugin) {
			var idx = plugins.indexOf(plugin);
			если (idx !== -1) {
				возвращаться;
			}

			var id = плагин.id;
			var opts = параметры[id];
			если (opts === false) {
				возвращаться;
			}

			если (опц === истина) {
				opts = helpers.clone(defaults.global.plugins[id]);
			}

			плагины.push(плагин);
			дескрипторы.push({
				плагин: плагин,
				параметры: варианты || {}
			});
		});

		кэш.дескрипторы = дескрипторы;
		кэш.id = this._cacheId;
		возврат дескрипторов;
	},

	/**
	 * Делает кэш недействительным для данной диаграммы: дескрипторы содержат ссылку на опцию плагина,
	 * но в некоторых случаях эта ссылка может быть изменена пользователем при обновлении опций.
	 * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
	 * @частный
	 */
	_invalidate: функция(диаграмма) {
		удалить диаграмму.$plugins;
	}
};

/**
 * Хуки расширения плагина.
 * @interface IPlugin
 * @с версии 2.1.0
 */
/**
 * @метод IPlugin#beforeInit
 * @desc Вызывается перед инициализацией `chart`.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Object} options — Параметры плагина.
 */
/**
 * @метод IPlugin#afterInit
 * @desc Вызывается после инициализации `chart` и перед первым обновлением.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Object} options — Параметры плагина.
 */
/**
 * @метод IPlugin#beforeUpdate
 * @desc Вызывается перед обновлением `chart`. Если какой-либо плагин возвращает `false`, обновление
 * отменяется (и, следовательно, последующий рендеринг) до тех пор, пока не будет запущено другое `обновление`.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Object} options — Параметры плагина.
 * @returns {Boolean} `false` для отмены обновления диаграммы.
 */
/**
 * @метод IPlugin#afterUpdate
 * @desc Вызывается после обновления `chart` и перед рендерингом. Обратите внимание, что это
 * хук не будет вызван, если обновление графика было ранее отменено.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Object} options — Параметры плагина.
 */
/**
 * @method IPlugin#beforeDatasetsUpdate
 * @desc Вызывается перед обновлением наборов данных `chart`. Если какой-либо плагин возвращает `false`,
 * обновление наборов данных отменяется до тех пор, пока не будет запущено другое `обновление`.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Object} options — Параметры плагина.
 * @returns {Boolean} false для отмены обновления наборов данных.
 * @начиная с версии 2.1.5
*/
/**
 * @method IPlugin#afterDatasetsUpdate
 * @desc Вызывается после обновления наборов данных `chart`. Обратите внимание, что этот хук
 * не будет вызван, если обновление наборов данных было ранее отменено.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Object} options — Параметры плагина.
 * @начиная с версии 2.1.5
 */
/**
 * @method IPlugin#beforeDatasetUpdate
 * @desc Вызывается перед обновлением набора данных `chart` по указанному `args.index`. Если какой-либо плагин
 * возвращает `false`, обновление наборов данных отменяется до тех пор, пока не будет запущено другое `обновление`.
 * @param {Chart} chart — экземпляр диаграммы.
 * @param {Object} args — Аргументы вызова.
 * @param {Number} args.index — индекс набора данных.
 * @param {Object} args.meta — метаданные набора данных.
 * @param {Object} options — Параметры плагина.
 * @returns {Boolean} `false` для отмены рисования наборов данных диаграммы.
 */
/**
 * @метод IPlugin#afterDatasetUpdate
 * @desc Вызывается после обновления наборов данных `chart` по указанному `args.index`. Примечание
 * этот хук не будет вызван, если обновление наборов данных было ранее отменено.
 * @param {Chart} chart — экземпляр диаграммы.
 * @param {Object} args — Аргументы вызова.
 * @param {Number} args.index — индекс набора данных.
 * @param {Object} args.meta — метаданные набора данных.
 * @param {Object} options — Параметры плагина.
 */
/**
 * @метод IPlugin#beforeLayout
 * @desc Вызывается перед выкладкой `chart`. Если какой-либо плагин возвращает `false`,
 * обновление макета отменяется до тех пор, пока не будет запущено другое `обновление`.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Object} options — Параметры плагина.
 * @returns {Boolean} `false` для отмены макета диаграммы.
 */
/**
 * @метод IPlugin#afterLayout
 * @desc Вызывается после того, как `chart` был выложен. Обратите внимание, что этот хук не будет
 * вызывается, если обновление макета было ранее отменено.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Object} options — Параметры плагина.
 */
/**
 * @метод IPlugin#beforeRender
 * @desc Вызывается перед рендерингом `chart`. Если какой-либо плагин возвращает `false`,
 * рендеринг отменяется до тех пор, пока не будет запущен другой `рендер`.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Object} options — Параметры плагина.
 * @returns {Boolean} `false` для отмены рендеринга диаграммы.
 */
/**
 * @метод IPlugin#afterRender
 * @desc Вызывается после того, как `chart` полностью отрисован (и анимация завершена). Примечание
 * этот хук не будет вызван, если рендеринг был ранее отменен.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Object} options — Параметры плагина.
 */
/**
 * @метод IPlugin#beforeDraw
 * @desc Вызывается перед рисованием `chart` в каждом кадре анимации, указанном заданным
 * значение ослабления. Если какой-либо плагин возвращает `false`, отрисовка кадра отменяется до тех пор, пока
 * запускается еще один `рендер`.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Number} easingValue — Текущее значение анимации в диапазоне от 0,0 до 1,0.
 * @param {Object} options — Параметры плагина.
 * @returns {Boolean} `false` для отмены рисования диаграммы.
 */
/**
 * @метод IPlugin#afterDraw
 * @desc Вызывается после того, как `chart` был нарисован для определенного значения ослабления. Примечание
 * этот хук не будет вызван, если розыгрыш был ранее отменен.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Number} easingValue — Текущее значение анимации в диапазоне от 0,0 до 1,0.
 * @param {Object} options — Параметры плагина.
 */
/**
 * @method IPlugin#beforeDatasetsDraw
 * @desc Вызывается перед рисованием наборов данных `chart`. Если какой-либо плагин возвращает `false`,
 * отрисовка наборов данных отменяется до тех пор, пока не будет запущен другой `рендер`.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Number} easingValue — Текущее значение анимации в диапазоне от 0,0 до 1,0.
 * @param {Object} options — Параметры плагина.
 * @returns {Boolean} `false` для отмены рисования наборов данных диаграммы.
 */
/**
 * @method IPlugin#afterDatasetsDraw
 * @desc Вызывается после того, как наборы данных `chart` были нарисованы. Обратите внимание, что этот хук
 * не будет вызван, если отрисовка наборов данных была ранее отменена.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Number} easingValue — Текущее значение анимации в диапазоне от 0,0 до 1,0.
 * @param {Object} options — Параметры плагина.
 */
/**
 * @method IPlugin#beforeDatasetDraw
 * @desc Вызывается перед рисованием набора данных `chart` по указанному `args.index` (наборы данных
 * рисуются в обратном порядке). Если какой-либо плагин возвращает `false`, наборы данных рисуются
 * отменяется до тех пор, пока не будет запущен другой `рендер`.
 * @param {Chart} chart — экземпляр диаграммы.
 * @param {Object} args — Аргументы вызова.
 * @param {Number} args.index — индекс набора данных.
 * @param {Object} args.meta — метаданные набора данных.
 * @param {Number} args.easingValue — Текущее значение анимации в диапазоне от 0,0 до 1,0.
 * @param {Object} options — Параметры плагина.
 * @returns {Boolean} `false` для отмены рисования наборов данных диаграммы.
 */
/**
 * @метод IPlugin#afterDatasetDraw
 * @desc Вызывается после того, как наборы данных `chart` по указанному `args.index` были отрисованы
 * (наборы данных рисуются в обратном порядке). Обратите внимание, что этот хук не будет вызван
 * если отрисовка наборов данных была ранее отменена.
 * @param {Chart} chart — экземпляр диаграммы.
 * @param {Object} args — Аргументы вызова.
 * @param {Number} args.index — индекс набора данных.
 * @param {Object} args.meta — метаданные набора данных.
 * @param {Number} args.easingValue — Текущее значение анимации в диапазоне от 0,0 до 1,0.
 * @param {Object} options — Параметры плагина.
 */
/**
 * @method IPlugin#beforeTooltipDraw
 * @desc Вызывается перед рисованием `tooltip`. Если какой-либо плагин возвращает `false`,
 * отрисовка IP-адреса инструмента отменяется до тех пор, пока не будет запущен другой `рендер`.
 * @param {Chart} chart — экземпляр диаграммы.
 * @param {Object} args — Аргументы вызова.
 * @param {Object} args.tooltip — Подсказка.
 * @param {Number} args.easingValue — Текущее значение анимации в диапазоне от 0,0 до 1,0.
 * @param {Object} options — Параметры плагина.
 * @returns {Boolean} `false` для отмены рисования подсказки диаграммы.
 */
/**
 * @method IPlugin#afterTooltipDraw
 * @desc Вызывается после рисования `tooltip`. Обратите внимание, что этот хук не будет
 * вызывается, если отрисовка подсказки была ранее отменена.
 * @param {Chart} chart — экземпляр диаграммы.
 * @param {Object} args — Аргументы вызова.
 * @param {Object} args.tooltip — Подсказка.
 * @param {Number} args.easingValue — Текущее значение анимации в диапазоне от 0,0 до 1,0.
 * @param {Object} options — Параметры плагина.
 */
/**
 * @метод IPlugin#beforeEvent
 * @desc Вызывается перед обработкой указанного `event`. Если какой-либо плагин возвращает `false`,
 * событие будет отменено.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {IEvent} event — объект события.
 * @param {Object} options — Параметры плагина.
 */
/**
 * @метод IPlugin#afterEvent
 * @desc Вызывается после того, как `event` был использован. Обратите внимание, что этот хук
 * не будет вызван, если `событие` было ранее отменено.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {IEvent} event — объект события.
 * @param {Object} options — Параметры плагина.
 */
/**
 * @метод IPlugin#изменение размера
 * @desc Вызывается после изменения размера диаграммы.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Number} size — новый размер отображения холста (например, ширина и высота canvas.style).
 * @param {Object} options — Параметры плагина.
 */
/**
 * @метод IPlugin#destroy
 * @desc Вызывается после того, как диаграмма была уничтожена.
 * @param {Chart.Controller} chart — экземпляр диаграммы.
 * @param {Object} options — Параметры плагина.
 */

},{"25":25,"45":45}],32:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
Элемент var = require(26);
var helpers = require(45);
var Такты = require(34);

defaults._set('масштаб', {
	дисплей: правда,
	позиция: «слева»,
	смещение: ложь,

	// настройки линии сетки
	Линии сетки: {
		дисплей: правда,
		цвет: 'rgba(0, 0, 0, 0.1)',
		Ширина линии: 1,
		drawBorder: правда,
		drawOnChartArea: правда,
		drawTicks: правда,
		tickMarkLength: 10,
		нулевая ширина строки: 1,
		zeroLineColor: 'rgba(0,0,0,0.25)',
		zeroLineBorderDash: [],
		zeroLineBorderDashOffset: 0.0,
		offsetGridLines: ложь,
		borderDash: [],
		borderDashOffset: 0.0
	},

	// шкала метки
	scaleLabel: {
		// отображать свойство
		отображение: ложь,

		// фактическая метка
		МеткаСтрока: '',

		// высота строки
		lineHeight: 1.2,

		// верхний/нижний отступ
		отступ: {
			верх: 4,
			внизу: 4
		}
	},

	// настройки метки
	тики: {
		beginAtZero: ложь,
		минВращение: 0,
		макс.Вращение: 50,
		зеркало: ложное,
		заполнение: 0,
		обратный: ложный,
		дисплей: правда,
		автоПропуск: правда,
		autoSkipPadding: 0,
		Смещение метки: 0,
		// Мы передаем массивы для отображения в виде многострочных меток, здесь мы преобразуем Others в строки.
		обратный вызов: Ticks.formatters.values,
		незначительный: {},
		главный: {}
	}
});

функция labelsFromTicks(тики) {
	var метки = [];
	вар i, илен;

	для (i = 0, ilen = ticks.length; i < ilen; ++i) {
		labels.push(тиксы[i].метка);
	}

	этикетки возврата;
}

функция getLineValue(масштаб, индекс, offsetGridLines) {
	var lineValue = scale.getPixelForTick(index);

	если (offsetGridLines) {
		если (индекс === 0) {
			lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
		} еще {
			lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
		}
	}
	возврат строкиЗначение;
}

модуль.экспорты = функция(Диаграмма) {

	функция computeTextSize(контекст, тик, шрифт) {
		вернуть helpers.isArray(tick) ?
			helpers.longestText(контекст, шрифт, отметка):
			context.measureText(тик).ширина;
	}

	функция parseFontOptions(опции) {
		var значениеИлиПоУмолчанию = помощники.значениеИлиПоУмолчанию;
		var globalDefaults = defaults.global;
		var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
		var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
		var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);

		возвращаться {
			размер: размер,
			стиль: стиль,
			семья: семья,
			шрифт: helpers.fontString(размер, стиль, семейство)
		};
	}

	функция parseLineHeight(опции) {
		вернуть helpers.options.toLineHeight(
			helpers.valueOrDefault(options.lineHeight, 1.2),
			helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
	}

	Диаграмма.Масштаб = Элемент.расширить({
		/**
		 * Получите необходимую для весов прокладку
		 * @метод getPadding
		 * @частный
		 * @returns {Padding} — необходимый отступ
		 */
		получитьЗаполнение: функция() {
			var me = это;
			возвращаться {
				слева: me.paddingLeft || 0,
				вверху: me.paddingTop || 0,
				справа: me.paddingRight || 0,
				низ: me.paddingBottom || 0
			};
		},

		/**
		 * Возвращает объекты делений шкалы ({label, major})
		 * @с 2.7
		 */
		getTicks: функция() {
			вернуть это._тики;
		},

		// Эти методы упорядочены по жизненному циклу. Затем следуют утилиты.
		// Любая функция, определенная здесь, наследуется всеми типами масштабов.
		// Любая функция может быть расширена типом шкалы

		mergeTicksOptions: функция() {
			var ticks = this.options.ticks;
			если (тиксы.минор === ложь) {
				тики.минор = {
					дисплей: ложь
				};
			}
			если (тиксы.major === false) {
				тики.major = {
					дисплей: ложь
				};
			}
			для (var key в тиках) {
				если (ключ !== 'главный' && ключ !== 'второстепенный') {
					если (typeof ticks.minor[key] === 'undefined') {
						тики.минор[ключ] = тики[ключ];
					}
					если (typeof ticks.major[key] === 'undefined') {
						тики.major[ключ] = тики[ключ];
					}
				}
			}
		},
		доОбновления: функция() {
			helpers.callback(this.options.beforeUpdate, [this]);
		},
		обновить: функция(максШирина, максВысота, поля) {
			var me = это;
			var i, ilen, метки, ярлык, галочки, тик;

			// Обновление жизненного цикла - Вероятно, не стоит когда-либо расширять или перезаписывать эту функцию ;)
			я.beforeUpdate();

			// Поглощайте основные измерения
			я.максШирина = максШирина;
			я.максВысота = максВысота;
			я.поля = помощники.расширить({
				осталось: 0,
				справа: 0,
				вверху: 0,
				внизу: 0
			}, поля);
			я.самый длинныйТекстКэш = я.самый длинныйТекстКэш || {};

			// Размеры
			я.beforeSetDimensions();
			я.setDimensions();
			я.afterSetDimensions();

			// Данные мин/макс
			я.beforeDataLimits();
			я.determineDataLimits();
			я.afterDataLimits();

			// Такты - `this.ticks` теперь УСТАРЕЛ!
			// Внутренние тики теперь хранятся как объекты в члене PRIVATE `this._ticks`
			// и не должен быть доступен напрямую извне этого класса. `this.ticks` является
			// существует уже долгое время и не отмечен как частный, мы не можем изменить его структуру
			// без неожиданных критических изменений. Если вам нужно получить доступ к делениям шкалы,
			// вместо этого используйте scale.getTicks().

			я.beforeBuildTicks();

			// Новые реализации должны возвращать массив объектов, но для ОБРАТНОЙ СОВМЕСТИМОСТИ
			// мы по-прежнему не поддерживаем возврат (`this.ticks` устанавливается внутренне при вызове этого метода).
			тики = я.buildTicks() || [];

			я.afterBuildTicks();

			я.beforeTickToLabelConversion();

			// Новые реализации должны возвращать отформатированные метки делений, но для BACKWARD
			// COMPAT, мы по-прежнему поддерживаем отсутствие возврата (`this.ticks` внутренне изменено путем вызова
			// этот метод и должен содержать только строковые значения).
			метки = я.конвертироватьТикиВМетки(тики) || я.тики;

			я.afterTickToLabelConversion();

			me.ticks = labels; // ОБРАТНАЯ СОВМЕСТИМОСТЬ

			// ВАЖНО: с этого момента мы считаем, что `this.ticks` НИКОГДА не изменится!

			// ОБРАТНАЯ СОВМЕСТИМОСТЬ: синхронизируйте `_ticks` с метками (то есть потенциально `this.ticks`)
			для (i = 0, ilen = labels.length; i < ilen; ++i) {
				метка = метки[i];
				тик = тики[i];
				если (!тик) {
					тики.push(тик = {
						этикетка: этикетка,
						майор: ложный
					});
				} еще {
					отметка.метка = метка;
				}
			}

			me._ticks = тики;

			// Вращение тика
			я.beforeCalculateTickRotation();
			я.calculateTickRotation();
			я.afterCalculateTickRotation();
			// Соответствовать
			я.beforeFit();
			я.подходит();
			я.afterFit();
			//
			я.afterUpdate();

			вернуть мне.minSize;

		},
		послеОбновления: функция() {
			helpers.callback(эти.опции.послеОбновления, [это]);
		},

		//

		beforeSetDimensions: функция() {
			helpers.callback(this.options.beforeSetDimensions, [this]);
		},
		setDimensions: функция() {
			var me = это;
			// Устанавливаем неограниченный размер перед поворотом метки
			если (я.isHorizontal()) {
				// Сбросить позицию перед расчетом поворота
				я.ширина = я.максШирина;
				я.левый = 0;
				я.право = я.ширина;
			} еще {
				я.высота = я.максВысота;

				// Сбросить позицию перед расчетом поворота
				я.топ = 0;
				я.низ = я.рост;
			}

			// Сбросить отступы
			я.paddingLeft = 0;
			я.paddingTop = 0;
			я.paddingRight = 0;
			я.paddingBottom = 0;
		},
		afterSetDimensions: функция() {
			helpers.callback(this.options.afterSetDimensions, [this]);
		},

		// Ограничения по данным
		beforeDataLimits: функция() {
			helpers.callback(this.options.beforeDataLimits, [this]);
		},
		определитьDataLimits: helpers.noop,
		afterDataLimits: функция() {
			helpers.callback(this.options.afterDataLimits, [this]);
		},

		//
		beforeBuildTicks: функция() {
			helpers.callback(this.options.beforeBuildTicks, [this]);
		},
		buildTicks: helpers.noop,
		afterBuildTicks: функция() {
			helpers.callback(this.options.afterBuildTicks, [this]);
		},

		beforeTickToLabelConversion: функция() {
			helpers.callback(this.options.beforeTickToLabelConversion, [this]);
		},
		convertTicksToLabels: функция() {
			var me = это;
			// Преобразуем тики в строки
			var tickOpts = me.options.ticks;
			я.тикс = я.тикс.карта(tickOpts.userCallback || tickOpts.callback, this);
		},
		afterTickToLabelConversion: функция() {
			helpers.callback(this.options.afterTickToLabelConversion, [this]);
		},

		//

		beforeCalculateTickRotation: функция() {
			helpers.callback(this.options.beforeCalculateTickRotation, [this]);
		},
		calculateTickRotation: функция() {
			var me = это;
			var context = я.ctx;
			var tickOpts = me.options.ticks;
			var labels = labelsFromTicks(me._ticks);

			// Получаем ширину каждой сетки, вычисляя разницу
			// между смещениями по оси x от 0 до 1.
			вар TicketFont = parseFontOptions (tickOpts);
			context.font = tickFont.font;

			var labelRotation = tickOpts.minRotation || 0;

			если (labels.length && me.options.display && me.isHorizontal()) {
				var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
				var labelWidth = originalLabelWidth;
				var cosВращение, sinВращение;

				// Разрешить отступ 3 пикселя x2 с каждой стороны для удобства чтения метки
				var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;

				// Максимальное вращение этикетки можно задать или установить по умолчанию на 90 градусов — также действует как счетчик циклов
				в то время как (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
					var angleRadians = helpers.toRadians(labelRotation);
					cosRotation = Math.cos(уголРадианы);
					sinRotation = Math.sin(уголРадианы);

					если (sinRotation * originalLabelWidth > me.maxHeight) {
						// вернуться на один шаг назад
						labelRotation--;
						перерыв;
					}

					меткаRotation++;
					labelWidth = cosRotation * originalLabelWidth;
				}
			}

			me.labelRotation = labelRotation;
		},
		afterCalculateTickRotation: функция() {
			helpers.callback(this.options.afterCalculateTickRotation, [this]);
		},

		//

		beforeFit: функция() {
			helpers.callback(эти.опции.beforeFit, [это]);
		},
		подходит: функция() {
			var me = это;
			// Перезагрузить
			var minSize = me.minSize = {
				ширина: 0,
				высота: 0
			};

			var labels = labelsFromTicks(me._ticks);

			var opts = me.options;
			var tickOpts = opts.ticks;
			вар ScaleLabelOpts = opts.scaleLabel;
			var gridLineOpts = opts.gridLines;
			var display = opts.display;
			вар isHorizontal = me.isHorizontal();

			вар TicketFont = parseFontOptions (tickOpts);
			var tickMarkLength = opts.gridLines.tickMarkLength;

			// Ширина
			если (горизонтально) {
				// вычитаем поля, чтобы выровнять с chartArea, если у нас масштаб полной ширины
				minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
			} еще {
				minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
			}

			// высота
			если (горизонтально) {
				minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
			} еще {
				minSize.height = me.maxHeight; // заполнить всю высоту
			}

			// Показываем ли мы название шкалы?
			если (scaleLabelOpts.display && display) {
				вар ScaleLabelLineHeight = parseLineHeight (scaleLabelOpts);
				var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
				var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;

				если (горизонтально) {
					minSize.height += deltaHeight;
				} еще {
					minSize.width += deltaHeight;
				}
			}

			// Не беспокойтесь о подгонке галочек, если мы их не показываем
			если (tickOpts.display && display) {
				var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
				var tallestLabelHeightInLines = helpers.numberOfLabelLines(метки);
				вар lineSpace = TicketFont.size * 0,5;
				var tickPadding = me.options.ticks.padding;

				если (горизонтально) {
					// Горизонтальная ось больше ограничена высотой.
					me.longestLabelWidth = largestTextWidth;

					var angleRadians = helpers.toRadians(me.labelRotation);
					var cosRotation = Math.cos(уголРадианы);
					вар sinRotation = Math.sin(angleRadians);

					// TODO - улучшить этот расчет
					var labelHeight = (sinRotation * largestTextWidth)
						+ (tickFont.size * tallestLabelHeightInLines)
						+ (пробел_линии * (самая_высокая_высота_метки_в_строках - 1))
						+ lineSpace; // отступ

					minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);

					me.ctx.font = tickFont.font;
					var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
					var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);

					// Убедитесь, что наши отметки всегда находятся внутри холста. При повороте отметки выравниваются по правому краю
					// что означает, что правый отступ определяется высотой шрифта
					если (я.меткаВращение !== 0) {
						me.paddingLeft = opts.position === 'bottom' ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // добавляем 3 пикселя, чтобы отойти от краев холста
						me.paddingRight = opts.position === 'bottom' ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;
					} еще {
						me.paddingLeft = firstLabelWidth / 2 + 3; // добавляем 3 пикселя, чтобы отойти от краев холста
						me.paddingRight = lastLabelWidth / 2 + 3;
					}
				} еще {
					// Вертикальная ось больше ограничена шириной. Метки — это
					// доминирующий фактор здесь, поэтому сначала получите эту длину и учтите заполнение
					если (tickOpts.mirror) {
						НаибольшаяШиринаТекста = 0;
					} еще {
						// используйте lineSpace для согласованности с горизонтальной осью
						// tickPadding не реализован для горизонтали
						largestTextWidth += tickPadding + lineSpace;
					}

					minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);

					me.paddingTop = tickFont.size / 2;
					me.paddingBottom = tickFont.size / 2;
				}
			}

			я.handleMargins();

			me.width = minSize.width;
			я.высота = минРазмер.высота;
		},

		/**
		 * Обработка полей и взаимодействий с отступами
		 * @частный
		 */
		handleMargins: функция() {
			var me = это;
			если (я.поля) {
				я.paddingLeft = Math.max(я.paddingLeft - я.margins.left, 0);
				я.paddingTop = Math.max(я.paddingTop - я.margins.top, 0);
				я.paddingRight = Math.max(я.paddingRight - я.margins.right, 0);
				я.paddingBottom = Math.max(я.paddingBottom - я.margins.bottom, 0);
			}
		},

		afterFit: функция() {
			helpers.callback(this.options.afterFit, [this]);
		},

		// Общие методы
		isHorizontal: функция() {
			вернуть this.options.position === 'top' || this.options.position === 'bottom';
		},
		isFullWidth: функция() {
			вернуть (this.options.fullWidth);
		},

		// Получить правильное значение. NaN - неверные входные данные. Если тип значения - объект, получим x или y в зависимости от того, горизонтальны мы или нет.
		getRightValue: функция (rawValue) {
			// Сначала нулевые и неопределенные значения
			если (helpers.isNullOrUndef(rawValue)) {
				вернуть NaN;
			}
			// isNaN(object) возвращает true, поэтому убедитесь, что NaN проверяет число; Отбросьте бесконечные значения
			если (typeof rawValue === 'number' && !isFinite(rawValue)) {
				вернуть NaN;
			}
			// Если это действительно объект, ныряем еще на один уровень
			если (rawValue) {
				если (это.isHorizontal()) {
					если (rawValue.x !== неопределено) {
						вернуть this.getRightValue(rawValue.x);
					}
				} иначе если (rawValue.y !== не определено) {
					вернуть this.getRightValue(rawValue.y);
				}
			}

			// Значение верное, возвращаем его
			вернуть rawValue;
		},

		/**
		 * Используется для получения значения, отображаемого во всплывающей подсказке для данных по указанному индексу.
		 * @параметр индекса
		 * @param datasetIndex
		 */
		getLabelForIndex: helpers.noop,

		/**
		 * Возвращает местоположение указанной точки данных. Значение может быть индексом или числовым значением
		 * Координата (0, 0) находится в верхнем левом углу холста.
		 * @параметр значение
		 * @параметр индекса
		 * @param datasetIndex
		 */
		getPixelForValue: helpers.noop,

		/**
		 * Используется для получения значения данных из заданного пикселя. Это обратная функция getPixelForValue
		 * Координата (0, 0) находится в верхнем левом углу холста.
		 * @параметр пиксель
		 */
		getValueForPixel: helpers.noop,

		/**
		 * Возвращает местоположение отметки по указанному индексу
		 * Координата (0, 0) находится в верхнем левом углу холста.
		 */
		getPixelForTick: функция(индекс) {
			var me = это;
			вар смещение = me.options.offset;
			если (я.isHorizontal()) {
				var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
				var tickWidth = innerWidth / Math.max((me._ticks.length - (смещение ? 0 : 1)), 1);
				var pixel = (tickWidth * index) + me.paddingLeft;

				если (смещение) {
					пиксель += tickWidth / 2;
				}

				var finalVal = me.left + Math.round(пиксель);
				finalVal += me.isFullWidth() ? me.margins.left : 0;
				вернуть finalVal;
			}
			var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
			вернуть меня.верх + (индекс * (внутренняявысота / (я._тиков.длина - 1)));
		},

		/**
		 * Утилита для получения местоположения пикселя в процентах от масштаба
		 * Координата (0, 0) находится в верхнем левом углу холста.
		 */
		getPixelForDecimal: функция (десятичное число) {
			var me = это;
			если (я.isHorizontal()) {
				var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
				var valueOffset = (innerWidth * десятичное число) + me.paddingLeft;

				var finalVal = me.left + Math.round(valueOffset);
				finalVal += me.isFullWidth() ? me.margins.left : 0;
				вернуть finalVal;
			}
			вернуть me.top + (десятичное * me.height);
		},

		/**
		 * Возвращает пиксель для минимального значения диаграммы
		 * Координата (0, 0) находится в верхнем левом углу холста.
		 */
		получитьBasePixel: функция() {
			вернуть this.getPixelForValue(this.getBaseValue());
		},

		получитьБазовоеЗначение: функция() {
			var me = это;
			var min = me.min;
			var max = me.max;

			вернуть меня.beginAtZero ? 0 :
				мин < 0 && макс < 0 ? макс :
				мин > 0 && макс > 0 ? мин :
				0;
		},

		/**
		 * Возвращает подмножество отметок, которые необходимо нанести на график, чтобы избежать перекрытия меток.
		 * @частный
		 */
		_autoSkip: функция(тики) {
			var skipRatio;
			var me = это;
			вар isHorizontal = me.isHorizontal();
			var optionTicks = me.options.ticks.minor;
			var tickCount = ticks.length;
			var labelRotationRadians = helpers.toRadians(me.labelRotation);
			var cosRotation = Math.cos(меткаRotationRadians);
			var longestRotatedLabel = me.longestLabelWidth * cosRotation;
			var результат = [];
			var i, тик, shouldSkip;

			// вычислить максимальное количество линий сетки для отображения
			var maxTicks;
			если (optionTicks.maxTicksLimit) {
				maxTicks = optionTicks.maxTicksLimit;
			}

			если (горизонтально) {
				skipRatio = false;

				если ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > (me.width - (me.paddingLeft + me.paddingRight))) {
					skipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));
				}

				// если они определили максимальное количество optionTicks,
				// увеличивайте skipRatio, пока это число не будет достигнуто
				если (максТики && тикКаунти > максТики) {
					skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
				}
			}

			для (i = 0; i < tickCount; i++) {
				тик = тики[i];

				// Поскольку мы всегда показываем последний тик, нам может потребоваться скрыть последний показанный тик перед
				shouldSkip = (skipRatio > 1 && i % skipRatio > 0) || (i % skipRatio === 0 && i + skipRatio >= tickCount);
				если (shouldSkip && i !== tickCount - 1) {
					// оставьте галочку на месте, но убедитесь, что она не отображается (#4635)
					удалить отметку;
				}
				результат.push(тик);
			}
			вернуть результат;
		},

		// На самом деле рисуем масштаб на холсте
		// @param {rectangle} chartArea : область диаграммы, на которой будут нарисованы полные линии сетки
		рисовать: функция(chartArea) {
			var me = это;
			var options = me.options;
			если (!options.display) {
				возвращаться;
			}

			var context = я.ctx;
			var globalDefaults = defaults.global;
			var optionTicks = options.ticks.minor;
			var optionMajorTicks = options.ticks.major || optionTicks;
			var gridLines = options.gridLines;
			вар ScaleLabel = options.scaleLabel;

			вар isRotated = me.labelRotation !== 0;
			вар isHorizontal = me.isHorizontal();

			var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
			var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
			вар TicketFont = parseFontOptions (optionTicks);
			var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
			вар majorTickFont = parseFontOptions (optionMajorTicks);

			var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;

			var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
			вар ScaleLabelFont = parseFontOptions (scaleLabel);
			var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
			var labelRotationRadians = helpers.toRadians(me.labelRotation);

			var itemsToDraw = [];

			var axisWidth = me.options.gridLines.lineWidth;
			var xTickStart = options.position === 'right' ? me.right : me.right - axisWidth - tl;
			var xTickEnd = options.position === 'right' ? me.right + tl : me.right;
			var yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;
			var yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;

			помощники.каждый(тики, функция(тик, индекс) {
				// автоскиппер пропустил этот тик (#4635)
				если (helpers.isNullOrUndef(tick.label)) {
					возвращаться;
				}

				var label = отметка.label;
				var lineWidth, lineColor, borderDash, borderDashOffset;
				если (индекс === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
					// Нарисуем первый индекс специально
					lineWidth = gridLines.zeroLineWidth;
					lineColor = gridLines.zeroLineColor;
					borderDash = gridLines.zeroLineBorderDash;
					borderDashOffset = gridLines.zeroLineBorderDashOffset;
				} еще {
					lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
					lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
					borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
					borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
				}

				// Общие свойства
				вар tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
				var textAlign = 'средний';
				var textBaseline = 'средний';
				var tickPadding = optionTicks.padding;

				если (горизонтально) {
					вар labelYOffset = tl + TicketPadding;

					если (options.position === 'bottom') {
						// нижний
						textBaseline = !isRotated ? 'top' : 'middle';
						textAlign = !isRotated ? 'center' : 'right';
						labelY = me.top + labelYOffset;
					} еще {
						// вершина
						textBaseline = !isRotated ? 'bottom' : 'middle';
						textAlign = !isRotated ? 'center' : 'left';
						labelY = me.bottom - labelYOffset;
					}

					var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
					если (xLineValue < me.left) {
						Цвет линии = 'rgba(0,0,0,0)';
					}
					xLineValue += helpers.aliasPixel(lineWidth);

					labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // значения x для optionTicks (необходимо учитывать опцию offsetLabel)

					tx1 = tx2 = x1 = x2 = xЗначениеСтроки;
					ty1 = yTickStart;
					ty2 = yTickEnd;
					y1 = chartArea.top;
					y2 = chartArea.bottom + axisWidth;
				} еще {
					var isLeft = options.position === 'left';
					var labelXOffset;

					если (optionTicks.mirror) {
						textAlign = isLeft ? 'left' : 'right';
						labelXOffset = tickPadding;
					} еще {
						textAlign = isLeft ? 'right' : 'left';
						labelXOffset = tl + tickPadding;
					}

					labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;

					var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
					если (yLineValue < me.top) {
						Цвет линии = 'rgba(0,0,0,0)';
					}
					yLineValue += helpers.aliasPixel(lineWidth);

					labelY = me.getPixelForTick(index) + optionTicks.labelOffset;

					tx1 = xTickStart;
					tx2 = xTickEnd;
					x1 = chartArea.left;
					x2 = chartArea.right + axisWidth;
					ty1 = ty2 = y1 = y2 = yLineValue;
				}

				itemsToDraw.push({
					передача1: передача1,
					ty1: ty1,
					передача2: передача2,
					ty2: ty2,
					х1: х1,
					у1: у1,
					х2: х2,
					у2: у2,
					меткаX: меткаX,
					меткаY: меткаY,
					glWidth: ширина линии,
					glColor: цвет линии,
					glBorderDash: borderDash,
					glBorderDashOffset: смещение границы,
					вращение: -1 * labelRotationRadians,
					этикетка: этикетка,
					мажор: тик.мажор,
					текстовая базовая линия: текстовая базовая линия,
					Выравнивание текста: Выравнивание текста
				});
			});

			// Нарисуйте все метки, отметки и линии сетки в правильных местах
			помощники.каждый(itemsToDraw, функция(itemToDraw) {
				если (gridLines.display) {
					контекст.сохранить();
					context.lineWidth = itemToDraw.glWidth;
					context.strokeStyle = itemToDraw.glColor;
					если (контекст.setLineDash) {
						context.setLineDash(itemToDraw.glBorderDash);
						context.lineDashOffset = itemToDraw.glBorderDashOffset;
					}

					context.beginPath();

					если (gridLines.drawTicks) {
						context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
						context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
					}

					если (gridLines.drawOnChartArea) {
						context.moveTo(itemToDraw.x1, itemToDraw.y1);
						context.lineTo(itemToDraw.x2, itemToDraw.y2);
					}

					контекст.штрих();
					контекст.восстановить();
				}

				если (optionTicks.display) {
					// Убедитесь, что мы рисуем текст правильным цветом и шрифтом
					контекст.сохранить();
					context.translate(itemToDraw.labelX, itemToDraw.labelY);
					context.rotate(itemToDraw.rotation);
					context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
					context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
					context.textBaseline = itemToDraw.textBaseline;
					context.textAlign = itemToDraw.textAlign;

					var label = itemToDraw.label;
					если (helpers.isArray(метка)) {
						var lineCount = label.length;
						var lineHeight = tickFont.size * 1.5;
						var y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;

						для (var i = 0; i < lineCount; ++i) {
							// Здесь мы просто убеждаемся, что многострочный элемент является строкой.
							context.fillText('' + label[i], 0, y);
							// применить тот же lineSpacing, который был рассчитан @ L#320
							y += lineHeight;
						}
					} еще {
						context.fillText(метка, 0, 0);
					}
					контекст.восстановить();
				}
			});

			если (scaleLabel.display) {
				// Нарисуйте метку шкалы
				var scaleLabelX;
				var scaleLabelY;
				переменная вращения = 0;
				var halfLineHeight = parseLineHeight(scaleLabel) / 2;

				если (горизонтально) {
					scaleLabelX = me.left + ((me.right - me.left) / 2); // середина ширины
					scaleLabelY = options.position === 'bottom'
						? me.bottom - halfLineHeight - scaleLabelPadding.bottom
						: me.top + halfLineHeight + scaleLabelPadding.top;
				} еще {
					var isLeft = options.position === 'left';
					scaleLabelX = isLeft
						? me.left + halfLineHeight + scaleLabelPadding.top
						: me.right - halfLineHeight - scaleLabelPadding.top;
					scaleLabelY = я.верх + ((я.низ - я.верх) / 2);
					вращение = isLeft ? -0,5 * Матем.ПИ : 0,5 * Матем.ПИ;
				}

				контекст.сохранить();
				context.translate(scaleLabelX, ScaleLabelY);
				context.rotate(вращение);
				context.textAlign = 'центр';
				context.textBaseline = 'средний';
				context.fillStyle = scaleLabelFontColor; // отрисовать в правильном цвете
				context.font = ScaleLabelFont.font;
				context.fillText(scaleLabel.labelString, 0, 0);
				контекст.восстановить();
			}

			если (gridLines.drawBorder) {
				// Рисуем линию по краю оси
				context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
				context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
				var x1 = я.левый;
				var x2 = me.right + axisWidth;
				var y1 = я.топ;
				вар y2 = me.bottom + axisWidth;

				var aliasPixel = helpers.aliasPixel(context.lineWidth);
				если (горизонтально) {
					y1 = y2 = options.position === 'top' ? me.bottom : me.top;
					y1 += aliasPixel;
					y2 += aliasPixel;
				} еще {
					x1 = x2 = options.position === 'left' ? me.right : me.left;
					x1 += aliasPixel;
					x2 += aliasPixel;
				}

				context.beginPath();
				контекст.переместитьВ(x1, y1);
				context.lineTo(x2, y2);
				контекст.штрих();
			}
		}
	});
};

},{"25":25,"26":26,"34":34,"45":45}],33:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
var helpers = require(45);
var layouts = require(30);

модуль.экспорты = функция(Диаграмма) {

	Chart.scaleService = {
		// Объект регистрации масштаба. Расширения могут регистрировать новые типы масштабов (например, логарифмические или шкалы БД), а затем
		// используйте новые параметры диаграммы, чтобы выбрать правильный масштаб
		конструкторы: {},
		// Используем функцию регистрации, чтобы мы могли перейти на карту ES6, когда нам больше не нужно поддерживать
		// старые браузеры

		// Масштабировать конфигурацию по умолчанию
		значения по умолчанию: {},
		registerScaleType: функция(тип, scaleConstructor, scaleDefaults) {
			этот.конструкторы[тип] = scaleConstructor;
			this.defaults[тип] = helpers.clone(scaleDefaults);
		},
		getScaleConstructor: функция(тип) {
			вернуть this.constructors.hasOwnProperty(тип) ? this.constructors[тип] : не определено;
		},
		getScaleDefaults: функция(тип) {
			// Возвращаем значения по умолчанию для масштаба, объединенные с глобальными настройками, чтобы мы всегда использовали последние
			вернуть this.defaults.hasOwnProperty(тип) ? helpers.merge({}, [defaults.scale, this.defaults[тип]]) : {};
		},
		updateScaleDefaults: функция(тип, дополнения) {
			var me = это;
			если (me.defaults.hasOwnProperty(тип)) {
				me.defaults[тип] = helpers.extend(me.defaults[тип], дополнения);
			}
		},
		addScalesToLayout: функция(диаграмма) {
			// Добавляет каждую шкалу в массив chart.boxes для соответствующего размера
			помощники.каждый(диаграмма.масштабы, функция(масштаб) {
				// Установите параметры ILayoutItem для обратной совместимости
				масштаб.полнаяШирина = масштаб.опции.полнаяШирина;
				масштаб.позиция = масштаб.опции.позиция;
				масштаб.вес = масштаб.опции.вес;
				layouts.addBox(диаграмма, масштаб);
			});
		}
	};
};

},{"25":25,"30":30,"45":45}],34:[function(require,module,exports){
«использовать строго»;

var helpers = require(45);

/**
 * Пространство имен для хранения статических функций генерации тиков
 * @namespace Диаграмма.Тики
 */
модуль.экспорты = {
	/**
	 * Пространство имен для хранения форматировщиков для различных типов отметок
	 * @namespace Диаграмма.Ticks.formatters
	 */
	форматировщики: {
		/**
		 * Форматировщик для меток значений
		 * @method Диаграмма.Ticks.formatters.values
		 * @param value значение для отображения
		 * @return {String|Array} метка для отображения
		 */
		значения: функция(значение) {
			return helpers.isArray(value) ? value : '' + value;
		},

		/**
		 * Форматировщик для линейных числовых отметок
		 * @method Chart.Ticks.formatters.linear
		 * @param tickValue {Number} значение для форматирования
		 * @param index {Number} позиция параметра tickValue в массиве ticks
		 * @param ticks {Array<Number>} список преобразуемых тиков
		 * @return {String} строковое представление параметра tickValue
		 */
		линейная: функция(tickValue, индекс, такты) {
			// Если у нас много галочек, не используем те, которые есть
			var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

			// Если у нас есть число, например, 2,5 в качестве дельты, выясним, сколько десятичных знаков нам нужно
			если (Math.abs(дельта) > 1) {
				если (tickValue !== Math.floor(tickValue)) {
					// не целое число
					delta = tickValue - Math.floor(tickValue);
				}
			}

			вар logDelta = helpers.log10(Math.abs(дельта));
			var tickString = '';

			если (tickValue !== 0) {
				var numDecimal = -1 * Math.floor(logDelta);
				numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed имеет максимум 20 десятичных знаков
				tickString = tickValue.toFixed(numDecimal);
			} еще {
				tickString = '0'; // никогда не показывать десятичные знаки для 0
			}

			вернуть tickString;
		},

		логарифмическая: функция(tickValue, index, ticks) {
			var remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));

			если (tickValue === 0) {
				вернуть «0»;
			} иначе если (осталось === 1 || осталось === 2 || осталось === 5 || индекс === 0 || индекс === ticks.length - 1) {
				вернуть tickValue.toExponential();
			}
			возвращаться '';
		}
	}
};

},{"45":45}],35:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
Элемент var = require(26);
var helpers = require(45);

defaults._set('глобальный', {
	подсказки: {
		включено: правда,
		пользовательский: нуль,
		режим: «ближайший»,
		позиция: «средняя»,
		пересечение: правда,
		Цвет фона: 'rgba(0,0,0,0.8)',
		titleFontStyle: 'жирный',
		заголовокИнтервал: 2,
		titleMarginBottom: 6,
		titleFontColor: '#fff',
		titleAlign: 'left',
		bodySpacing: 2,
		Цвет шрифта тела: '#fff',
		bodyAlign: 'влево',
		footerFontStyle: 'жирный',
		Нижний колонтитулИнтервал: 2,
		footerMarginTop: 6,
		footerFontColor: '#fff',
		footerAlign: 'left',
		yЗаполнение: 6,
		xЗаполнение: 6,
		кареткаPadding: 2,
		Размер каретки: 5,
		УголРадиус: 6,
		multiKeyBackground: '#fff',
		displayColors: правда,
		Цвет границы: 'rgba(0,0,0,0)',
		Ширина границы: 0,
		обратные вызовы: {
			// Аргументы: (tooltipItems, data)
			доНазвание: helpers.noop,
			заголовок: функция(tooltipItems, данные) {
				// Выберите первый xLabel на данный момент
				var title = '';
				var labels = данные.метки;
				var labelCount = labels ? labels.length : 0;

				если (tooltipItems.length > 0) {
					var item = tooltipItems[0];

					если (item.xLabel) {
						заголовок = item.xLabel;
					} иначе если (labelCount > 0 && item.index < labelCount) {
						заголовок = метки[элемент.индекс];
					}
				}

				вернуть заголовок;
			},
			afterTitle: помощники.noop,

			// Аргументы: (tooltipItems, data)
			beforeBody: помощники.noop,

			// Аргументы: (tooltipItem, data)
			beforeLabel: помощники.noop,
			метка: функция(tooltipItem, данные) {
				var label = data.datasets[tooltipItem.datasetIndex].label || '';

				если (метка) {
					метка += ': ';
				}
				метка += tooltipItem.yLabel;
				этикетка возврата;
			},
			labelColor: функция(tooltipItem, chart) {
				var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
				var activeElement = meta.data[tooltipItem.index];
				var view = activeElement._view;
				возвращаться {
					Цвет границы: view.цвет границы,
					Цвет фона: view.Цвет фона
				};
			},
			labelTextColor: функция() {
				вернуть this._options.bodyFontColor;
			},
			afterLabel: помощники.noop,

			// Аргументы: (tooltipItems, data)
			afterBody: помощники.noop,

			// Аргументы: (tooltipItems, data)
			beforeFooter: помощники.noop,
			нижний колонтитул: helpers.noop,
			afterFooter: помощники.noop
		}
	}
});

модуль.экспорты = функция(Диаграмма) {

	/**
 	 * Вспомогательный метод для объединения непрозрачности в цвет
 	 */
	функция mergeOpacity(colorString, opacity) {
		var color = helpers.color(colorString);
		вернуть цвет.альфа(непрозрачность * цвет.альфа()).rgbaString();
	}

	// Помощник для push или concat в зависимости от того, является ли 2-й параметр массивом или нет
	функция pushOrConcat(база, toPush) {
		если (toPush) {
			если (helpers.isArray(toPush)) {
				// база = база.concat(toPush);
				Массив.прототип.push.apply(база, toPush);
			} еще {
				база.push(toPush);
			}
		}

		возврат базы;
	}

	// Частный помощник для создания модели элемента подсказки
	// @param element : элемент диаграммы (точка, дуга, полоса) для создания элемента подсказки
	// @return : новый элемент подсказки
	функция createTooltipItem(элемент) {
		var xScale = элемент._xScale;
		var yScale = element._yScale || element._scale; // обработка радара || polarArea charts
		var index = элемент._index;
		вар datasetIndex = element._datasetIndex;

		возвращаться {
			xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
			yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
			индекс: индекс,
			индекс набора данных: индекс набора данных,
			х: элемент._модель.х,
			у: элемент._модель.у
		};
	}

	/**
	 * Помощник для получения модели сброса для подсказки
	 * @param tooltipOpts {Object} параметры подсказки
	 */
	функция getBaseModel(tooltipOpts) {
		var globalDefaults = defaults.global;
		var значениеИлиПоУмолчанию = помощники.значениеИлиПоУмолчанию;

		возвращаться {
			// Позиционирование
			xPadding: подсказкаOpts.xPadding,
			yPadding: tooltipOpts.yPadding,
			xAlign: подсказкаOpts.xAlign,
			yAlign: подсказкаOpts.yAlign,

			// Тело
			bodyFontColor: подсказкаOpts.bodyFontColor,
			_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
			_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
			_bodyAlign: подсказкаOpts.bodyAlign,
			bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
			bodySpacing: tooltipOpts.bodySpacing,

			// Заголовок
			titleFontColor: TooltipOpts.titleFontColor,
			_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
			_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
			titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
			_titleAlign: tooltipOpts.titleAlign,
			titleSpacing: tooltipOpts.titleSpacing,
			titleMarginBottom: подсказкаOpts.titleMarginBottom,

			// Нижний колонтитул
			footerFontColor: tooltipOpts.footerFontColor,
			_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
			_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
			footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
			_footerAlign: подсказкаOpts.footerAlign,
			footerSpacing: tooltipOpts.footerSpacing,
			footerMarginTop: подсказкаOpts.footerMarginTop,

			// Появление
			caretSize: подсказкаOpts.caretSize,
			cornerRadius: подсказкаOpts.cornerRadius,
			backgroundColor: подсказкаOpts.backgroundColor,
			непрозрачность: 0,
			legendColorBackground: подсказкаOpts.multiKeyBackground,
			displayColors: подсказкаOpts.displayColors,
			borderColor: подсказкаOpts.borderColor,
			borderWidth: подсказкаOpts.borderWidth
		};
	}

	/**
	 * Получить размер подсказки
	 */
	функция getTooltipSize(подсказка, модель) {
		var ctx = tooltip._chart.ctx;

		var height = model.yPadding * 2; // Отступ подсказки
		переменная ширина = 0;

		// Количество всех строк в теле
		var body = модель.body;
		var combinedBodyLength = body.reduce(function(count, bodyItem) {
			вернуть количество + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
		}, 0);
		combinedBodyLength += model.beforeBody.length + model.afterBody.length;

		var titleLineCount = model.title.length;
		var footerLineCount = model.footer.length;
		вар titleFontSize = model.titleFontSize;
		вар bodyFontSize = model.bodyFontSize;
		var footerFontSize = model.footerFontSize;

		height += titleLineCount * titleFontSize; // Строки заголовка
		height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Интервал между строками заголовка
		height += titleLineCount ? model.titleMarginBottom : 0; // Нижнее поле заголовка
		высота += combinedBodyLength * bodyFontSize; // Строки тела
		height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Расстояние между линиями тела
		height += footerLineCount ? model.footerMarginTop : 0; // Поле нижнего колонтитула
		height += footerLineCount * (footerFontSize); // Строки нижнего колонтитула
		height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Межстрочный интервал нижнего колонтитула

		// Ширина заголовка
		var widthPadding = 0;
		var maxLineWidth = функция(строка) {
			ширина = Math.max(ширина, ctx.measureText(строка).width + widthPadding);
		};

		ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
		helpers.each(model.title, maxLineWidth);

		// Ширина тела
		ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
		helpers.each(модель.beforeBody.concat(модель.afterBody), maxLineWidth);

		// Линии тела могут иметь дополнительную ширину из-за цветового поля
		widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;
		помощники.каждый(тело, функция(bodyItem) {
			helpers.each(bodyItem.before, maxLineWidth);
			helpers.each(bodyItem.lines, maxLineWidth);
			helpers.each(bodyItem.after, maxLineWidth);
		});

		// Сбросить обратно на 0
		ШиринаЗаполнения = 0;

		// Ширина нижнего колонтитула
		ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
		helpers.each(модель.footer, maxLineWidth);

		// Добавить отступ
		ширина += 2 * model.xPadding;

		возвращаться {
			ширина: ширина,
			высота: высота
		};
	}

	/**
	 * Помощник для выравнивания подсказки с учетом размера
	 */
	функция determineAlignment(подсказка, размер) {
		var model = tooltip._model;
		var chart = tooltip._chart;
		варchartArea = Tooltip._chart.chartArea;
		var xAlign = 'центр';
		var yAlign = 'центр';

		если (модель.y < размер.высота) {
			yAlign = 'сверху';
		} иначе если (модель.y > (высота.диаграммы - размер.высота)) {
			yAlign = 'снизу';
		}

		var lf, rf; // функции для определения выравнивания по левому и правому краю
		var olf, orf; // функции для определения, приводит ли выравнивание по левому/правому краю к выходу подсказки за пределы диаграммы
		var yf; // функция для получения выравнивания по оси Y, если подсказка выходит за пределы левого или правого края
		var MidX = (chartArea.left +chartArea.right)/2;
		var MidY = (chartArea.top +chartArea.bottom)/2;

		если (yAlign === 'center') {
			lf = функция(x) {
				вернуть x <= midX;
			};
			рф = функция(х) {
				вернуть x > midX;
			};
		} еще {
			lf = функция(x) {
				вернуть x <= (размер.ширина / 2);
			};
			рф = функция(х) {
				вернуть x >= (chart.width - (size.width / 2));
			};
		}

		ольф = функция(x) {
			вернуть x + size.width + model.caretSize + model.caretPadding > chart.width;
		};
		orf = функция(x) {
			вернуть x - размер.ширина - модель.размер_угла_заполнения - модель.заполнение_угла_заполнения < 0;
		};
		yf = функция(y) {
			вернуть y <= midY ? 'top' : 'bottom';
		};

		если (lf(модель.x)) {
			xAlign = 'влево';

			// Подсказка слишком широкая и выходит за правую сторону диаграммы?
			если (olf(модель.x)) {
				xAlign = 'центр';
				yAlign = yf(модель.y);
			}
		} иначе если (rf(модель.x)) {
			xAlign = 'справа';

			// Подсказка слишком широкая и выходит за левый край холста?
			если (orf(модель.x)) {
				xAlign = 'центр';
				yAlign = yf(модель.y);
			}
		}

		var opts = tooltip._options;
		возвращаться {
			xAlign: opts.xAlign ? opts.xAlign : xAlign,
			yAlign: opts.yAlign ? opts.yAlign : yAlign
		};
	}

	/**
	 * @Helper для получения местоположения, в котором необходимо разместить всплывающую подсказку, учитывая начальную позицию (через виртуальную машину), а также размер и выравнивание
	 */
	функция getBackgroundPoint(vm, размер, выравнивание, диаграмма) {
		// Фоновая позиция
		вар х = вм.х;
		вар у = вм.у;

		var caretSize = vm.caretSize;
		var caretPadding = vm.caretPadding;
		вар angularRadius = vm.cornerRadius;
		var xAlign = выравнивание.xAlign;
		var yAlign = выравнивание.yAlign;
		var paddingAndSize = caretSize + caretPadding;
		var radiusAndPadding = cornerRadius + caretPadding;

		если (xAlign === 'вправо') {
			x -= размер.ширина;
		} иначе если (xAlign === 'center') {
			x -= (размер.ширина / 2);
			если (x + размер.ширина > ширина.диаграммы) {
				x = ширина.диаграммы - размер.ширина;
			}
			если (х < 0) {
				х = 0;
			}
		}

		если (yAlign === 'top') {
			y += paddingAndSize;
		} иначе если (yAlign === 'bottom') {
			y -= размер.высота + отступИРазмер;
		} еще {
			у -= (размер.высота / 2);
		}

		если (yAlign === 'center') {
			если (xAlign === 'влево') {
				x += paddingAndSize;
			} иначе если (xAlign === 'right') {
				x -= paddingAndSize;
			}
		} иначе если (xAlign === 'left') {
			x -= радиусИОтступы;
		} иначе если (xAlign === 'right') {
			x += радиусИОтступ;
		}

		возвращаться {
			х: х,
			у: у
		};
	}

	Chart.Tooltip = Element.extend({
		инициализировать: функция() {
			this._model = getBaseModel(this._options);
			этот._lastActive = [];
		},

		// Получить заголовок
		// Аргументы: (tooltipItem, data)
		получитьЗаголовок: функция() {
			var me = это;
			var opts = me._options;
			var обратные вызовы = opts.обратные вызовы;

			var beforeTitle = callbacks.beforeTitle.apply(я, аргументы);
			var title = callbacks.title.apply(я, аргументы);
			var afterTitle = callbacks.afterTitle.apply(я, аргументы);

			var строки = [];
			строки = pushOrConcat(строки, передЗаголовком);
			строки = pushOrConcat(строки, заголовок);
			строки = pushOrConcat(строки, afterTitle);

			обратные линии;
		},

		// Аргументы: (tooltipItem, data)
		получитьBeforeBody: функция() {
			var lines = this._options.callbacks.beforeBody.apply(this, arguments);
			return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
		},

		// Аргументы: (tooltipItem, data)
		getBody: функция(tooltipItems, данные) {
			var me = это;
			var обратные вызовы = me._options.обратные вызовы;
			var bodyItems = [];

			helpers.each(tooltipItems, function(tooltipItem) {
				var bodyItem = {
					до: [],
					строки: [],
					после: []
				};
				pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
				pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
				pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));

				bodyItems.push(bodyItem);
			});

			вернуть bodyItems;
		},

		// Аргументы: (tooltipItem, data)
		получитьAfterBody: функция() {
			var lines = this._options.callbacks.afterBody.apply(this, arguments);
			return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
		},

		// Получить нижний колонтитул и строки beforeFooter и afterFooter
		// Аргументы: (tooltipItem, data)
		получитьFooter: функция() {
			var me = это;
			var обратные вызовы = me._options.обратные вызовы;

			var beforeFooter = callbacks.beforeFooter.apply(я, аргументы);
			var footer = callbacks.footer.apply(я, аргументы);
			var afterFooter = callbacks.afterFooter.apply(я, аргументы);

			var строки = [];
			строки = pushOrConcat(строки, beforeFooter);
			строки = pushOrConcat(строки, нижний колонтитул);
			строки = pushOrConcat(строки, afterFooter);

			обратные линии;
		},

		обновление: функция (изменено) {
			var me = это;
			var opts = me._options;

			// Необходимо перегенерировать модель, так как это быстрее, чем использование extend, и это необходимо из-за оптимизации в Chart.Element.transition
			// это делает _view = _model, если ease === 1. Это приводит к тому, что второе обновление подсказки устанавливает свойства как в представлении, так и в модели одновременно
			// что нарушает любую анимацию.
			вар существующаяМодель = me._model;
			var model = me._model = getBaseModel(opts);
			var active = я._active;

			var data = me._data;

			// В случае, когда active.length === 0, нам нужно сохранить существующие значения для хорошей анимации
			выравнивание переменной = {
				xAlign: существующаяМодель.xAlign,
				yAlign: существующаяМодель.yAlign
			};
			var backgroundPoint = {
				x: существующаяМодель.x,
				y: существующаяМодель.y
			};
			var tooltipSize = {
				ширина: существующаяМодель.ширина,
				высота: существующаяМодель.высота
			};
			var tooltipPosition = {
				x: существующаяМодель.caretX,
				y: существующаяМодель.caretY
			};

			вар i, лен;

			если (активная.длина) {
				модель.непрозрачность = 1;

				var labelColors = [];
				var labelTextColors = [];
				tooltipPosition = Chart.Tooltip.positioners[opts.position].call(me, active, me._eventPosition);

				var tooltipItems = [];
				для (i = 0, len = активная.длина; i < len; ++i) {
					tooltipItems.push(createTooltipItem(active[i]));
				}

				// Если пользователь предоставил функцию фильтра, используйте ее для изменения элементов подсказки
				если (опц.фильтр) {
					tooltipItems = tooltipItems.фильтр(функция(a) {
						вернуть opts.filter(a, data);
					});
				}

				// Если пользователь предоставил функцию сортировки, используйте ее для изменения элементов подсказки
				если (opts.itemSort) {
					tooltipItems = tooltipItems.sort(function(a, b) {
						вернуть opts.itemSort(a, b, data);
					});
				}

				// Определим цвета для ящиков
				helpers.each(tooltipItems, function(tooltipItem) {
					labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
					labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
				});


				// Построить текстовые строки
				model.title = me.getTitle(tooltipItems, data);
				model.beforeBody = me.getBeforeBody(элементы подсказки, данные);
				model.body = me.getBody(tooltipItems, data);
				model.afterBody = me.getAfterBody(элементы подсказки, данные);
				model.footer = me.getFooter(tooltipItems, data);

				// Начальное позиционирование и цвета
				model.x = Math.round(tooltipPosition.x);
				model.y = Math.round(tooltipPosition.y);
				model.caretPadding = opts.caretPadding;
				модель.labelColors = labelColors;
				model.labelTextColors = labelTextColors;

				// точки данных
				model.dataPoints = tooltipItems;

				// Нам нужно определить выравнивание подсказки
				tooltipSize = getTooltipSize(this, model);
				выравнивание = determineAlignment(this, tooltipSize);
				// Окончательный размер и положение
				backgroundPoint = getBackgroundPoint(модель, tooltipSize, выравнивание, me._chart);
			} еще {
				модель.непрозрачность = 0;
			}

			model.xAlign = выравнивание.xAlign;
			model.yAlign = выравнивание.yAlign;
			модель.x = фоноваяТочка.x;
			модель.y = backgroundPoint.y;
			model.width = tooltipSize.width;
			model.height = tooltipSize.height;

			// Точка, куда указывает курсор на подсказке
			model.caretX = tooltipPosition.x;
			model.caretY = tooltipPosition.y;

			я._модель = модель;

			если (изменено && opts.custom) {
				opts.custom.call(я, модель);
			}

			верни меня;
		},
		drawCaret: функция(tooltipPoint, размер) {
			var ctx = this._chart.ctx;
			var vm = this._view;
			var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);

			ctx.lineTo(caretPosition.x1, caretPosition.y1);
			ctx.lineTo(caretPosition.x2, caretPosition.y2);
			ctx.lineTo(caretPosition.x3, caretPosition.y3);
		},
		getCaretPosition: функция(tooltipPoint, размер, vm) {
			переменная x1, x2, x3, y1, y2, y3;
			var caretSize = vm.caretSize;
			вар angularRadius = vm.cornerRadius;
			var xAlign = vm.xAlign;
			var yAlign = vm.yAlign;
			var ptX = tooltipPoint.x;
			var ptY = tooltipPoint.y;
			переменная ширина = размер.ширина;
			var высота = размер.высота;

			если (yAlign === 'center') {
				y2 = ptY + (высота / 2);

				если (xAlign === 'влево') {
					x1 = ptX;
					x2 = x1 - размер_каретки;
					х3 = х1;

					y1 = y2 + caretSize;
					y3 = y2 - размер_каретки;
				} еще {
					x1 = ptX + ширина;
					x2 = x1 + размер_каретки;
					х3 = х1;

					y1 = y2 - размер_каретки;
					y3 = y2 + caretSize;
				}
			} еще {
				если (xAlign === 'влево') {
					x2 = ptX + cornerRadius + (caretSize);
					x1 = x2 - размер_каретки;
					x3 = x2 + размер_каретки;
				} иначе если (xAlign === 'right') {
					x2 = ptX + ширина - радиус угла - размер каретки;
					x1 = x2 - размер_каретки;
					x3 = x2 + размер_каретки;
				} еще {
					x2 = vm.caretX;
					x1 = x2 - размер_каретки;
					x3 = x2 + размер_каретки;
				}
				если (yAlign === 'top') {
					у1 = ptY;
					y2 = y1 - размер_каретки;
					у3 = у1;
				} еще {
					y1 = ptY + высота;
					y2 = y1 + caretSize;
					у3 = у1;
					// инвертировать порядок рисования
					вар tmp = x3;
					х3 = х1;
					x1 = tmp;
				}
			}
			вернуть {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};
		},
		drawTitle: функция(pt, vm, ctx, непрозрачность) {
			var title = vm.title;

			если (название.длина) {
				ctx.textAlign = vm._titleAlign;
				ctx.textBaseline = 'верх';

				вар titleFontSize = vm.titleFontSize;
				var titleSpacing = vm.titleSpacing;

				ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
				ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

				вар i, лен;
				для (i = 0, len = title.length; i < len; ++i) {
					ctx.fillText(title[i], pt.x, pt.y);
					pt.y += titleFontSize + titleSpacing; // Высота строки и интервал

					если (i + 1 === заголовок.длина) {
						pt.y += vm.titleMarginBottom - titleSpacing; // Если Last, добавить поле, удалить интервал
					}
				}
			}
		},
		drawBody: функция(pt, vm, ctx, непрозрачность) {
			вар bodyFontSize = vm.bodyFontSize;
			var bodySpacing = vm.bodySpacing;
			var body = vm.body;

			ctx.textAlign = vm._bodyAlign;
			ctx.textBaseline = 'верх';
			ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);

			// Перед телом
			var xLinePadding = 0;
			var fillLineOfText = функция(строка) {
				ctx.fillText(строка, pt.x + xLinePadding, pt.y);
				pt.y += bodyFontSize + bodySpacing;
			};

			// Перед линиями тела
			ctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);
			helpers.each(vm.beforeBody, fillLineOfText);

			var drawColorBoxes = vm.displayColors;
			xLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;

			// Нарисуем линии тела сейчас
			помощники.каждый(тело, функция(bodyItem, i) {
				var textColor = mergeOpacity(vm.labelTextColors[i], непрозрачность);
				ctx.fillStyle = цвет текста;
				helpers.each(bodyItem.before, fillLineOfText);

				помощники.каждый(bodyItem.строки, функция(строка) {
					// При необходимости нарисуйте поля, похожие на легенду
					если (drawColorBoxes) {
						// Заполняем белый прямоугольник так, чтобы цвета красиво смешивались, если непрозрачность < 1
						ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
						ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

						// Граница
						ctx.lineWidth = 1;
						ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
						ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);

						// Внутренний квадрат
						ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
						ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
						ctx.fillStyle = цвет текста;
					}

					fillLineOfText(строка);
				});

				helpers.each(bodyItem.after, fillLineOfText);
			});

			// Сбросить обратно на 0 для последующего тела
			xLinePadding = 0;

			// После линий тела
			helpers.each(vm.afterBody, fillLineOfText);
			pt.y -= bodySpacing; // Удалить последний интервал тела
		},
		drawFooter: функция(pt, vm, ctx, непрозрачность) {
			var footer = vm.footer;

			если (нижний колонтитул.длина) {
				pt.y += vm.footerMarginTop;

				ctx.textAlign = vm._footerAlign;
				ctx.textBaseline = 'верх';

				ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
				ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

				помощники.каждый(нижний колонтитул, функция(строка) {
					ctx.fillText(строка, точка.x, точка.y);
					pt.y += vm.footerFontSize + vm.footerSpacing;
				});
			}
		},
		drawBackground: функция(pt, vm, ctx, tooltipSize, opacity) {
			ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
			ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
			ctx.lineWidth = vm.borderWidth;
			var xAlign = vm.xAlign;
			var yAlign = vm.yAlign;
			var x = pt.x;
			var y = pt.y;
			var width = tooltipSize.width;
			var height = tooltipSize.height;
			var радиус = vm.cornerRadius;

			ctx.beginPath();
			ctx.moveTo(x + радиус, y);
			если (yAlign === 'top') {
				this.drawCaret(pt, tooltipSize);
			}
			ctx.lineTo(x + ширина - радиус, y);
			ctx.quadraticCurveTo(x + ширина, y, x + ширина, y + радиус);
			если (yAlign === 'center' && xAlign === 'right') {
				this.drawCaret(pt, tooltipSize);
			}
			ctx.lineTo(x + ширина, y + высота - радиус);
			ctx.quadraticCurveTo(x + ширина, y + высота, x + ширина - радиус, y + высота);
			если (yAlign === 'bottom') {
				this.drawCaret(pt, tooltipSize);
			}
			ctx.lineTo(x + радиус, y + высота);
			ctx.quadraticCurveTo(x, y + высота, x, y + высота - радиус);
			если (yAlign === 'center' && xAlign === 'left') {
				this.drawCaret(pt, tooltipSize);
			}
			ctx.lineTo(x, y + радиус);
			ctx.quadraticCurveTo(x, y, x + радиус, y);
			ctx.closePath();

			ctx.заполнить();

			если (vm.borderWidth > 0) {
				ctx.stroke();
			}
		},
		рисовать: функция() {
			var ctx = this._chart.ctx;
			var vm = this._view;

			если (vm.opacity === 0) {
				возвращаться;
			}

			var tooltipSize = {
				ширина: vm.width,
				высота: vm.высота
			};
			вар пт = {
				х: вм.х,
				г: вм.г
			};

			// IE11/Edge не любит слишком маленькую прозрачность, поэтому привязываемся к 0
			var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;

			// Истинное/ложное значение для пустой подсказки
			var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

			если (this._options.enabled && hasTooltipContent) {
				// Рисуем фон
				this.drawBackground(pt, vm, ctx, tooltipSize, opacity);

				// Нарисовать заголовок, текст и нижний колонтитул
				pt.x += vm.xPadding;
				pt.y += vm.yPadding;

				// Названия
				this.drawTitle(pt, vm, ctx, opacity);

				// Тело
				this.drawBody(pt, vm, ctx, opacity);

				// Нижний колонтитул
				this.drawFooter(pt, vm, ctx, opacity);
			}
		},

		/**
		 * Обработка события
		 * @частный
		 * @param {IEvent} event — событие для обработки
		 * @returns {Boolean} true, если подсказка изменилась
		 */
		handleEvent: функция(e) {
			var me = это;
			var options = me._options;
			переменная изменена = ложь;

			я._последнийАктивный = я._последнийАктивный || [];

			// Найти активные элементы для подсказок
			если (e.type === 'mouseout') {
				я._активный = [];
			} еще {
				me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
			}

			// Запомнить последние действия
			изменено = !helpers.arrayEquals(me._active, me._lastActive);

			// Обрабатывать целевое событие только при изменении подсказки
			если (изменено) {
				я._последнийАктивный = я._активный;

				если (опции.включено || опции.пользовательские) {
					я._событиеПозиция = {
						х: бывш.,
						y: эй
					};

					я.обновление(истина);
					я.pivot();
				}
			}

			возвращение изменено;
		}
	});

	/**
	 * @namespace Chart.Tooltip.positioners
	 */
	Chart.Tooltip.positioners = {
		/**
		 * Режим «Усреднение» помещает подсказку в среднее положение отображаемых элементов.
		 * @function Chart.Tooltip.positioners.average
		 * @param elements {ChartElement[]} элементы, отображаемые во всплывающей подсказке
		 * @returns {Point} позиция подсказки
		 */
		среднее: функция(элементы) {
			если (!elements.length) {
				вернуть ложь;
			}

			вар i, лен;
			вар х = 0;
			переменная у = 0;
			количество переменных = 0;

			для (i = 0, len = элементы.длина; i < len; ++i) {
				var el = элементы[i];
				если (el && el. имеетЗначение()) {
					var pos = el.tooltipPosition();
					х += полож.х;
					у += полож.у;
					++количество;
				}
			}

			возвращаться {
				x: Матем.округление(x / количество),
				y: Матем.округление(y / количество)
			};
		},

		/**
		 * Получает позицию подсказки, ближайшую к элементу, ближайшему к позиции события
		 * @function Chart.Tooltip.positioners.nearest
		 * @param elements {Chart.Element[]} элементы подсказки
		 * @param eventPosition {Point} положение события в координатах холста
		 * @returns {Point} — положение подсказки
		 */
		ближайший: функция(элементы, eventPosition) {
			var x = eventPosition.x;
			var y = eventPosition.y;
			var minDistance = Число.ПОЛОЖИТЕЛЬНАЯ_БЕСКОНЕЧНОСТЬ;
			var i, len, ближайшийЭлемент;

			для (i = 0, len = элементы.длина; i < len; ++i) {
				var el = элементы[i];
				если (el && el. имеетЗначение()) {
					вар центр = el.getCenterPoint();
					var d = helpers.distanceBetweenPoints(eventPosition, center);

					если (d < minDistance) {
						минРасстояние = d;
						ближайшийЭлемент = el;
					}
				}
			}

			если (ближайшийЭлемент) {
				var tp = nearestElement.tooltipPosition();
				х = тп.х;
				у = tп.у;
			}

			возвращаться {
				х: х,
				у: у
			};
		}
	};
};

},{"25":25,"26":26,"45":45}],36:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
Элемент var = require(26);
var helpers = require(45);

defaults._set('глобальный', {
	элементы: {
		дуга: {
			Цвет фона: defaults.global.defaultColor,
			Цвет границы: '#fff',
			Ширина границы: 2
		}
	}
});

module.exports = Элемент.extend({
	inLabelRange: функция(mouseX) {
		var vm = this._view;

		если (вм) {
			вернуть (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));
		}
		вернуть ложь;
	},

	inRange: функция(chartX, chartY) {
		var vm = this._view;

		если (вм) {
			var pointRelativePosition = helpers.getAngleFromPoint(vm, {x: chartX, y: chartY});
			вар угол = pointRelativePosition.angle;
			вар расстояние = pointRelativePosition.distance;

			// Очистить диапазон углов
			вар startAngle = vm.startAngle;
			var endAngle = vm.endAngle;
			в то время как (конечныйУгол < начальныйУгол) {
				конечныйУгол += 2.0 * Матем.ПИ;
			}
			в то время как (угол > конецУгла) {
				угол -= 2.0 * Матем.ПИ;
			}
			в то время как (угол < начальныйУгол) {
				угол += 2.0 * Матем.ПИ;
			}

			// Проверьте, находится ли в пределах диапазона угла открытия/закрытия
			var BetweenAngles = (угол >= startAngle && угол <= endAngle);
			var withinRadius = (расстояние >= vm.innerRadius && расстояние <= vm.outerRadius);

			возврат (betweenAngles && withinRadius);
		}
		вернуть ложь;
	},

	получитьCenterPoint: функция() {
		var vm = this._view;
		вар halfAngle = (vm.startAngle + vm.endAngle)/2;
		var halfRadius = (vm.innerRadius + vm.outerRadius)/2;
		возвращаться {
			x: vm.x + Math.cos(полуугол) * полурадиус,
			y: vm.y + Math.sin(halfAngle) * halfRadius
		};
	},

	getArea: функция() {
		var vm = this._view;
		вернуть Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
	},

	подсказкаPosition: function() {
		var vm = this._view;
		var centerAngle = vm.startAngle + ((vm.endAngle - vm.startAngle)/2);
		var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;

		возвращаться {
			x: vm.x + (Math.cos(центрУгол) * диапазонОтЦентра),
			y: vm.y + (Math.sin(центрУгол) * диапазонОтЦентра)
		};
	},

	рисовать: функция() {
		var ctx = this._chart.ctx;
		var vm = this._view;
		var sA = vm.startAngle;
		var eA = vm.endAngle;

		ctx.beginPath();

		ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
		ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

		ctx.closePath();
		ctx.strokeStyle = vm.borderColor;
		ctx.lineWidth = vm.borderWidth;

		ctx.fillStyle = vm.backgroundColor;

		ctx.заполнить();
		ctx.lineJoin = 'скос';

		если (vm.borderWidth) {
			ctx.stroke();
		}
	}
});

},{"25":25,"26":26,"45":45}],37:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
Элемент var = require(26);
var helpers = require(45);

var globalDefaults = defaults.global;

defaults._set('глобальный', {
	элементы: {
		линия: {
			натяжение: 0,4,
			Цвет фона: globalDefaults.defaultColor,
			Ширина границы: 3,
			borderColor: globalDefaults.defaultColor,
			borderCapStyle: 'butt',
			borderDash: [],
			borderDashOffset: 0.0,
			borderJoinStyle: 'митра',
			capBezierPoints: правда,
			fill: true, // заполняем ли мы область между линией и ее базовой осью
		}
	}
});

module.exports = Элемент.extend({
	рисовать: функция() {
		var me = это;
		var vm = me._view;
		var ctx = me._chart.ctx;
		var spanGaps = vm.spanGaps;
		var points = me._children.slice(); // клонировать массив
		var globalOptionLineElements = globalDefaults.elements.line;
		var lastDrawnIndex = -1;
		var index, текущий, предыдущий, текущийVM;

		// Если мы циклим, добавляем первую точку снова
		если (me._loop && points.length) {
			точки.push(точки[0]);
		}

		ctx.сохранить();

		// Параметры линии обводки
		ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;

		// IE 9 и 10 не поддерживают штриховую линию
		если (ctx.setLineDash) {
			ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
		}

		ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
		ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
		ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
		ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;

		// Линия обводки
		ctx.beginPath();
		lastDrawnIndex = -1;

		для (индекс = 0; индекс < точек.длина; ++индекс) {
			текущий = баллы[индекс];
			предыдущий = помощники.предыдущийЭлемент(точки, индекс);
			currentVM = текущий._view;

			// Первая точка перемещается в начальную позицию независимо ни от чего
			если (индекс === 0) {
				если (!currentVM.skip) {
					ctx.moveTo(текущая_VM.x, текущая_VM.y);
					lastDrawnIndex = индекс;
				}
			} еще {
				предыдущий = lastDrawnIndex === -1 ? предыдущий : points[lastDrawnIndex];

				если (!currentVM.skip) {
					if ((lastDrawnIndex !== (index - 1) && !spanGaps) || LastDrawnIndex === -1) {
						// Был пробел, и это первая точка после пробела
						ctx.moveTo(текущая_VM.x, текущая_VM.y);
					} еще {
						// Линия к следующей точке
						helpers.canvas.lineTo(ctx, previous._view, current._view);
					}
					lastDrawnIndex = индекс;
				}
			}
		}

		ctx.stroke();
		ctx.восстановить();
	}
});

},{"25":25,"26":26,"45":45}],38:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
Элемент var = require(26);
var helpers = require(45);

var defaultColor = defaults.global.defaultColor;

defaults._set('глобальный', {
	элементы: {
		точка: {
			радиус: 3,
			pointStyle: 'круг',
			Цвет фона: цвет по умолчанию,
			borderColor: цвет по умолчанию,
			Ширина границы: 1,
			// Наведите курсор
			Радиус попадания: 1,
			hoverRadius: 4,
			hoverBorderWidth: 1
		}
	}
});

функция xRange(mouseX) {
	var vm = this._view;
	вернуть vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;
}

функция yRange(mouseY) {
	var vm = this._view;
	вернуть vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;
}

module.exports = Элемент.extend({
	inRange: функция(mouseX, mouseY) {
		var vm = this._view;
		вернуть vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;
	},

	inLabelRange: xRange,
	inXRange: xRange,
	inYRange: yRange,

	получитьCenterPoint: функция() {
		var vm = this._view;
		возвращаться {
			х: вм.х,
			г: вм.г
		};
	},

	getArea: функция() {
		вернуть Math.PI * Math.pow(this._view.radius, 2);
	},

	подсказкаPosition: function() {
		var vm = this._view;
		возвращаться {
			х: вм.х,
			у: вм.у,
			отступ: vm.radius + vm.borderWidth
		};
	},

	рисовать: функция(chartArea) {
		var vm = this._view;
		var model = эта._модель;
		var ctx = this._chart.ctx;
		вар pointStyle = vm.pointStyle;
		радиус переменной = vm.радиус;
		вар х = вм.х;
		вар у = вм.у;
		var color = helpers.цвет;
		var errMargin = 1.01; // 1.01 — это запас для накопленной ошибки. (Особенно Edge, IE.)
		отношение переменных = 0;

		если (vm.skip) {
			возвращаться;
		}

		ctx.strokeStyle = vm.borderColor || defaultColor;
		ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
		ctx.fillStyle = vm.backgroundColor || defaultColor;

		// Клиппинг для очков.
		// выход из внутренней charArea?
		если ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right * errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom * errMargin < model.y))) {
			// Точка постепенно исчезает
			если (модель.x < chartArea.left) {
				отношение = (x - модель.x) / (chartArea.left - модель.x);
			} иначе если (chartArea.right * errMargin < model.x) {
				отношение = (модель.x - x) / (модель.x - chartArea.right);
			} иначе если (модель.y < chartArea.top) {
				соотношение = (y - model.y) / (chartArea.top - model.y);
			} иначе если (chartArea.bottom * errMargin < model.y) {
				соотношение = (модель.y - y) / (модель.y - область диаграммы.дно);
			}
			отношение = Матем.округление(отношение * 100) / 100;
			ctx.strokeStyle = цвет(ctx.strokeStyle).альфа(соотношение).rgbString();
			ctx.fillStyle = цвет(ctx.fillStyle).альфа(соотношение).rgbString();
		}

		helpers.canvas.drawPoint(ctx, pointStyle, радиус, x, y);
	}
});

},{"25":25,"26":26,"45":45}],39:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
Элемент var = require(26);

defaults._set('глобальный', {
	элементы: {
		прямоугольник: {
			Цвет фона: defaults.global.defaultColor,
			borderColor: defaults.global.defaultColor,
			borderSkipped: 'снизу',
			Ширина границы: 0
		}
	}
});

функция isVertical(bar) {
	вернуть bar._view.width !== не определено;
}

/**
 * Вспомогательная функция для получения границ панели независимо от ориентации
 * @param bar {Chart.Element.Rectangle} панель
 * @return {Bounds} границы панели
 * @частный
 */
функция getBarBounds(bar) {
	var vm = bar._view;
	переменная x1, x2, y1, y2;

	если (isVertical(bar)) {
		// вертикальный
		var halfWidth = vm.width / 2;
		x1 = vm.x - половина ширины;
		x2 = vm.x + половина ширины;
		y1 = Math.min(vm.y, vm.base);
		y2 = Math.max(vm.y, vm.base);
	} еще {
		// горизонтальная полоса
		var halfHeight = vm.height / 2;
		x1 = Math.min(vm.x, vm.base);
		x2 = Math.max(vm.x, vm.base);
		y1 = vm.y - половинаВысоты;
		y2 = vm.y + halfHeight;
	}

	возвращаться {
		слева: x1,
		вверху: y1,
		справа: x2,
		внизу: y2
	};
}

module.exports = Элемент.extend({
	рисовать: функция() {
		var ctx = this._chart.ctx;
		var vm = this._view;
		var слева, справа, сверху, снизу, signX, signY, borderSkipped;
		вар borderWidth = vm.borderWidth;

		если (!vm.горизонтальный) {
			// бар
			левое = vm.x - vm.width / 2;
			справа = vm.x + vm.width / 2;
			верх = вм.y;
			низ = vm.base;
			знакX = 1;
			знакY = низ > верх ? 1 : -1;
			borderSkipped = vm.borderSkipped || 'bottom';
		} еще {
			// горизонтальная полоса
			левое = vm.base;
			справа = vm.x;
			верх = vm.y - vm.высота / 2;
			низ = vm.y + vm.высота / 2;
			signX = справа > слева ? 1 : -1;
			знак Y = 1;
			borderSkipped = vm.borderSkipped || 'левый';
		}

		// Холст не позволяет нам обводить внутри ширины, поэтому мы можем
		// отрегулируйте размеры, чтобы они соответствовали, если мы устанавливаем обводку на линии
		если (ширина границы) {
			// borderWidth должен быть меньше ширины и высоты полосы.
			var barSize = Math.min(Math.abs(слева - справа), Math.abs(сверху - снизу));
			borderWidth = borderWidth > barSize ? barSize : borderWidth;
			вар halfStroke = borderWidth / 2;
			// Отрегулируйте borderWidth, когда положение верхней части панели близко к vm.base(ноль).
			var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);
			var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);
			var borderTop = top + (borderSkipped !== 'top' ? HalfStroke * SignY : 0);
			var borderBottom = дно + (borderSkipped !== 'дно' ? -halfStroke * SignY : 0);
			// не станет вертикальной линией?
			если (borderLeft !== borderRight) {
				верх = borderTop;
				нижняя часть = borderBottom;
			}
			// не станет горизонтальной линией?
			если (borderTop !== borderBottom) {
				слева = borderLeft;
				справа = borderRight;
			}
		}

		ctx.beginPath();
		ctx.fillStyle = vm.backgroundColor;
		ctx.strokeStyle = vm.borderColor;
		ctx.lineWidth = borderWidth;

		// Угловые точки, снизу слева направо по часовой стрелке
		// | 1 2 |
		// | 0 3 |
		вар углы = [
			[слева, внизу],
			[слева, вверху],
			[справа, вверху],
			[справа, внизу]
		];

		// Найти первый (начальный) угол с откатом на «низ»
		var border = ['низ', 'левый', 'верх', 'правый'];
		вар startCorner = borders.indexOf(borderSkipped, 0);
		если (начальныйУгол === -1) {
			начальный_угол = 0;
		}

		функция cornerAt(индекс) {
			вернуть углы[(startCorner + index) % 4];
		}

		// Рисуем прямоугольник от 'startCorner'
		var corner = cornerAt(0);
		ctx.moveTo(угол[0], угол[1]);

		для (var i = 1; i < 4; i++) {
			угол = уголAt(i);
			ctx.lineTo(угол[0], угол[1]);
		}

		ctx.заполнить();
		если (ширина границы) {
			ctx.stroke();
		}
	},

	высота: функция() {
		var vm = this._view;
		вернуть vm.base - vm.y;
	},

	inRange: функция(mouseX, mouseY) {
		var inRange = false;

		если (этот._вид) {
			var bounds = getBarBounds(this);
			inRange = mouseX >= границы.left && mouseX <= границы.right && mouseY >= границы.top && mouseY <= границы.bottom;
		}

		возврат вдиапазон;
	},

	inLabelRange: функция(mouseX, mouseY) {
		var me = это;
		если (!me._view) {
			вернуть ложь;
		}

		var inRange = false;
		var bounds = getBarBounds(me);

		если (isVertical(я)) {
			inRange = mouseX >= границы.left && mouseX <= границы.right;
		} еще {
			inRange = mouseY >= границы.верх && mouseY <= границы.низ;
		}

		возврат вдиапазон;
	},

	inXRange: функция(mouseX) {
		var bounds = getBarBounds(this);
		вернуть mouseX >= bounds.left && mouseX <= bounds.right;
	},

	inYRange: функция(mouseY) {
		var bounds = getBarBounds(this);
		вернуть mouseY >= границы.верх && mouseY <= границы.низ;
	},

	получитьCenterPoint: функция() {
		var vm = this._view;
		переменная x, y;
		если (isVertical(это)) {
			х = вм.х;
			y = (vm.y + vm.base) / 2;
		} еще {
			x = (vm.x + vm.base) / 2;
			у = вм.у;
		}

		вернуть {x: x, y: y};
	},

	getArea: функция() {
		var vm = this._view;
		вернуть vm.width * Math.abs(vm.y - vm.base);
	},

	подсказкаPosition: function() {
		var vm = this._view;
		возвращаться {
			х: вм.х,
			г: вм.г
		};
	}
});

},{"25":25,"26":26}],40:[function(require,module,exports){
«использовать строго»;

модуль.экспорт = {};
модуль.экспорты.Arc = require(36);
module.exports.Line = require(37);
module.exports.Point = require(38);
module.exports.Rectangle = require(39);

},{"36":36,"37":37,"38":38,"39":39}],41:[function(require,module,exports){
«использовать строго»;

var helpers = require(42);

/**
 * @namespace Chart.helpers.canvas
 */
вар экспорт = модуль.экспорт = {
	/**
	 * Очищает весь холст, связанный с заданной `chart`.
	 * @param {Chart} chart — диаграмма, для которой необходимо очистить холст.
	 */
	очистить: функция(диаграмма) {
		chart.ctx.clearRect(0, 0, ширина.диаграммы, высота.диаграммы);
	},

	/**
	 * Создает «путь» для прямоугольника со скругленными углами в позиции (x, y) с
	 * заданный размер (ширина, высота) и одинаковый `радиус` для всех углов.
	 * @param {CanvasRenderingContext2D} ctx — 2D-контекст холста.
	 * @param {Number} x — ось x координат начальной точки прямоугольника.
	 * @param {Number} y — ось Y координат начальной точки прямоугольника.
	 * @param {Number} width — ширина прямоугольника.
	 * @param {Number} height — высота прямоугольника.
	 * @param {Number} radius — округленная величина (в пикселях) для четырех углов.
	 * @todo обрабатывает `radius` как верхний левый, верхний правый, нижний правый, нижний левый массив/объект?
	 */
	roundedRect: функция(ctx, x, y, ширина, высота, радиус) {
		если (радиус) {
			var rx = Math.min(радиус, ширина / 2);
			var ry = Math.min(радиус, высота / 2);

			ctx.moveTo(x + rx, y);
			ctx.lineTo(x + width - rx, y);
			ctx.quadraticCurveTo(x + ширина, y, x + ширина, y + ry);
			ctx.lineTo(x + ширина, y + высота - ry);
			ctx.quadraticCurveTo(x + ширина, y + высота, x + ширина - rx, y + высота);
			ctx.lineTo(x + rx, y + высота);
			ctx.quadraticCurveTo(x, y + высота, x, y + высота - ry);
			ctx.lineTo(x, y + ry);
			ctx.quadraticCurveTo(x, y, x + rx, y);
		} еще {
			ctx.rect(x, y, ширина, высота);
		}
	},

	drawPoint: функция(ctx, стиль, радиус, x, y) {
		тип переменной, длина_края, смещение_по_оси, смещение_по_оси, высота, размер;

		если (стиль && тип стиля === 'объект') {
			тип = стиль.toString();
			если (тип === '[объект HTMLImageElement]' || тип === '[объект HTMLCanvasElement]') {
				ctx.drawImage(стиль, x - стиль.ширина / 2, y - стиль.высота / 2, стиль.ширина, стиль.высота);
				возвращаться;
			}
		}

		if (isNaN(радиус) || радиус <= 0) {
			возвращаться;
		}

		переключатель (стиль) {
		// По умолчанию включает круг
		по умолчанию:
			ctx.beginPath();
			ctx.arc(x, y, радиус, 0, Матем.PI * 2);
			ctx.closePath();
			ctx.заполнить();
			перерыв;
		случай «треугольник»:
			ctx.beginPath();
			edgeLength = 3 * радиус / Math.sqrt(3);
			высота = длина_ребра * Математика. квадратный_корень(3) ​​/ 2;
			ctx.moveTo(x - длина_ребра / 2, y + высота / 3);
			ctx.lineTo(x + edgeLength / 2, y + height / 3);
			ctx.lineTo(x, y - 2 * высота / 3);
			ctx.closePath();
			ctx.заполнить();
			перерыв;
		случай «прямой»:
			размер = 1 / Матем.КОРЕНЬ2 * радиус;
			ctx.beginPath();
			ctx.fillRect(x - размер, y - размер, 2 * размер, 2 * размер);
			ctx.strokeRect(x - размер, y - размер, 2 * размер, 2 * размер);
			перерыв;
		случай 'rectRounded':
			var offset = радиус / Math.SQRT2;
			var leftX = x - смещение;
			var topY = y - смещение;
			вар SideSize = Math.SQRT2 * радиус;
			ctx.beginPath();
			this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);
			ctx.closePath();
			ctx.заполнить();
			перерыв;
		случай 'rectRot':
			размер = 1 / Матем.КОРЕНЬ2 * радиус;
			ctx.beginPath();
			ctx.moveTo(x - размер, y);
			ctx.lineTo(x, y + размер);
			ctx.lineTo(x + размер, y);
			ctx.lineTo(x, y - размер);
			ctx.closePath();
			ctx.заполнить();
			перерыв;
		случай «крест»:
			ctx.beginPath();
			ctx.moveTo(x, y + радиус);
			ctx.lineTo(x, y - радиус);
			ctx.moveTo(x - радиус, y);
			ctx.lineTo(x + радиус, y);
			ctx.closePath();
			перерыв;
		случай «crossRot»:
			ctx.beginPath();
			xOffset = Math.cos(Math.PI / 4) * радиус;
			yOffset = Math.sin(Math.PI / 4) * радиус;
			ctx.moveTo(x - xOffset, y - yOffset);
			ctx.lineTo(x + xOffset, y + yOffset);
			ctx.moveTo(x - xOffset, y + yOffset);
			ctx.lineTo(x + xOffset, y - yOffset);
			ctx.closePath();
			перерыв;
		случай «звезда»:
			ctx.beginPath();
			ctx.moveTo(x, y + радиус);
			ctx.lineTo(x, y - радиус);
			ctx.moveTo(x - радиус, y);
			ctx.lineTo(x + радиус, y);
			xOffset = Math.cos(Math.PI / 4) * радиус;
			yOffset = Math.sin(Math.PI / 4) * радиус;
			ctx.moveTo(x - xOffset, y - yOffset);
			ctx.lineTo(x + xOffset, y + yOffset);
			ctx.moveTo(x - xOffset, y + yOffset);
			ctx.lineTo(x + xOffset, y - yOffset);
			ctx.closePath();
			перерыв;
		случай «линия»:
			ctx.beginPath();
			ctx.moveTo(x - радиус, y);
			ctx.lineTo(x + радиус, y);
			ctx.closePath();
			перерыв;
		случай «тире»:
			ctx.beginPath();
			ctx.moveTo(x, y);
			ctx.lineTo(x + радиус, y);
			ctx.closePath();
			перерыв;
		}

		ctx.stroke();
	},

	clipArea: функция(ctx, area) {
		ctx.сохранить();
		ctx.beginPath();
		ctx.rect(область.левая, область.верхняя, область.правая - область.левая, область.нижняя - область.верхняя);
		ctx.clip();
	},

	unclipArea: функция(ctx) {
		ctx.восстановить();
	},

	lineTo: функция (ctx, предыдущий, цель, перевернуть) {
		если (целевая.steppedLine) {
			если ((target.steppedLine === 'после' && !перевернуть) || (target.steppedLine !== 'после' && перевернуть)) {
				ctx.lineTo(предыдущий.x, цель.y);
			} еще {
				ctx.lineTo(цель.x, предыдущая.y);
			}
			ctx.lineTo(цель.x, цель.y);
			возвращаться;
		}

		если (!целевое.напряжение) {
			ctx.lineTo(цель.x, цель.y);
			возвращаться;
		}

		ctx.bezierCurveTo(
			перевернуть ? предыдущая.controlPointPreviousX : предыдущая.controlPointNextX,
			перевернуть ? предыдущая.controlPointPreviousY : предыдущая.controlPointNextY,
			перевернуть ? target.controlPointNextX : target.controlPointPreviousX,
			перевернуть ? target.controlPointNextY : target.controlPointPreviousY,
			цель.x,
			цель.y);
	}
};

// УСТАРЕНИЕ

/**
 * Предоставлено для обратной совместимости, вместо этого используйте Chart.helpers.canvas.clear.
 * @namespace Chart.helpers.clear
 * @deprecated с версии 2.7.0
 * @todo удалено в версии 3
 * @частный
 */
helpers.clear = exports.clear;

/**
 * Предоставлено для обратной совместимости, вместо этого используйте Chart.helpers.canvas.roundedRect.
 * @namespace Chart.helpers.drawRoundedRectangle
 * @deprecated с версии 2.7.0
 * @todo удалено в версии 3
 * @частный
 */
helpers.drawRoundedRectangle = функция(ctx) {
	ctx.beginPath();
	exports.roundedRect.apply(экспорт, аргументы);
	ctx.closePath();
};

},{"42":42}],42:[function(require,module,exports){
«использовать строго»;

/**
 * @namespace Chart.helpers
 */
var помощники = {
	/**
	 * Пустая функция, которую можно использовать, например, для необязательного обратного вызова.
	 */
	нуп: функция() {},

	/**
	 * Возвращает уникальный идентификатор, последовательно сгенерированный из глобальной переменной.
	 * @returns {Число}
	 * @функция
	 */
	uid: (функция() {
		идентификатор переменной = 0;
		функция возврата() {
			вернуть идентификатор++;
		};
	}()),

	/**
	 * Возвращает true, если `value` не равно null или undefined, в противном случае возвращает false.
	 * @param {*} value — значение для проверки.
	 * @returns {Булево значение}
	 * @с версии 2.7.0
	 */
	isNullOrUndef: функция(значение) {
		возвращаемое значение === null || тип значения === 'undefined';
	},

	/**
	 * Возвращает true, если `value` является массивом, в противном случае возвращает false.
	 * @param {*} value — значение для проверки.
	 * @returns {Булево значение}
	 * @функция
	 */
	isArray: Array.isArray ? Array.isArray : функция(значение) {
		return Object.prototype.toString.call(value) === '[объект Массив]';
	},

	/**
	 * Возвращает true, если `value` является объектом (исключая null), в противном случае возвращает false.
	 * @param {*} value — значение для проверки.
	 * @returns {Булево значение}
	 * @с версии 2.7.0
	 */
	isObject: функция(значение) {
		возвращаемое значение !== null && Object.prototype.toString.call(value) === '[object Object]';
	},

	/**
	 * Возвращает `value`, если определено, в противном случае возвращает `defaultValue`.
	 * @param {*} value — возвращаемое значение, если оно определено.
	 * @param {*} defaultValue — возвращаемое значение, если `value` не определено.
	 * @возвращает {*}
	 */
	значениеИлиПоУмолчанию: функция(значение, ЗначениеПоУмолчанию) {
		возвращаемый тип значения === 'undefined' ? defaultValue : value;
	},

	/**
	 * Возвращает значение по указанному индексу `index` в массиве, если он определен, в противном случае возвращает `defaultValue`.
	 * @param {Array} value - Массив для поиска значения по индексу `index`.
	 * @param {Number} index — индекс в `value` для поиска значения.
	 * @param {*} defaultValue — возвращаемое значение, если `value[index]` не определено.
	 * @возвращает {*}
	 */
	значениеВИндексеИлиПоУмолчанию: функция(значение, индекс, ЗначениеПоУмолчанию) {
		return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
	},

	/**
	 * Вызывает `fn` с заданными `args` в области, определенной `thisArg`, и возвращает
	 * значение, возвращаемое `fn`. Если `fn` не является функцией, этот метод возвращает undefined.
	 * @param {Function} fn — Функция для вызова.
	 * @param {Array|undefined|null} args — Аргументы, с которыми следует вызывать `fn`.
	 * @param {Object} [thisArg] — значение `this`, предоставленное для вызова `fn`.
	 * @возвращает {*}
	 */
	обратный вызов: функция(fn, args, thisArg) {
		если (fn && typeof fn.call === 'function') {
			вернуть fn.apply(thisArg, args);
		}
	},

	/**
	 * Примечание (SB) для повышения производительности этот метод следует использовать только в случае цикличного типа
	 * неизвестно или находится в неинтенсивном коде (не вызывается часто и мало зацикливается). В противном случае
	 * предпочтительнее использовать обычный цикл for() и сэкономить лишние вызовы функций.
	 * @param {Object|Array} loopable — объект или массив для итерации.
	 * @param {Function} fn — Функция, вызываемая для каждого элемента.
	 * @param {Object} [thisArg] — значение `this`, предоставленное для вызова `fn`.
	 * @param {Boolean} [reverse] — если true, выполняет итерацию в обратном направлении по циклу.
	 */
	каждый: функция (loopable, fn, thisArg, reverse) {
		var i, len, ключи;
		если (helpers.isArray(loopable)) {
			len = зацикливаемая.длина;
			если (обратный) {
				для (i = len - 1; i >= 0; i--) {
					fn.call(thisArg, loopable[i], i);
				}
			} еще {
				для (i = 0; i < len; i++) {
					fn.call(thisArg, loopable[i], i);
				}
			}
		} иначе если (helpers.isObject(loopable)) {
			ключи = Объект.ключи(циклический);
			len = ключи.длина;
			для (i = 0; i < len; i++) {
				fn.call(thisArg, loopable[keys[i]], keys[i]);
			}
		}
	},

	/**
	 * Возвращает true, если массивы `a0` и `a1` имеют одинаковое содержимое, в противном случае возвращает false.
	 * @см. http://stackoverflow.com/a/14853974
	 * @param {Array} a0 — Массив для сравнения
	 * @param {Array} a1 — Массив для сравнения
	 * @returns {Булево значение}
	 */
	arrayEquals: функция(a0, a1) {
		вар i, ilen, v0, v1;

		если (!a0 || !a1 || a0.длина !== a1.длина) {
			вернуть ложь;
		}

		для (i = 0, ilen = a0.length; i < ilen; ++i) {
			v0 = a0[i];
			v1 = a1[i];

			если (v0 экземпляр массива && v1 экземпляр массива) {
				если (!helpers.arrayEquals(v0, v1)) {
					вернуть ложь;
				}
			} иначе если (v0 !== v1) {
				// ПРИМЕЧАНИЕ: два разных экземпляра объекта никогда не будут равны: {x:20} != {x:20}
				вернуть ложь;
			}
		}

		вернуть истину;
	},

	/**
	 * Возвращает полную копию `source` без сохранения ссылок на объекты и массивы.
	 * @param {*} source — значение для клонирования.
	 * @возвращает {*}
	 */
	клон: функция(источник) {
		если (helpers.isArray(источник)) {
			возврат источника.карта(помощники.клон);
		}

		если (helpers.isObject(источник)) {
			var target = {};
			var keys = Object.keys(источник);
			var klen = ключи.длина;
			вар к = 0;

			для (; к < клен; ++к) {
				цель[ключи[k]] = помощники.клон(источник[ключи[k]]);
			}

			возврат цели;
		}

		обратный источник;
	},

	/**
	 * Объединение по умолчанию при вызове Chart.helpers.merge без опции объединения.
	 * Примечание(SB): этот метод также используется configMerge и scaleMerge в качестве запасного варианта.
	 * @частный
	 */
	_merger: функция(ключ, цель, источник, параметры) {
		var tval = цель[ключ];
		var sval = источник[ключ];

		если (помощники.isObject(tval) && помощники.isObject(sval)) {
			helpers.merge(tval, sval, options);
		} еще {
			цель[ключ] = помощники.клон(sval);
		}
	},

	/**
	 * Объединяет source[key] с target[key], только если target[key] не определен.
	 * @частный
	 */
	_mergerIf: функция(ключ, цель, источник) {
		var tval = цель[ключ];
		var sval = источник[ключ];

		если (помощники.isObject(tval) && помощники.isObject(sval)) {
			helpers.mergeIf(tval, sval);
		} иначе если (!target.hasOwnProperty(ключ)) {
			цель[ключ] = помощники.клон(sval);
		}
	},

	/**
	 * Рекурсивно глубоко копирует свойства `source` в `target` с заданными `options`.
	 * ВАЖНО: `target` не клонируется и будет обновлен с использованием свойств `source`.
	 * @param {Object} target — целевой объект, в который объединяются все источники.
	 * @param {Object|Array(Object)} source - Объект(ы) для объединения в `target`.
	 * @param {Object} [options] - Объединение параметров:
	 * @param {Function} [options.merger] — Метод слияния (ключ, цель, источник, параметры)
	 * @returns {Object} Целевой объект.
	 */
	слияние: функция(цель, источник, параметры) {
		var sources = helpers.isArray(источник) ? источник : [источник];
		var ilen = источники.длина;
		var merge, i, ключи, klen, k;

		если (!helpers.isObject(цель)) {
			возврат цели;
		}

		параметры = параметры || {};
		merge = options.merger || помощники._merger;

		для (i = 0; i < ilen; ++i) {
			источник = источники[i];
			если (!helpers.isObject(источник)) {
				продолжать;
			}

			ключи = Объект.ключи(источник);
			для (k = 0, klen = ключи.длина; k < klen; ++k) {
				merge(ключи[k], цель, источник, параметры);
			}
		}

		возврат цели;
	},

	/**
	 * Рекурсивно глубоко копирует свойства `source` в `target` *только* если они не определены в target.
	 * ВАЖНО: `target` не клонируется и будет обновлен с использованием свойств `source`.
	 * @param {Object} target — целевой объект, в который объединяются все источники.
	 * @param {Object|Array(Object)} source - Объект(ы) для объединения в `target`.
	 * @returns {Object} Целевой объект.
	 */
	mergeIf: функция(цель, источник) {
		вернуть помощников.merge(цель, источник, {слияние: помощники._mergerIf});
	},

	/**
	 * Применяет содержимое двух или более объектов одновременно к первому объекту.
	 * @param {Object} target — целевой объект, в который объединяются все объекты.
	 * @param {Object} arg1 — объект, содержащий дополнительные свойства для объединения в цель.
	 * @param {Object} argN — Дополнительные объекты, содержащие свойства для объединения в цель.
	 * @returns {Object} Целевой объект.
	 */
	расширить: функция(цель) {
		var setFn = функция(значение, ключ) {
			цель[ключ] = значение;
		};
		for (var i = 1, ilen = аргументы.длина; i < ilen; ++i) {
			helpers.each(аргументы[i], setFn);
		}
		возврат цели;
	},

	/**
	 * Базовое наследование JavaScript на основе модели, созданной в Backbone.js
	 */
	наследует: функция(расширения) {
		var me = это;
		var ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {
			вернуть меня. применить(это, аргументы);
		};

		var Суррогат = функция() {
			этот.конструктор = ChartElement;
		};

		Суррогат.прототип = я.прототип;
		ChartElement.prototype = new Surrogate();
		ChartElement.extend = helpers.inherits;

		если (расширения) {
			helpers.extend(ChartElement.prototype, extensions);
		}

		ChartElement.__super__ = я.прототип;
		вернуть ChartElement;
	}
};

module.exports = помощники;

// УСТАРЕНИЕ

/**
 * Предоставлено для обратной совместимости, вместо этого используйте Chart.helpers.callback.
 * @function Chart.helpers.callCallback
 * @deprecated с версии 2.6.0
 * @todo удалено в версии 3
 * @частный
 */
helpers.callCallback = helpers.callback;

/**
 * Предоставлено для обратной совместимости, вместо этого используйте Array.prototype.indexOf.
 * Array.prototype.indexOf совместимость: Chrome, Opera, Safari, FF1.5+, IE9+
 * @function Chart.helpers.indexOf
 * @deprecated с версии 2.7.0
 * @todo удалено в версии 3
 * @частный
 */
helpers.indexOf = функция(массив, элемент, fromIndex) {
	вернуть Array.prototype.indexOf.call(array, item, fromIndex);
};

/**
 * Предоставлено для обратной совместимости, вместо этого используйте Chart.helpers.valueOrDefault.
 * @function Chart.helpers.getValueOrDefault
 * @deprecated с версии 2.7.0
 * @todo удалено в версии 3
 * @частный
 */
helpers.getValueOrDefault = helpers.valueOrDefault;

/**
 * Предоставлено для обратной совместимости, вместо этого используйте Chart.helpers.valueAtIndexOrDefault.
 * @function Chart.helpers.getValueAtIndexOrDefault
 * @deprecated с версии 2.7.0
 * @todo удалено в версии 3
 * @частный
 */
helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

},{}],43:[function(require,module,exports){
«использовать строго»;

var helpers = require(42);

/**
 * Функции замедления адаптированы из уравнений замедления Роберта Пеннера.
 * @namespace Chart.helpers.easingEffects
 * @см. http://www.robertpenner.com/easing/
 */
эффекты переменной = {
	линейная: функция(t) {
		вернуть т;
	},

	easeInQuad: функция(t) {
		вернуть т * т;
	},

	easeOutQuad: функция(t) {
		вернуть -t * (t - 2);
	},

	easeInOutQuad: функция(t) {
		если ((t /= 0,5) < 1) {
			возврат 0,5 * т * т;
		}
		возврат -0,5 * ((--t) * (t - 2) - 1);
	},

	easeInCubic: функция(t) {
		вернуть т * т * т;
	},

	easeOutCubic: функция(t) {
		возврат (t = t - 1) * t * t + 1;
	},

	easeInOutCubic: функция(t) {
		если ((t /= 0,5) < 1) {
			возврат 0,5 * т * т * т;
		}
		вернуть 0,5 * ((t -= 2) * t * t + 2);
	},

	easeInQuart: функция(t) {
		вернуть т * т * т * т;
	},

	easeOutQuart: функция(t) {
		вернуть -((t = t - 1) * t * t * t - 1);
	},

	easeInOutQuart: функция(t) {
		если ((t /= 0,5) < 1) {
			возврат 0,5 * т * т * т * т;
		}
		вернуть -0,5 * ((t -= 2) * t * t * t - 2);
	},

	easeInQuint: функция(t) {
		вернуть т * т * т * т * т;
	},

	easeOutQuint: функция(t) {
		возврат (t = t - 1) * t * t * t * t + 1;
	},

	easeInOutQuint: функция(t) {
		если ((t /= 0,5) < 1) {
			возврат 0,5 * т * т * т * т * т;
		}
		вернуть 0,5 * ((t -= 2) * t * t * t * t + 2);
	},

	easeInSine: функция(t) {
		вернуть -Math.cos(t * (Math.PI / 2)) + 1;
	},

	easeOutSine: функция(t) {
		вернуть Math.sin(t * (Math.PI / 2));
	},

	easeInOutSine: функция(t) {
		вернуть -0,5 * (Math.cos(Math.PI * t) - 1);
	},

	easeInExpo: функция(t) {
		вернуть (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));
	},

	easeOutExpo: функция(t) {
		вернуть (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;
	},

	easeInOutExpo: функция(t) {
		если (т === 0) {
			возврат 0;
		}
		если (т === 1) {
			возврат 1;
		}
		если ((t /= 0,5) < 1) {
			вернуть 0,5 * Math.pow(2, 10 * (t - 1));
		}
		вернуть 0.5 * (-Math.pow(2, -10 * --t) + 2);
	},

	easeInCirc: функция(t) {
		если (т >= 1) {
			вернуть т;
		}
		вернуть -(Math.sqrt(1 - t * t) - 1);
	},

	easeOutCirc: функция(t) {
		вернуть Math.sqrt(1 - (t = t - 1) * t);
	},

	easeInOutCirc: функция(t) {
		если ((t /= 0,5) < 1) {
			вернуть -0,5 * (Math.sqrt(1 - t * t) - 1);
		}
		вернуть 0,5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
	},

	easeInElastic: функция(t) {
		вар s = 1,70158;
		вар р = 0;
		вар а = 1;
		если (т === 0) {
			возврат 0;
		}
		если (т === 1) {
			возврат 1;
		}
		если (!п) {
			р = 0,3;
		}
		если (а < 1) {
			а = 1;
			с = п / 4;
		} еще {
			s = p / (2 * Матем.ПИ) * Матем.asin(1 / a);
		}
		вернуть -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
	},

	easeOutElastic: функция(t) {
		вар s = 1,70158;
		вар р = 0;
		вар а = 1;
		если (т === 0) {
			возврат 0;
		}
		если (т === 1) {
			возврат 1;
		}
		если (!п) {
			р = 0,3;
		}
		если (а < 1) {
			а = 1;
			с = п / 4;
		} еще {
			s = p / (2 * Матем.ПИ) * Матем.asin(1 / a);
		}
		вернуть a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
	},

	easeInOutElastic: функция(t) {
		вар s = 1,70158;
		вар р = 0;
		вар а = 1;
		если (т === 0) {
			возврат 0;
		}
		если ((т /= 0,5) === 2) {
			возврат 1;
		}
		если (!п) {
			р = 0,45;
		}
		если (а < 1) {
			а = 1;
			с = п / 4;
		} еще {
			s = p / (2 * Матем.ПИ) * Матем.asin(1 / a);
		}
		если (т < 1) {
			вернуть -0,5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
		}
		вернуть a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
	},
	easeInBack: функция(t) {
		вар s = 1,70158;
		вернуть т * т * ((с + 1) * т - с);
	},

	easeOutBack: функция(t) {
		вар s = 1,70158;
		возврат (t = t - 1) * t * ((s + 1) * t + s) + 1;
	},

	easeInOutBack: функция(t) {
		вар s = 1,70158;
		если ((t /= 0,5) < 1) {
			вернуть 0,5 * (t * t * (((s *= (1,525)) + 1) * t - s));
		}
		вернуть 0,5 * ((t -= 2) * t * (((s *= (1,525)) + 1) * t + s) + 2);
	},

	easeInBounce: функция(t) {
		возврат 1 - эффекты.easeOutBounce(1 - t);
	},

	easeOutBounce: функция(t) {
		если (т < (1 / 2,75)) {
			возврат 7,5625 * т * т;
		}
		если (т < (2 / 2,75)) {
			возврат 7,5625 * (t -= (1,5 / 2,75)) * t + 0,75;
		}
		если (т < (2,5 / 2,75)) {
			возврат 7,5625 * (t -= (2,25 / 2,75)) * t + 0,9375;
		}
		возврат 7,5625 * (t -= (2,625 / 2,75)) * t + 0,984375;
	},

	easeInOutBounce: функция(t) {
		если (т < 0,5) {
			вернуть эффекты.easeInBounce(t * 2) * 0.5;
		}
		вернуть эффекты.easeOutBounce(t * 2 - 1) * 0,5 + 0,5;
	}
};

модуль.экспорты = {
	эффекты: эффекты
};

// УСТАРЕНИЕ

/**
 * Предоставлено для обратной совместимости, вместо этого используйте Chart.helpers.easing.effects.
 * @function Chart.helpers.easingEffects
 * @deprecated с версии 2.7.0
 * @todo удалено в версии 3
 * @частный
 */
helpers.easingEffects = эффекты;

},{"42":42}],44:[function(require,module,exports){
«использовать строго»;

var helpers = require(42);

/**
 * @alias Chart.helpers.options
 * @пространство_имен
 */
модуль.экспорты = {
	/**
	 * Преобразует заданное значение высоты строки в пиксели для определенного размера шрифта.
	 * @param {Number|String} value — lineHeight для анализа (например, 1.6, '14px', '75%', '1.6em').
	 * @param {Number} size — размер шрифта (в пикселях), используемый для определения относительного `value`.
	 * @returns {Number} Эффективная высота строки в пикселях (размер * 1,2, если значение недопустимо).
	 * @см. https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
	 * @с версии 2.7.0
	 */
	toLineHeight: функция(значение, размер) {
		var match = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
		если (!соответствует || соответствует[1] === 'нормально') {
			размер возврата * 1,2;
		}

		значение = +совпадения[2];

		переключатель (совпадения[3]) {
		случай 'px':
			возвращаемое значение;
		случай '%':
			значение /= 100;
			перерыв;
		по умолчанию:
			перерыв;
		}

		возвращаемый размер * значение;
	},

	/**
	 * Преобразует заданное значение в объект отступа с предварительно вычисленной шириной/высотой.
	 * @param {Number|Object} value — если это число, установите значение для всех компонентов TRBL,
	 * иначе, если и объект, используют определенные свойства и устанавливают неопределенные в 0.
	 * @returns {Object} Значения отступов (сверху, справа, снизу, слева, ширина, высота)
	 * @с версии 2.7.0
	 */
	toPadding: функция(значение) {
		вар т, р, б, л;

		если (helpers.isObject(значение)) {
			t = +value.top || 0;
			r = +значение.право || 0;
			b = +значение.нижняя часть || 0;
			l = +значение.left || 0;
		} еще {
			t = r = b = l = +значение || 0;
		}

		возвращаться {
			вверху: т,
			справа: р,
			внизу: б,
			слева: л,
			высота: т + б,
			ширина: д + п
		};
	},

	/**
	 * Последовательно оценивает заданные `входные данные` и возвращает первое определенное значение.
	 * @param {Array[]} inputs — массив значений, возвращающий последнее значение.
	 * @param {Object} [context] — если определено и текущее значение является функцией, то значение
	 * вызывается с `context` в качестве первого аргумента, а результат становится новым входным параметром.
	 * @param {Number} [index] — если определено и текущее значение является массивом, значение
	 * в `index` становится новым входом.
	 * @с версии 2.7.0
	 */
	разрешить: функция(входные данные, контекст, индекс) {
		var i, ilen, значение;

		для (i = 0, ilen = входные данные.длина; i < ilen; ++i) {
			значение = входы[i];
			если (значение === не определено) {
				продолжать;
			}
			если (контекст !== не определено && тип значения === 'функция') {
				значение = значение(контекст);
			}
			если (индекс !== не определено && helpers.isArray(value)) {
				значение = значение[индекс];
			}
			если (значение !== не определено) {
				возвращаемое значение;
			}
		}
	}
};

},{"42":42}],45:[function(require,module,exports){
«использовать строго»;

модуль.экспорты = требуют(42);
module.exports.easing = require(43);
модуль.экспорт.холст = требуется(41);
module.exports.options = требуется(44);

},{"41":41,"42":42,"43":43,"44":44}],46:[function(require,module,exports){
/**
 * Реализация резервной платформы (минимальная).
 * @см. https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
 */

модуль.экспорты = {
	acquireContext: функция(элемент) {
		если (элемент && элемент.холст) {
			// Поддержка любого объекта, связанного с холстом (включая context2d)
			элемент = элемент.холст;
		}

		вернуть элемент && item.getContext('2d') || null;
	}
};

},{}],47:[function(require,module,exports){
/**
 * Реализация Chart.Platform для таргетинга на веб-браузер
 */

«использовать строго»;

var helpers = require(45);

var EXPANDO_KEY = '$chartjs';
var CSS_PREFIX = 'chartjs-';
var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
var CSS_RENDER_ANIMATION = CSS_PREFIX + 'рендер-анимация';
var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];

/**
 * Типы событий DOM -> Типы событий Chart.js.
 * Примечание: отображаются только события разных типов.
 * @см. https://developer.mozilla.org/en-US/docs/Web/Events
 */
var ТИПЫ_СОБЫТИЙ = {
	touchstart: 'mousedown',
	touchmove: 'перемещение мыши',
	touchend: 'mouseup',
	pointerenter: 'мышиный_ввод',
	pointerdown: 'mousedown',
	pointermove: 'перемещение мыши',
	указатель вверх: 'mouseup',
	pointerleave: 'mouseout',
	pointerout: 'mouseout'
};

/**
 * «Использованный» размер — это окончательное значение свойства измерения после всех расчетов.
 * выполнено. Этот метод использует вычисленный стиль `element`, но возвращает неопределенное
 * если вычисленный стиль не выражен в пикселях. Это может произойти в некоторых случаях, когда
 * `element` имеет размер относительно своего родителя, и этот последний пока не отображается,
 * например, из-за `display: none` на родительском узле.
 * @см. https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 * @returns {Number} Размер в пикселях или не определен, если неизвестен.
 */
функция readUsedSize(элемент, свойство) {
	значение переменной = helpers.getStyle(элемент, свойство);
	var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
	возвращает совпадения ? Number(matches[1]) : undefined;
}

/**
 * Инициализирует стиль холста и размер рендеринга без изменения размера отображения холста,
 * поскольку отзывчивость обрабатывается методом controller.resize(). Конфигурация используется
 * для определения соотношения сторон, которое следует применять в случае, если явно не указана высота.
 */
функция initCanvas(холст, конфигурация) {
	var style = холст.стиль;

	// ПРИМЕЧАНИЕ(SB) canvas.getAttribute('width') !== canvas.width: в первом случае это
	// возвращает null или '', если для атрибута холста не задано явное значение.
	var renderHeight = canvas.getAttribute('высота');
	var renderWidth = canvas.getAttribute('ширина');

	// Chart.js изменяет некоторые значения холста, которые мы хотим восстановить при уничтожении
	холст[EXPANDO_KEY] = {
		исходный: {
			высота: renderHeight,
			ширина: renderWidth,
			стиль: {
				дисплей: стиль.дисплей,
				высота: стиль.высота,
				ширина: стиль.ширина
			}
		}
	};

	// Принудительно отображать холст как блок, чтобы избежать дополнительного пространства, вызванного встроенными элементами
	// элементы, которые могут помешать процессу адаптивного изменения размера.
	// https://github.com/chartjs/Chart.js/issues/2538
	стиль.отображение = стиль.отображение || 'блок';

	если (renderWidth === null || renderWidth === '') {
		var displayWidth = readUsedSize(canvas, 'ширина');
		если (displayWidth !== не определено) {
			холст.ширина = displayWidth;
		}
	}

	если (renderHeight === null || renderHeight === '') {
		если (холст.стиль.высота === '') {
			// Если нет явной высоты рендеринга и высоты стиля, применим соотношение сторон,
			// какой из них может быть указан пользователем, а также диаграммами как опция по умолчанию
			// (т.е. options.aspectRatio). Если не указано, используйте соотношение сторон холста 2.
			высота.холста = ширина.холста / (config.options.aspectRatio || 2);
		} еще {
			var displayHeight = readUsedSize(canvas, 'высота');
			если (displayWidth !== не определено) {
				холст.высота = displayHeight;
			}
		}
	}

	вернуть холст;
}

/**
 * Обнаруживает поддержку аргумента объекта параметров в addEventListener.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
 * @частный
 */
var supportsEventListenerOptions = (function() {
	var поддерживает = false;
	пытаться {
		var options = Object.defineProperty({}, 'пассивный', {
			получить: функция() {
				поддерживает = истина;
			}
		});
		window.addEventListener('e', null, параметры);
	} поймать (е) {
		// продолжить независимо от ошибки
	}
	обратные опоры;
}());

// Пассивный режим по умолчанию установлен на true, как и ожидает Chrome для событий «touchstart» и «touchend».
// https://github.com/chartjs/Chart.js/issues/4287
вар eventListenerOptions = supportEventListenerOptions? {пассив: правда}: ложь;

функция addEventListener(узел, тип, слушатель) {
	узел.addEventListener(тип, прослушиватель, eventListenerOptions);
}

функция removeEventListener(узел, тип, слушатель) {
	node.removeEventListener(тип, прослушиватель, eventListenerOptions);
}

функция createEvent(тип, диаграмма, x, y, nativeEvent) {
	возвращаться {
		тип: тип,
		диаграмма: диаграмма,
		родной: nativeEvent || null,
		x: x !== не определено ? x : null,
		y: y !== не определено ? y : null,
	};
}

функция fromNativeEvent(событие, диаграмма) {
	var type = EVENT_TYPES[тип.события] || тип.события;
	var pos = helpers.getRelativePosition(событие, диаграмма);
	return createEvent(тип, диаграмма, поз.x, поз.y, событие);
}

функция дросселирована(fn, thisArg) {
	var ticking = false;
	переменная аргументы = [];

	функция возврата() {
		args = Массив.прототип.срез.вызов(аргументы);
		этотАрг = этотАрг || этот;

		если (!тикает) {
			тиканье = правда;
			helpers.requestAnimFrame.call(окно, функция() {
				тиканье = ложь;
				fn.apply(thisArg, args);
			});
		}
	};
}

// Реализация основана на https://github.com/marcj/css-element-queries
функция createResizer(обработчик) {
	var resizer = document.createElement('div');
	var cls = CSS_PREFIX + 'размер-монитора';
	var maxSize = 1000000;
	вар стиль =
		'позиция: абсолютная;' +
		'левый:0;' +
		'топ:0;' +
		'право:0;' +
		'внизу:0;' +
		'переполнение:скрыто;' +
		'события указателя:нет;' +
		'видимость:скрыт;' +
		'z-индекс:-1;';

	resizer.style.cssText = стиль;
	resizer.имя_класса = cls;
	resizer.innerHTML =
		'<div class="' + cls + '-expand" style="' + style + '">' +
			'<div стиль="' +
				'позиция: абсолютная;' +
				'ширина:' + максРазмер + 'px;' +
				'высота:' + максРазмер + 'px;' +
				'левый:0;' +
				'топ:0">' +
			'</div>' +
		'</div>' +
		'<div class="' + cls + '-shrink" style="' + style + '">' +
			'<div стиль="' +
				'позиция: абсолютная;' +
				'ширина:200%;' +
				'высота:200%;' +
				'слева:0; ' +
				'топ:0">' +
			'</div>' +
		'</div>';

	вар расширить = resizer.childNodes[0];
	вар сжать = resizer.childNodes[1];

	resizer._reset = функция() {
		expand.scrollLeft = maxSize;
		expand.scrollTop = maxSize;
		сжать.scrollLeft = maxSize;
		сжать.scrollTop = maxSize;
	};
	var onScroll = функция() {
		resizer._reset();
		обработчик();
	};

	addEventListener(расширить, 'прокрутить', onScroll.bind(расширить, 'расширить'));
	addEventListener(shrink, 'прокрутка', onScroll.bind(shrink, 'прокрутка'));

	возврат изменения размера;
}

// https://davidwalsh.name/detect-node-insertion
функция watchForRender(узел, обработчик) {
	varexpando = node[EXPANDO_KEY] || (узел[EXPANDO_KEY] = {});
	var proxy = expando.renderProxy = function(e) {
		если (e.animationName === CSS_RENDER_ANIMATION) {
			обработчик();
		}
	};

	помощники.каждый(ANIMATION_START_EVENTS, функция(тип) {
		addEventListener(узел, тип, прокси);
	});

	// #4737: Chrome может пропустить анимацию CSS, если класс CSS_RENDER_MONITOR
	// удаляется, а затем немедленно добавляется обратно (тот же кадр анимации?). Доступ к
	// Свойство `offsetParent` вызовет переформатирование и повторную оценку CSS-анимации.
	// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
	// https://github.com/chartjs/Chart.js/issues/4737
	expando.reflow = !!node.offsetParent;

	узел.classList.add(CSS_RENDER_MONITOR);
}

функция unwatchForRender(узел) {
	varexpando = node[EXPANDO_KEY] || {};
	var proxy = expando.renderProxy;

	если (прокси) {
		помощники.каждый(ANIMATION_START_EVENTS, функция(тип) {
			removeEventListener(узел, тип, прокси);
		});

		удалить expando.renderProxy;
	}

	node.classList.remove(CSS_RENDER_MONITOR);
}

функция addResizeListener(узел, слушатель, диаграмма) {
	varexpando = node[EXPANDO_KEY] || (узел[EXPANDO_KEY] = {});

	// Давайте отслеживать это добавленное изменение размера и таким образом избегать запроса DOM при его удалении.
	var resizer = expando.resizer = createResizer(throttled(function() {
		если (expando.resizer) {
			return listener(createEvent('resize', chart));
		}
	}));

	// Изменяющий размер необходимо прикрепить к родительскому узлу, поэтому сначала нужно
	// убедитесь, что `node` присоединен к DOM перед внедрением элемента изменения размера.
	watchForRender(узел, функция() {
		если (expando.resizer) {
			вар контейнер = node.parentNode;
			if (контейнер && контейнер !== resizer.parentNode) {
				контейнер.insertBefore(resizer, container.firstChild);
			}

			// Размер контейнера мог измениться, давайте сбросим состояние изменения размера.
			resizer._reset();
		}
	});
}

функция removeResizeListener(узел) {
	varexpando = node[EXPANDO_KEY] || {};
	var resizer = expando.resizer;

	удалить expando.resizer;
	unwatchForRender(узел);

	если (resizer && resizer.parentNode) {
		resizer.parentNode.removeChild(resizer);
	}
}

функция инъекции CSS(платформа, css) {
	// http://stackoverflow.com/q/3922139
	var style = platform._style || document.createElement('style');
	если (!платформа._стиль) {
		платформа._стиль = стиль;
		css = '/* Диаграмма.js */\n' + css;
		style.setAttribute('тип', 'текст/css');
		document.getElementsByTagName('head')[0].appendChild(style);
	}

	style.appendChild(document.createTextNode(css));
}

модуль.экспорты = {
	/**
	 * Это свойство определяет, включена ли данная платформа для текущей среды.
	 * В настоящее время используется platform.js для выбора правильной реализации.
	 * @частный
	 */
	_enabled: тип окна !== 'undefined' && тип документа !== 'undefined',

	инициализировать: функция() {
		var keyframes = 'от{opacity:0.99}до{opacity:1}';

		вставитьCSS(это,
			// Обнаружение рендеринга DOM
			// https://davidwalsh.name/detect-node-insertion
			'@-webkit-keyframes' + CSS_RENDER_ANIMATION + '{' + ключевые кадры + '}' +
			'@keyframes' + CSS_RENDER_ANIMATION + '{' + ключевые кадры + '}' +
			'.' + CSS_RENDER_MONITOR + '{' +
				'-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +
				'анимация:' + CSS_RENDER_ANIMATION + ' 0.001с;' +
			'}'
		);
	},

	acquireContext: функция(элемент, конфигурация) {
		если (тип элемента === 'строка') {
			элемент = документ.getElementById(элемент);
		} иначе если (элемент.длина) {
			// Поддержка запросов на основе массивов (например, jQuery)
			элемент = элемент[0];
		}

		если (элемент && элемент.холст) {
			// Поддержка любого объекта, связанного с холстом (включая context2d)
			элемент = элемент.холст;
		}

		// Чтобы предотвратить отпечатки холста, некоторые надстройки отменяют определение getContext
		// метод, например: https://github.com/kkapsner/CanvasBlocker
		// https://github.com/chartjs/Chart.js/issues/2807
		var context = item && item.getContext && item.getContext('2d');

		// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` завершается ошибкой, если элемент
		// внутри iframe или при запуске в защищенной среде. Мы могли бы предположить,
		// типы из их значения toString(), но давайте сохраним гибкость и предположим, что это
		// достаточное условие, если элемент имеет context2D, в котором элемент является `canvas`.
		// https://github.com/chartjs/Chart.js/issues/3887
		// https://github.com/chartjs/Chart.js/issues/4102
		// https://github.com/chartjs/Chart.js/issues/4152
		если (контекст && контекст.холст === элемент) {
			initCanvas(элемент, конфигурация);
			возврат контекста;
		}

		вернуть ноль;
	},

	releaseContext: функция(контекст) {
		var холст = контекст.холст;
		если (!canvas[EXPANDO_KEY]) {
			возвращаться;
		}

		var initial = холст[EXPANDO_KEY].initial;
		['высота', 'ширина'].forEach(function(prop) {
			значение переменной = начальное[свойство];
			если (helpers.isNullOrUndef(значение)) {
				холст.removeAttribute(свойство);
			} еще {
				холст.setAttribute(свойство, значение);
			}
		});

		helpers.each(initial.style || {}, function(value, key) {
			холст.стиль[ключ] = значение;
		});

		// Размер рендеринга холста мог быть изменен (и, следовательно, стек состояний был сброшен),
		// мы не можем использовать save() и restore() для восстановления исходного состояния. Поэтому убедитесь, что в
		// по крайней мере, контекст холста сбрасывается в состояние по умолчанию путем установки ширины холста.
		// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
		ширина.холста = ширина.холста;

		удалить холст[EXPANDO_KEY];
	},

	addEventListener: функция(диаграмма, тип, прослушиватель) {
		var холст = диаграмма.холст;
		если (тип === 'изменить размер') {
			// Примечание: событие изменения размера поддерживается не во всех браузерах.
			addResizeListener(холст, слушатель, диаграмма);
			возвращаться;
		}

		varexpando = прослушиватель[EXPANDO_KEY] || (прослушиватель[EXPANDO_KEY] = {});
		var proxies = expando.proxies || (expando.proxies = {});
		var proxy = proxy[chart.id + '_' + type] = function(event) {
			прослушиватель(fromNativeEvent(событие, диаграмма));
		};

		addEventListener(холст, тип, прокси);
	},

	removeEventListener: функция(диаграмма, тип, прослушиватель) {
		var холст = диаграмма.холст;
		если (тип === 'изменить размер') {
			// Примечание: событие изменения размера поддерживается не во всех браузерах.
			removeResizeListener(холст, слушатель);
			возвращаться;
		}

		varexpando = прослушиватель[EXPANDO_KEY] || {};
		var proxies = expando.proxies || {};
		var proxy = proxy[chart.id + '_' + type];
		если (!прокси) {
			возвращаться;
		}

		removeEventListener(холст, тип, прокси);
	}
};

// УСТАРЕНИЕ

/**
 * Предоставлено для обратной совместимости, вместо этого используйте EventTarget.addEventListener.
 * Совместимость EventTarget.addEventListener: Chrome, Opera 7, Safari, FF1.5+, IE9+
 * @см. https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
 * @function Chart.helpers.addEvent
 * @deprecated с версии 2.7.0
 * @todo удалено в версии 3
 * @частный
 */
helpers.addEvent = addEventListener;

/**
 * Предоставлено для обратной совместимости, вместо этого используйте EventTarget.removeEventListener.
 * Совместимость EventTarget.removeEventListener: Chrome, Opera 7, Safari, FF1.5+, IE9+
 * @см. https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
 * @function Chart.helpers.removeEvent
 * @deprecated с версии 2.7.0
 * @todo удалено в версии 3
 * @частный
 */
helpers.removeEvent = removeEventListener;

},{"45":45}],48:[function(require,module,exports){
«использовать строго»;

var helpers = require(45);
var basic = require(46);
var dom = require(47);

// @TODO Сделать возможным выбор другой платформы во время сборки.
var implementation = dom._enabled ? dom : basic;

/**
 * @namespace Chart.platform
 * @см. https://chartjs.gitbooks.io/proposals/content/Platform.html
 * @с версии 2.4.0
 */
модуль.экспорты = помощники.расширить({
	/**
	 * @с версии 2.7.0
	 */
	инициализировать: функция() {},

	/**
	 * Вызывается во время построения диаграммы, возвращает экземпляр context2d, реализующий
	 * [Стандарт API контекста W3C Canvas 2D]{@link https://www.w3.org/TR/2dcontext/}.
	 * @param {*} item — собственный элемент, из которого необходимо получить контекст (зависит от платформы)
	 * @param {Object} options - Параметры диаграммы
	 * @returns {CanvasRenderingContext2D} экземпляр context2d
	 */
	acquireContext: функция() {},

	/**
	 * Вызывается во время уничтожения диаграммы, освобождает все ресурсы, связанные с контекстом
	 * ранее возвращалось методом acquireContext().
	 * @param {CanvasRenderingContext2D} context — экземпляр context2d
	 * @returns {Boolean} true, если метод выполнен успешно, в противном случае false
	 */
	releaseContext: функция() {},

	/**
	 * Регистрирует указанный прослушиватель на указанной диаграмме.
	 * @param {Chart} chart — диаграмма, из которой следует прослушивать события
	 * @param {String} type — тип ({@link IEvent}), который нужно прослушивать
	 * @param {Function} прослушиватель - получает уведомление (объект, реализующий
	 * интерфейс {@link IEvent}) при возникновении события указанного типа.
	 */
	addEventListener: функция() {},

	/**
	 * Удаляет указанный прослушиватель, ранее зарегистрированный с помощью addEventListener.
	 * @param {Chart} chart - Диаграмма, из которой нужно удалить слушателя
	 * @param {String} type — тип ({@link IEvent}), который нужно удалить
	 * @param {Function} listener — функция прослушивателя, которую необходимо удалить из цели события.
	 */
	removeEventListener: функция() {}

}, выполнение);

/**
 * @интерфейс IPlatform
 * Позволяет абстрагировать зависимости платформы от диаграммы
 * @borrows Chart.platform.acquireContext как acquireContext
 * @borrows Chart.platform.releaseContext как releaseContext
 * @borrows Chart.platform.addEventListener как addEventListener
 * @borrows Chart.platform.removeEventListener как removeEventListener
 */

/**
 * @interface IEvent
 * @prop {String} type — имя типа события, возможные значения:
 * 'contextmenu', 'mouseenter', 'mousedown', 'mousemove', 'mouseup', 'mouseout',
 * «щелчок», «двойной щелчок», «нажатие клавиши», «нажатие клавиши», «отжатие клавиши» и «изменение размера»
 * @prop {*} native — исходное нативное событие (null для эмулируемых событий, например, «resize»)
 * @prop {Number} x — позиция мыши по оси x относительно холста (null для несовместимых событий)
 * @prop {Number} y — позиция мыши по оси Y относительно холста (null для несовместимых событий)
 */

},{"45":45,"46":46,"47":47}],49:[function(require,module,exports){
«использовать строго»;

модуль.экспорт = {};
модуль.экспорт.наполнитель = требуется(50);
module.exports.legend = требуется(51);
module.exports.title = требуется(52);

},{"50":50,"51":51,"52":52}],50:[function(require,module,exports){
/**
 * Плагин основан на обсуждении следующих проблем Chart.js:
 * @см. https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569
 * @см. https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897
 */

«использовать строго»;

переменные по умолчанию = require(25);
элементы переменной = require(40);
var helpers = require(45);

defaults._set('глобальный', {
	плагины: {
		наполнитель: {
			распространять: правда
		}
	}
});

var mappers = {
	набор данных: функция(источник) {
		var index = источник.fill;
		var chart = исходная.диаграмма;
		вар мета =chart.getDatasetMeta(индекс);
		var visible = meta && chart.isDatasetVisible(index);
		var points = (visible && meta.dataset._children) || [];
		var длина = points.длина || 0;

		вернуть !длина ? null : функция(точка, i) {
			возврат (i < длина && точек[i]._view) || null;
		};
	},

	граница: функция(источник) {
		var граница = источник.граница;
		var x = граница ? граница.x : null;
		var y = граница ? граница.y : null;

		функция возврата(точка) {
			возвращаться {
				x: x === null ? точка.x : x,
				y: y === null ? точка.y : y,
			};
		};
	}
};

// @todo если (fill[0] === '#')
функция decodeFill(el, index, count) {
	var model = el._model || {};
	var fill = модель.fill;
	var цель;

	если (заполнить === не определено) {
		fill = !!model.backgroundColor;
	}

	если (заполнить === ложь || заполнить === ноль) {
		вернуть ложь;
	}

	если (заполнить === правда) {
		вернуть «источник»;
	}

	цель = parseFloat (заполнить, 10);
	если (isFinite(target) && Math.floor(target) === target) {
		если (заполнение[0] === '-' || заполнение[0] === '+') {
			цель = индекс + цель;
		}

		если (цель === индекс || цель < 0 || цель >= количество) {
			вернуть ложь;
		}

		возврат цели;
	}

	переключатель (заполнить) {
	// совместимость
	случай «низ»:
		вернуть «старт»;
	случай «верх»:
		вернуть «конец»;
	случай «ноль»:
		вернуть «источник»;
	// поддерживаемые границы
	случай «происхождение»:
	случай «начало»:
	случай «конец»:
		возвратное заполнение;
	// недопустимые значения заполнения
	по умолчанию:
		вернуть ложь;
	}
}

функция computeBoundary(источник) {
	var model = source.el._model || {};
	var scale = source.el._scale || {};
	var fill = источник.fill;
	var target = null;
	вар горизонтальный;

	если (isFinite(заполнить)) {
		вернуть ноль;
	}

	// Обратная совместимость: до версии 3 нам все еще необходимо поддерживать граничные значения, заданные
	// модель (scaleTop, scaleBottom и scaleZero), поскольку некоторые внешние плагины и
	// контроллеры все еще могут его использовать (например, диаграмма Смита).

	если (заполнить === 'старт') {
		цель = модель.scaleBottom === не определено ? масштаб.bottom : модель.scaleBottom;
	} иначе если (заполнить === 'конец') {
		цель = модель.scaleTop === не определено ? масштаб.top : модель.scaleTop;
	} иначе если (модель.scaleZero !== не определено) {
		цель = модель.scaleZero;
	} иначе если (scale.getBasePosition) {
		цель = масштаб.getBasePosition();
	} иначе если (масштаб.getBasePixel) {
		цель = масштаб.getBasePixel();
	}

	если (цель !== не определено && цель !== null) {
		если (цель.x !== не определено && цель.y !== не определено) {
			возврат цели;
		}

		если (тип цели === 'число' && isFinite(цель)) {
			горизонтальный = масштаб.isHorizontal();
			возвращаться {
				x: горизонтально ? цель : null,
				y: горизонтальный ? null : цель
			};
		}
	}

	вернуть ноль;
}

функция resolveTarget(источники, индекс, распространение) {
	var source = источники[индекс];
	var fill = источник.fill;
	var visited = [индекс];
	var цель;

	если (!распространять) {
		возвратное заполнение;
	}

	в то время как (fill !== false && visited.indexOf(fill) === -1) {
		если (!isFinite(заполнить)) {
			возвратное заполнение;
		}

		цель = источники[заполнить];
		если (!цель) {
			вернуть ложь;
		}

		если (цель.видимая) {
			возвратное заполнение;
		}

		посетил.push(заполнить);
		заполнить = цель.заполнить;
	}

	вернуть ложь;
}

функция createMapper(источник) {
	var fill = источник.fill;
	тип переменной = 'набор данных';

	если (заполнить === ложь) {
		вернуть ноль;
	}

	если (!isFinite(заполнить)) {
		тип = 'граница';
	}

	возврат картографов[тип](источник);
}

функция isDrawable(точка) {
	точка возврата && !point.skip;
}

функция drawArea(ctx, curve0, curve1, len0, len1) {
	вар i;

	если (!len0 || !len1) {
		возвращаться;
	}

	// построение первой кривой области (нормальной)
	ctx.moveTo(кривая0[0].x, кривая0[0].y);
	для (i = 1; i < len0; ++i) {
		helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
	}

	// соединение двух кривых площади
	ctx.lineTo(кривая1[длина1 - 1].x, кривая1[длина1 - 1].y);

	// построение обратной кривой области (обратная)
	для (i = len1 - 1; i > 0; --i) {
		helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
	}
}

функция doFill(ctx, точки, картограф, вид, цвет, цикл) {
	var count = points.length;
	var span = view.spanGaps;
	var curve0 = [];
	var curve1 = [];
	var len0 = 0;
	var len1 = 0;
	var i, ilen, index, p0, p1, d0, d1;

	ctx.beginPath();

	для (i = 0, ilen = (count + !!loop); i < ilen; ++i) {
		индекс = i % количество;
		p0 = точки[индекс]._view;
		p1 = mapper(p0, индекс, вид);
		d0 = isDrawable(p0);
		d1 = isDrawable(p1);

		если (d0 && d1) {
			len0 = curve0.push(p0);
			len1 = curve1.push(p1);
		} иначе если (len0 && len1) {
			если (!span) {
				drawArea(ctx, curve0, curve1, len0, len1);
				len0 = len1 = 0;
				кривая0 = [];
				кривая1 = [];
			} еще {
				если (d0) {
					кривая0.push(p0);
				}
				если (d1) {
					кривая1.push(p1);
				}
			}
		}
	}

	drawArea(ctx, curve0, curve1, len0, len1);

	ctx.closePath();
	ctx.fillStyle = цвет;
	ctx.заполнить();
}

модуль.экспорты = {
	идентификатор: 'наполнитель',

	afterDatasetsUpdate: функция(диаграмма, параметры) {
		var count = (chart.data.datasets || []).length;
		var propagate = параметры.распространение;
		var источники = [];
		var meta, i, el, источник;

		для (i = 0; i < количество; ++i) {
			мета = диаграмма.getDatasetMeta(i);
			el = мета.набор данных;
			источник = ноль;

			если (el && el._model && el instanceof elements.Line) {
				источник = {
					видимый: chart.isDatasetVisible(i),
					заполнить: decodeFill(el, i, count),
					диаграмма: диаграмма,
					эл: эл
				};
			}

			мета.$filler = источник;
			источники.push(источник);
		}

		для (i = 0; i < количество; ++i) {
			источник = источники[i];
			если (!источник) {
				продолжать;
			}

			источник.fill = resolveTarget(источники, i, распространять);
			источник.граница = computeBoundary(источник);
			источник.mapper = createMapper(источник);
		}
	},

	beforeDatasetDraw: функция(диаграмма, аргументы) {
		var meta = args.meta.$filler;
		если (!мета) {
			возвращаться;
		}

		var ctx = диаграмма.ctx;
		var el = meta.el;
		var view = el._view;
		var points = el._children || [];
		var mapper = meta.mapper;
		var color = view.backgroundColor || defaults.global.defaultColor;

		если (картограф && цвет && точки.длина) {
			helpers.canvas.clipArea(ctx, chart.chartArea);
			doFill(ctx, points, mapper, view, color, el._loop);
			helpers.canvas.unclipArea(ctx);
		}
	}
};

},{"25":25,"40":40,"45":45}],51:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
Элемент var = require(26);
var helpers = require(45);
var layouts = require(30);

var noop = helpers.noop;

defaults._set('глобальный', {
	легенда: {
		дисплей: правда,
		позиция: «сверху»,
		полнаяШирина: правда,
		обратный: ложный,
		вес: 1000,

		// обратный вызов, который будет обрабатывать
		onClick: функция(e, legendItem) {
			индекс вар = LegendItem.datasetIndex;
			var ci = эта.диаграмма;
			вар мета = ci.getDatasetMeta(индекс);

			// См. комментарий controller.isDatasetVisible
			meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

			// Мы скрыли набор данных... перерисовываем диаграмму
			ci.обновление();
		},

		onHover: ноль,

		метки: {
			Ширина коробки: 40,
			заполнение: 10,
			// Создает метки, показанные в легенде
			// Допустимые возвращаемые свойства:
			// текст : текст для отображения
			// fillStyle : заполнение цветного поля
			// strokeStyle: обводка цветного поля
			// скрытый : если этот элемент легенды ссылается на скрытый элемент
			// lineCap : стиль окончания линии
			// линияТире
			// lineDashOffset :
			// lineJoin:
			// ширина линии:
			generateLabels: функция(диаграмма) {
				var data = chart.data;
				вернуть helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {
					возвращаться {
						текст: набор данных.метка,
						fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),
						скрытый: !chart.isDatasetVisible(i),
						lineCap: dataset.borderCapStyle,
						lineDash: набор данных.borderDash,
						lineDashOffset: набор_данных.borderDashOffset,
						lineJoin: набор данных.borderJoinStyle,
						lineWidth: dataset.borderWidth,
						strokeStyle: dataset.borderColor,
						pointStyle: набор данных.pointStyle,

						// Ниже приведены дополнительные данные, используемые для переключения наборов данных.
						Индекс набора данных: i
					};
				}, этот) : [];
			}
		}
	},

	legendCallback: функция(диаграмма) {
		переменная текст = [];
		text.push('<ul class="' + chart.id + '-legend">');
		для (var i = 0; i < chart.data.datasets.length; i++) {
			text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
			если (chart.data.datasets[i].label) {
				text.push(chart.data.datasets[i].label);
			}
			текст.push('</li>');
		}
		текст.push('</ul>');
		вернуть текст.join('');
	}
});

/**
 * Вспомогательная функция для получения ширины поля на основе параметра usePointStyle
 * @param labelopts {Object} параметры метки в легенде
 * @param fontSize {Number} размер шрифта метки
 * @return {Number} ширина области цветового поля
 */
функция getBoxWidth(labelOpts, fontSize) {
	вернуть labelOpts.usePointStyle ?
		Размер шрифта * Математика.SQRT2 :
		labelOpts.boxWidth;
}

/**
 * ВАЖНО: этот класс представлен публично как Chart.Legend, требуется обратная совместимость!
 */
var Легенда = Элемент.расширить({

	инициализация: функция(config) {
		helpers.extend(это, конфигурация);

		// Содержит области попадания для каждого набора данных (в порядке набора данных)
		эта.легендаHitBoxes = [];

		// Находимся ли мы в режиме пончика, который имеет другой тип данных?
		этот.doughnutMode = false;
	},

	// Эти методы упорядочены по жизненному циклу. Затем следуют утилиты.
	// Любая функция, определенная здесь, наследуется всеми типами легенд.
	// Любая функция может быть расширена типом легенды

	доОбновления: нуп,
	обновить: функция(максШирина, максВысота, поля) {
		var me = это;

		// Обновление жизненного цикла - Вероятно, не стоит когда-либо расширять или перезаписывать эту функцию ;)
		я.beforeUpdate();

		// Поглощайте основные измерения
		я.максШирина = максШирина;
		я.максВысота = максВысота;
		me.margins = поля;

		// Размеры
		я.beforeSetDimensions();
		я.setDimensions();
		я.afterSetDimensions();
		// Метки
		я.beforeBuildLabels();
		я.buildLabels();
		я.afterBuildLabels();

		// Соответствовать
		я.beforeFit();
		я.подходит();
		я.afterFit();
		//
		я.afterUpdate();

		вернуть мне.minSize;
	},
	afterUpdate: нуп,

	//

	beforeSetDimensions: нет,
	setDimensions: функция() {
		var me = это;
		// Устанавливаем неограниченный размер перед поворотом метки
		если (я.isHorizontal()) {
			// Сбросить позицию перед расчетом поворота
			я.ширина = я.максШирина;
			я.левый = 0;
			я.право = я.ширина;
		} еще {
			я.высота = я.максВысота;

			// Сбросить позицию перед расчетом поворота
			я.топ = 0;
			я.низ = я.рост;
		}

		// Сбросить отступы
		я.paddingLeft = 0;
		я.paddingTop = 0;
		я.paddingRight = 0;
		я.paddingBottom = 0;

		// Сбросить мин. размер
		я.минРазмер = {
			ширина: 0,
			высота: 0
		};
	},
	afterSetDimensions: нет,

	//

	beforeBuildМетки: noop,
	buildLabels: функция() {
		var me = это;
		var labelOpts = me.options.labels || {};
		var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];

		если (labelOpts.filter) {
			legendItems = legendItems.фильтр(функция(элемент) {
				return labelOpts.filter(item, me.chart.data);
			});
		}

		если (я.опции.обратный) {
			legendItems.reverse();
		}

		я.legendItems = legendItems;
	},
	afterBuildМетки: noop,

	//

	beforeFit: нуп,
	подходит: функция() {
		var me = это;
		var opts = me.options;
		var labelOpts = opts.labels;
		var display = opts.display;

		var ctx = я.ctx;

		вар globalDefault = defaults.global;
		var значениеИлиПоУмолчанию = помощники.значениеИлиПоУмолчанию;
		var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
		var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
		var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
		var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);

		// Сбросить хитбоксы
		var hitboxes = me.legendHitBoxes = [];

		var minSize = me.minSize;
		вар isHorizontal = me.isHorizontal();

		если (горизонтально) {
			minSize.width = me.maxWidth; // заполнить всю ширину
			minSize.height = display ? 10 : 0;
		} еще {
			minSize.width = display ? 10 : 0;
			minSize.height = me.maxHeight; // заполнить всю высоту
		}

		// Увеличить размеры здесь
		если (дисплей) {
			ctx.font = labelFont;

			если (горизонтально) {
				// Метки

				// Ширина каждой строки полей легенды. Метки переносятся на несколько строк, когда их слишком много, чтобы поместиться на одной
				var lineWidths = me.lineWidths = [0];
				var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;

				ctx.textAlign = 'влево';
				ctx.textBaseline = 'верх';

				помощники.каждый(я.легендныеэлементы, функция(легендныйэлемент, я) {
					вар boxWidth = getBoxWidth (labelOpts, FontSize);
					var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

					если (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
						totalHeight += fontSize + (labelOpts.padding);
						lineWidths[lineWidths.length] = я.левый;
					}

					// Сохраните здесь ширину и высоту хитбокса. Окончательное положение будет обновлено в `draw`
					хитбоксы[i] = {
						осталось: 0,
						вверху: 0,
						ширина: ширина,
						высота: размер шрифта
					};

					lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
				});

				minSize.height += totalHeight;

			} еще {
				var vPadding = labelOpts.padding;
				var columnWidths = me.columnWidths = [];
				var totalWidth = labelOpts.padding;
				var currentColWidth = 0;
				var currentColHeight = 0;
				var itemHeight = fontSize + vPadding;

				помощники.каждый(я.легендныеэлементы, функция(легендныйэлемент, я) {
					вар boxWidth = getBoxWidth (labelOpts, FontSize);
					var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

					// Если слишком высоко, перейти к новому столбцу
					если (currentColHeight + itemHeight > minSize.height) {
						totalWidth += currentColWidth + labelOpts.padding;
						columnWidths.push(currentColWidth); // предыдущая ширина столбца

						текущаяШиринаСтолбца = 0;
						currentColHeight = 0;
					}

					// Получить максимальную ширину
					currentColWidth = Math.max(currentColWidth, itemWidth);
					currentColHeight += itemHeight;

					// Сохраните здесь ширину и высоту хитбокса. Окончательное положение будет обновлено в `draw`
					хитбоксы[i] = {
						осталось: 0,
						вверху: 0,
						ширина: itemWidth,
						высота: размер шрифта
					};
				});

				общаяШирина += текущаяШиринаСтолбца;
				Ширина столбца.push(текущая ширина столбца);
				minSize.width += totalWidth;
			}
		}

		me.width = minSize.width;
		я.высота = минРазмер.высота;
	},
	afterFit: нуп,

	// Общие методы
	isHorizontal: функция() {
		вернуть this.options.position === 'top' || this.options.position === 'bottom';
	},

	// На самом деле рисуем легенду на холсте
	рисовать: функция() {
		var me = это;
		var opts = me.options;
		var labelOpts = opts.labels;
		вар globalDefault = defaults.global;
		var lineDefault = globalDefault.elements.line;
		var legendWidth = me.width;
		var lineWidths = me.lineWidths;

		если (opts.display) {
			var ctx = я.ctx;
			var значениеИлиПоУмолчанию = помощники.значениеИлиПоУмолчанию;
			вар fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
			var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
			var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
			var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
			var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
			переменная курсора;

			// Настройка холста
			ctx.textAlign = 'влево';
			ctx.textBaseline = 'средний';
			ctx.lineWidth = 0,5;
			ctx.strokeStyle = fontColor; // для эффекта зачеркивания
			ctx.fillStyle = fontColor; // отрисовать в правильном цвете
			ctx.font = labelFont;

			вар boxWidth = getBoxWidth (lab elOpts, FontSize);
			var hitboxes = me.legendHitBoxes;

			// текущая позиция
			вар drawLegendBox = функция (x, y, LegendItem) {
				if (isNaN(boxWidth) || boxWidth <= 0) {
					возвращаться;
				}

				// Установите ctx для коробки
				ctx.сохранить();

				ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
				ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
				ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
				ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
				ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
				ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
				var isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);

				если (ctx.setLineDash) {
					// IE 9 и 10 не поддерживают штриховую линию
					ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
				}

				если (opts.labels && opts.labels.usePointStyle) {
					// Пересчитать x и y для drawPoint(), так как ожидается
					// x и y должны быть в центре фигуры (а не в левом верхнем углу)
					вар радиус = FontSize * Math.SQRT2/2;
					var offSet = радиус / Математика.SQRT2;
					var centerX = x + offsetSet;
					var centerY = y + offsetSet;

					// Нарисовать pointStyle как символ легенды
					helpers.canvas.drawPoint(ctx, legendItem.pointStyle, радиус, centerX, centerY);
				} еще {
					// Нарисовать рамку как символ легенды
					если (!isLineWidthZero) {
						ctx.strokeRect(x, y, boxWidth, fontSize);
					}
					ctx.fillRect(x, y, boxWidth, fontSize);
				}

				ctx.восстановить();
			};
			var fillText = function(x, y, legendItem, textWidth) {
				var halfFontSize = fontSize / 2;
				var xLeft = boxWidth + halfFontSize + x;
				вар yMiddle = y + halfFontSize;

				ctx.fillText(legendItem.text, xLeft, yMiddle);

				если (легендаЭлемент.скрытый) {
					// Зачеркнуть текст, если он скрыт
					ctx.beginPath();
					ctx.lineWidth = 2;
					ctx.moveTo(xLeft, yMiddle);
					ctx.lineTo(xLeft + textWidth, yMiddle);
					ctx.stroke();
				}
			};

			// Горизонтальный
			вар isHorizontal = me.isHorizontal();
			если (горизонтально) {
				курсор = {
					x: me.left + ((шириналегенды - шириналинии[0]) / 2),
					y: me.top + labelOpts.padding,
					строка: 0
				};
			} еще {
				курсор = {
					x: me.left + labelOpts.padding,
					y: me.top + labelOpts.padding,
					строка: 0
				};
			}

			var itemHeight = fontSize + labelOpts.padding;
			помощники.каждый(я.легендныеэлементы, функция(легендныйэлемент, я) {
				var textWidth = ctx.measureText(legendItem.text).width;
				вар ширина = boxWidth + (fontSize/2) + textWidth;
				var x = курсор.x;
				var y = курсор.y;

				если (горизонтально) {
					если (x + ширина >= шириналегенды) {
						y = курсор.y += itemHeight;
						курсор.строка++;
						x = курсор.x = я.left + ((шириналегенды - шириналинии[курсор.линия]) / 2);
					}
				} иначе если (y + itemHeight > me.bottom) {
					x = курсор.x = x + me.columnWidths[курсор.линия] + labelOpts.padding;
					y = cursor.y = me.top + labelOpts.padding;
					курсор.строка++;
				}

				drawLegendBox(x, y, legendItem);

				хитбоксы[i].left = x;
				хитбоксы[i].top = y;

				// Заполняем фактическую метку
				fillText(x, y, LegendItem, textWidth);

				если (горизонтально) {
					курсор.x += ширина + (labelOpts.padding);
				} еще {
					курсор.y += itemHeight;
				}

			});
		}
	},

	/**
	 * Обработка события
	 * @частный
	 * @param {IEvent} event — событие для обработки
	 * @return {Boolean} true, если произошло изменение
	 */
	handleEvent: функция(e) {
		var me = это;
		var opts = me.options;
		var type = e.type === 'mouseup' ? 'click' : e.type;
		переменная изменена = ложь;

		если (тип === 'mousemove') {
			если (!opts.onHover) {
				возвращаться;
			}
		} иначе если (тип === 'щелчок') {
			если (!opts.onClick) {
				возвращаться;
			}
		} еще {
			возвращаться;
		}

		// Событие диаграммы уже имеет в себе относительное положение
		вар х = ех;
		вар у = еу;

		если (x >= я.слева && x <= я.справа && y >= я.сверху && y <= я.снизу) {
			// Смотрим, касаемся ли мы одного из полей набора данных
			var lh = me.legendHitBoxes;
			для (var i = 0; i < lh.length; ++i) {
				var hitBox = lh[i];

				если (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
					// Прикосновение к элементу
					если (тип === 'щелчок') {
						// используйте e.native для обратной совместимости
						opts.onClick.call(me, e.native, me.legendItems[i]);
						изменено = правда;
						перерыв;
					} иначе если (тип === 'mousemove') {
						// используйте e.native для обратной совместимости
						opts.onHover.call(me, e.native, me.legendItems[i]);
						изменено = правда;
						перерыв;
					}
				}
			}
		}

		возвращение изменено;
	}
});

функция createNewLegendAndAttach(chart, legendOpts) {
	var legend = новая легенда({
		ctx: диаграмма.ctx,
		параметры: legendOpts,
		диаграмма: диаграмма
	});

	layouts.configure(диаграмма, легенда, легендаOpts);
	layouts.addBox(диаграмма, легенда);
	диаграмма.легенда = легенда;
}

модуль.экспорты = {
	идентификатор: 'легенда',

	/**
	 * Обратная совместимость: начиная с версии 2.1.5 легенда зарегистрирована как плагин, что делает
	 * Chart.Legend устарел. Чтобы избежать критических изменений, мы экспортируем Legend как часть
	 * плагин, который будет повторно представлен в файле chart.js.
	 * https://github.com/chartjs/Chart.js/pull/2640
	 * @частный
	 */
	_элемент: Легенда,

	beforeInit: функция(диаграмма) {
		var legendOpts = chart.options.legend;

		если (легендаОптс) {
			createNewLegendAndAttach(chart, legendOpts);
		}
	},

	beforeUpdate: функция(диаграмма) {
		var legendOpts = chart.options.legend;
		var legend = диаграмма.легенда;

		если (легендаОптс) {
			helpers.mergeIf(legendOpts, defaults.global.legend);

			если (легенда) {
				layouts.configure(диаграмма, легенда, легендаOpts);
				legend.options = legendOpts;
			} еще {
				createNewLegendAndAttach(chart, legendOpts);
			}
		} иначе если (легенда) {
			layouts.removeBox(диаграмма, легенда);
			удалить диаграмму.легенда;
		}
	},

	afterEvent: функция(диаграмма, e) {
		var legend = диаграмма.легенда;
		если (легенда) {
			легенда.handleEvent(e);
		}
	}
};

},{"25":25,"26":26,"30":30,"45":45}],52:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
Элемент var = require(26);
var helpers = require(45);
var layouts = require(30);

var noop = helpers.noop;

defaults._set('глобальный', {
	заголовок: {
		отображение: ложь,
		Стиль шрифта: 'жирный',
		полнаяШирина: правда,
		lineHeight: 1.2,
		заполнение: 10,
		позиция: «сверху»,
		текст: '',
		вес: 2000 // по умолчанию больше легенды (1000), чтобы быть выше
	}
});

/**
 * ВАЖНО: этот класс представлен публично как Chart.Legend, требуется обратная совместимость!
 */
var Заголовок = Элемент.расширить({
	инициализация: функция(config) {
		var me = это;
		helpers.extend(я, конфигурация);

		// Содержит области попадания для каждого набора данных (в порядке набора данных)
		me.legendHitBoxes = [];
	},

	// Эти методы упорядочены по жизненному циклу. Затем следуют утилиты.

	доОбновления: нуп,
	обновить: функция(максШирина, максВысота, поля) {
		var me = это;

		// Обновление жизненного цикла - Вероятно, не стоит когда-либо расширять или перезаписывать эту функцию ;)
		я.beforeUpdate();

		// Поглощайте основные измерения
		я.максШирина = максШирина;
		я.максВысота = максВысота;
		me.margins = поля;

		// Размеры
		я.beforeSetDimensions();
		я.setDimensions();
		я.afterSetDimensions();
		// Метки
		я.beforeBuildLabels();
		я.buildLabels();
		я.afterBuildLabels();

		// Соответствовать
		я.beforeFit();
		я.подходит();
		я.afterFit();
		//
		я.afterUpdate();

		вернуть мне.minSize;

	},
	afterUpdate: нуп,

	//

	beforeSetDimensions: нет,
	setDimensions: функция() {
		var me = это;
		// Устанавливаем неограниченный размер перед поворотом метки
		если (я.isHorizontal()) {
			// Сбросить позицию перед расчетом поворота
			я.ширина = я.максШирина;
			я.левый = 0;
			я.право = я.ширина;
		} еще {
			я.высота = я.максВысота;

			// Сбросить позицию перед расчетом поворота
			я.топ = 0;
			я.низ = я.рост;
		}

		// Сбросить отступы
		я.paddingLeft = 0;
		я.paddingTop = 0;
		я.paddingRight = 0;
		я.paddingBottom = 0;

		// Сбросить мин. размер
		я.минРазмер = {
			ширина: 0,
			высота: 0
		};
	},
	afterSetDimensions: нет,

	//

	beforeBuildМетки: noop,
	buildМетки: noop,
	afterBuildМетки: noop,

	//

	beforeFit: нуп,
	подходит: функция() {
		var me = это;
		var значениеИлиПоУмолчанию = помощники.значениеИлиПоУмолчанию;
		var opts = me.options;
		var display = opts.display;
		var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
		var minSize = me.minSize;
		var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
		var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
		var textSize = display ? (lineCount * lineHeight) + (opts.padding * 2) : 0;

		если (я.isHorizontal()) {
			minSize.width = me.maxWidth; // заполнить всю ширину
			minSize.height = textSize;
		} еще {
			minSize.width = textSize;
			minSize.height = me.maxHeight; // заполнить всю высоту
		}

		me.width = minSize.width;
		я.высота = минРазмер.высота;

	},
	afterFit: нуп,

	// Общие методы
	isHorizontal: функция() {
		var pos = эта.опция.позиция;
		возврат поз === 'верх' || поз === 'низ';
	},

	// Фактически рисуем заголовок на холсте
	рисовать: функция() {
		var me = это;
		var ctx = я.ctx;
		var значениеИлиПоУмолчанию = помощники.значениеИлиПоУмолчанию;
		var opts = me.options;
		var globalDefaults = defaults.global;

		если (opts.display) {
			var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
			var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
			var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
			var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
			var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
			var offset = lineHeight / 2 + opts.padding;
			переменная вращения = 0;
			var top = я.топ;
			var left = я.left;
			var bottom = я.bottom;
			var right = я.right;
			var maxWidth, titleX, titleY;

			ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // отрисовать в правильном цвете
			ctx.font = titleFont;

			// Горизонтальный
			если (я.isHorizontal()) {
				titleX = left + ((right - left) / 2); // середина ширины
				titleY = верх + смещение;
				максШирина = справа - слева;
			} еще {
				titleX = opts.position === 'left' ? left + offset : right - offset;
				titleY = верх + ((низ - верх) / 2);
				maxWidth = низ - верх;
				вращение = Матем.ПИ * (опц.позиция === 'влево' ? -0,5 : 0,5);
			}

			ctx.сохранить();
			ctx.translate(titleX, titleY);
			ctx.rotate(вращение);
			ctx.textAlign = 'центр';
			ctx.textBaseline = 'средний';

			var text = opts.text;
			если (helpers.isArray(текст)) {
				переменная у = 0;
				для (var i = 0; i < text.length; ++i) {
					ctx.fillText(текст[i], 0, y, maxWidth);
					y += lineHeight;
				}
			} еще {
				ctx.fillText(текст, 0, 0, maxWidth);
			}

			ctx.восстановить();
		}
	}
});

функция createNewTitleBlockAndAttach(chart, titleOpts) {
	переменная title = новый заголовок({
		ctx: диаграмма.ctx,
		параметры: titleOpts,
		диаграмма: диаграмма
	});

	layouts.configure(диаграмма, заголовок, titleOpts);
	layouts.addBox(диаграмма, заголовок);
	chart.titleBlock = заголовок;
}

модуль.экспорты = {
	идентификатор: 'название',

	/**
	 * Обратная совместимость: начиная с версии 2.1.5, заголовок зарегистрирован как плагин, что делает
	 * Chart.Title устарел. Чтобы избежать критических изменений, мы экспортируем Title как часть
	 * плагин, который будет повторно представлен в файле chart.js.
	 * https://github.com/chartjs/Chart.js/pull/2640
	 * @частный
	 */
	_элемент: Заголовок,

	beforeInit: функция(диаграмма) {
		var titleOpts = chart.options.title;

		если (titleOpts) {
			createNewTitleBlockAndAttach(chart, titleOpts);
		}
	},

	beforeUpdate: функция(диаграмма) {
		var titleOpts = chart.options.title;
		вар titleBlock =chart.titleBlock;

		если (titleOpts) {
			helpers.mergeIf(titleOpts, defaults.global.title);

			если (titleBlock) {
				layouts.configure(chart, titleBlock, titleOpts);
				titleBlock.options = titleOpts;
			} еще {
				createNewTitleBlockAndAttach(chart, titleOpts);
			}
		} иначе если (titleBlock) {
			layouts.removeBox(диаграмма, заголовокBlock);
			удалить блок заголовка диаграммы;
		}
	}
};

},{"25":25,"26":26,"30":30,"45":45}],53:[function(require,module,exports){
«использовать строго»;

модуль.экспорты = функция(Диаграмма) {

	// Конфигурация по умолчанию для шкалы категорий
	var defaultConfig = {
		позиция: «внизу»
	};

	var DatasetScale = Chart.Scale.extend({
		/**
		* Внутренняя функция для получения правильных меток. Если определены data.xLabels или data.yLabels, используйте их
		* в противном случае вернуться к data.labels
		* @частный
		*/
		получитьМетки: функция() {
			var data = this.chart.data;
			вернуть this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
		},

		defineDataLimits: функция() {
			var me = это;
			var labels = me.getLabels();
			я.минИндекс = 0;
			me.maxIndex = labels.length - 1;
			var findIndex;

			если (me.options.ticks.min !== не определено) {
				// минимальное значение, указанное пользователем
				findIndex = labels.indexOf(me.options.ticks.min);
				me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
			}

			если (me.options.ticks.max !== не определено) {
				// максимальное значение, указанное пользователем
				findIndex = labels.indexOf(me.options.ticks.max);
				me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
			}

			me.min = labels[me.minIndex];
			я.макс = метки[я.максИндекс];
		},

		buildTicks: функция() {
			var me = это;
			var labels = me.getLabels();
			// Если мы просматриваем некоторое подмножество меток, разрежем исходный массив
			me.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
		},

		getLabelForIndex: функция(индекс, datasetIndex) {
			var me = это;
			var data = me.chart.data;
			вар isHorizontal = me.isHorizontal();

			если (data.yLabels && !isHorizontal) {
				вернуть меня.getRightValue(data.datasets[datasetIndex].data[index]);
			}
			вернуть me.ticks[index - me.minIndex];
		},

		// Используется для получения местоположений значений данных. Значение может быть индексом или числовым значением
		getPixelForValue: функция(значение, индекс) {
			var me = это;
			вар смещение = me.options.offset;
			// 1 добавляется, потому что нам нужна длина, но у нас есть индексы
			var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (смещение ? 0 : 1)), 1);

			// Если значение — это объект данных, то индекс — это индекс в массиве данных,
			// не индекс шкалы. Нам нужно это изменить.
			var valueCategory;
			если (значение !== неопределено && значение !== null) {
				valueCategory = me.isHorizontal() ? value.x : value.y;
			}
			если (valueCategory !== undefined || (value !== undefined && isNaN(index))) {
				var labels = me.getLabels();
				значение = значениеКатегория || значение;
				var idx = labels.indexOf(значение);
				индекс = idx !== -1 ? idx : индекс;
			}

			если (я.isHorizontal()) {
				var valueWidth = me.width / offsetAmt;
				var widthOffset = (valueWidth * (index - me.minIndex));

				если (смещение) {
					widthOffset += (значениеШирина / 2);
				}

				вернуть меня.left + Math.round(widthOffset);
			}
			var valueHeight = me.height / offsetAmt;
			var heightOffset = (valueHeight * (index - me.minIndex));

			если (смещение) {
				высотаСмещение += (значениеВысота / 2);
			}

			вернуть меня.top + Math.round(heightOffset);
		},
		getPixelForTick: функция(индекс) {
			вернуть this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
		},
		получитьЗначениеДляПикселя: функция(пиксель) {
			var me = это;
			вар смещение = me.options.offset;
			значение переменной;
			var offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
			var horz = me.isHorizontal();
			var valueDimension = (горизонт ? моя.ширина : моя.высота) / offsetAmt;

			пиксель -= горизонт ? я.слева : я.сверху;

			если (смещение) {
				пиксель -= (значениеРазмер / 2);
			}

			если (пиксель <= 0) {
				значение = 0;
			} еще {
				значение = Math.round(пиксель / значениеРазмер);
			}

			возвращаемое значение + me.minIndex;
		},
		получитьBasePixel: функция() {
			вернуть это.bottom;
		}
	});

	Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);

};

},{}],54:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
var helpers = require(45);
var Такты = require(34);

модуль.экспорты = функция(Диаграмма) {

	var defaultConfig = {
		позиция: «слева»,
		тики: {
			обратный вызов: Ticks.formatters.linear
		}
	};

	var ЛинейнаяШкала = Диаграмма.ОсноваЛинейнойШкалы.расширить({

		defineDataLimits: функция() {
			var me = это;
			var opts = me.options;
			var chart = я.диаграмма;
			var data = chart.data;
			var datasets = данные.datasets;
			вар isHorizontal = me.isHorizontal();
			var DEFAULT_MIN = 0;
			переменная DEFAULT_MAX = 1;

			функция IDMatches(мета) {
				return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
			}

			// Сначала вычисляем диапазон
			я.мин = ноль;
			я.макс = ноль;

			var hasStacks = opts.stacked;
			если (hasStacks === не определено) {
				helpers.each(наборы данных, функция(набор данных, индекс набора данных) {
					если (имеетСтеки) {
						возвращаться;
					}

					вар мета =chart.getDatasetMeta(datasetIndex);
					если (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
						мета.стек !== неопределено) {
						hasStacks = правда;
					}
				});
			}

			если (opts.stacked || hasStacks) {
				var значенияPerStack = {};

				helpers.each(наборы данных, функция(набор данных, индекс набора данных) {
					вар мета =chart.getDatasetMeta(datasetIndex);
					переменная ключ = [
						мета.тип,
						// у нас есть отдельный стек для наборов данных stack=undefined, когда opts.stacked не определен
						((opts.stacked === не определено && meta.stack === не определено) ? datasetIndex : ''),
						мета.стек
					].присоединиться('.');

					если (valuesPerStack[ключ] === не определено) {
						значенияPerStack[ключ] = {
							положительныеЗначения: [],
							ОтрицательныеЗначения: []
						};
					}

					// Сохраняем их по типу
					var positiveValues ​​= значенияВСтеке[ключ].positiveValues;
					var negativeValues ​​= значенияВСтеке[ключ].отрицательныеЗначения;

					если (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						помощники.каждый(набор данных.данные, функция(rawValue, индекс) {
							значение var = +me.getRightValue(rawValue);
							если (isNaN(значение) || meta.data[индекс].hidden) {
								возвращаться;
							}

							positiveValues[индекс] = positiveValues[индекс] || 0;
							отрицательныеЗначения[индекс] = отрицательныеЗначения[индекс] || 0;

							если (opts.relativePoints) {
								положительныеЗначения[индекс] = 100;
							} иначе если (значение < 0) {
								negativeValues[индекс] += значение;
							} еще {
								positiveValues[индекс] += значение;
							}
						});
					}
				});

				помощники.каждый(значенияПоСтеку, функция(значенияДляТипа) {
					var значения = значенияДляТипа.положительныеЗначения.concat(значенияДляТипа.отрицательныеЗначения);
					вар minVal = helpers.min(значения);
					var maxVal = helpers.max(значения);
					me.min = me.min === ноль? minVal : Math.min(me.min, minVal);
					я.макс = я.макс === null ? maxVal : Math.макс(я.макс, maxVal);
				});

			} еще {
				helpers.each(наборы данных, функция(набор данных, индекс набора данных) {
					вар мета =chart.getDatasetMeta(datasetIndex);
					если (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						помощники.каждый(набор данных.данные, функция(rawValue, индекс) {
							значение var = +me.getRightValue(rawValue);
							если (isNaN(значение) || meta.data[индекс].hidden) {
								возвращаться;
							}

							если (я.мин === null) {
								me.min = значение;
							} иначе если (значение < me.min) {
								me.min = значение;
							}

							если (я.макс === null) {
								я.макс = значение;
							} иначе если (значение > me.max) {
								я.макс = значение;
							}
						});
					}
				});
			}

			me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
			я.макс = isFinite(я.макс) && !isNaN(я.макс) ? я.макс : DEFAULT_MAX;

			// Общая базовая реализация для обработки ticks.min, ticks.max, ticks.beginAtZero
			this.handleTickRangeOptions();
		},
		getTickLimit: функция() {
			var maxTicks;
			var me = это;
			var tickOpts = me.options.ticks;

			если (я.isHorizontal()) {
				maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
			} еще {
				// Коэффициент 2, используемый для масштабирования размера шрифта, был определен экспериментально.
				var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
				maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
			}

			вернуть максТики;
		},
		// Вызывается после построения тактов. Нам нужно
		handleDirectionalChanges: функция() {
			если (!this.isHorizontal()) {
				// Мы находимся в вертикальной ориентации. Верхнее значение — самое высокое. Поэтому переворачиваем массив
				этот.тик.реверс();
			}
		},
		getLabelForIndex: функция(индекс, datasetIndex) {
			вернуть +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		// Утилиты
		getPixelForValue: функция(значение) {
			// Это должно быть вызвано после запуска fit, чтобы
			// this.left, this.top, this.right и this.bottom были определены
			var me = это;
			var start = я.start;

			вар rightValue = +me.getRightValue(значение);
			вар пиксель;
			var range = me.end - start;

			если (я.isHorizontal()) {
				пиксель = me.left + (me.width / range * (rightValue - start));
			} еще {
				пиксель = я.низ - (я.высота / диапазон * (rightValue - начало));
			}
			возврат пикселя;
		},
		получитьЗначениеДляПикселя: функция(пиксель) {
			var me = это;
			вар isHorizontal = me.isHorizontal();
			var innerDimension = isHorizontal ? моя.ширина : моя.высота;
			var offset = (isHorizontal ? пиксель - me.left : me.bottom - пиксель) / innerDimension;
			вернуть меня.начало + ((меня.конец - меня.начало) * смещение);
		},
		getPixelForTick: функция(индекс) {
			вернуть this.getPixelForValue(this.ticksAsNumbers[index]);
		}
	});
	Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);

};

},{"25":25,"34":34,"45":45}],55:[function(require,module,exports){
«использовать строго»;

var helpers = require(45);

/**
 * Сгенерировать набор линейных отметок
 * @param generationOptions параметры, используемые для генерации тиков
 * @param dataRange диапазон данных
 * @returns {Array<Number>} массив значений тиков
 */
функция generateTicks(generationOptions, dataRange) {
	var тики = [];
	// Чтобы получить «хорошее» значение для интервала между делениями, мы будем использовать соответствующим образом названное
	// Алгоритм "хорошего числа". См. http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
	// для получения подробной информации.

	интервал переменных;
	если (generationOptions.stepSize && generationOptions.stepSize > 0) {
		интервал = generationOptions.stepSize;
	} еще {
		вар niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
		интервал = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
	}
	var niceMin = Math.floor(dataRange.min / spacing) * интервал;
	var niceMax = Math.ceil(dataRange.max / интервал) * интервал;

	// Если заданы min, max и stepSize и они создают равномерно распределенную шкалу, используйте ее.
	если (generationOptions.min && generationOptions.max && generationOptions.stepSize) {
		// Если число очень близко к нашему целому, используем его.
		если (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, интервал / 1000)) {
			niceMin = generationOptions.min;
			niceMax = generationOptions.max;
		}
	}

	var numSpaces = (niceMax - niceMin) / интервал;
	// Если значение очень близко к округленному, используем его.
	если (helpers.almostEquals(numSpaces, Math.round(numSpaces), интервал / 1000)) {
		numSpaces = Math.round(numSpaces);
	} еще {
		numSpaces = Math.ceil(numSpaces);
	}

	точность переменной = 1;
	если (интервал < 1) {
		точность = Math.pow(10, spacing.toString().length - 2);
		niceMin = Math.round(niceMin * точность) / точность;
		niceMax = Math.round(niceMax * точность) / точность;
	}
	ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
	для (var j = 1; j < numSpaces; ++j) {
		ticks.push(Math.round((niceMin + j * интервал) * точность) / точность);
	}
	ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);

	возврат клещей;
}


модуль.экспорты = функция(Диаграмма) {

	var noop = helpers.noop;

	Chart.LinearScaleBase = Chart.Scale.extend({
		getRightValue: функция (значение) {
			если (тип значения === 'строка') {
				вернуть +значение;
			}
			вернуть Chart.Scale.prototype.getRightValue.call(this, value);
		},

		handleTickRangeOptions: функция() {
			var me = это;
			var opts = me.options;
			var tickOpts = opts.ticks;

			// Если мы принудительно начинаем с 0, но 0 уже будет отображен на графике,
			// ничего не делать, так как это сделает диаграмму странной. Если пользователь действительно хочет странную диаграмму
			// ось, они могут вручную переопределить ее
			если (tickOpts.beginAtZero) {
				вар minSign = helpers.sign(me.min);
				var maxSign = helpers.sign(me.max);

				если (минЗнак < 0 && максЗнак < 0) {
					// переместить верхнюю часть на 0
					я.макс = 0;
				} иначе если (minSign > 0 && maxSign > 0) {
					// переместить нижнюю часть вниз на 0
					я.мин = 0;
				}
			}

			var setMin =ickOpts.min !== не определено || TicketOpts.suggestedMin !== не определено;
			var setMax = tickOpts.max !== не определено || tickOpts.suggestedMax !== не определено;

			если (tickOpts.min !== не определено) {
				me.min = tickOpts.min;
			} иначе если (tickOpts.suggestedMin !== не определено) {
				если (я.мин === null) {
					me.min = tickOpts.suggestedMin;
				} еще {
					я.мин = Math.мин(я.мин, tickOpts.suggestedMin);
				}
			}

			если (tickOpts.max !== не определено) {
				я.макс = tickOpts.макс;
			} иначе если (tickOpts.suggestedMax !== не определено) {
				если (я.макс === null) {
					me.max = tickOpts.suggestedMax;
				} еще {
					я.макс = Math.макс(я.макс, tickOpts.suggestedMax);
				}
			}

			если (установитьМин!==установитьМакс) {
				// Мы устанавливаем минимум или максимум, но не оба одновременно.
				// Поэтому убедитесь, что наш ассортимент хорош
				// Инвертированный или нулевой диапазон длины может возникнуть, когда
				// ticks.min установлен, и наборы данных не видны
				если (я.мин >= я.макс) {
					если (установитьМин) {
						я.макс = я.мин + 1;
					} еще {
						я.мин = я.макс - 1;
					}
				}
			}

			если (я.мин === я.макс) {
				я.макс++;

				если (!tickOpts.beginAtZero) {
					я.мин--;
				}
			}
		},
		getTickLimit: нуп,
		handleDirectionalChanges: нуп,

		buildTicks: функция() {
			var me = это;
			var opts = me.options;
			var tickOpts = opts.ticks;

			// Выясняем, какое максимальное количество тиков мы можем поддерживать, исходя из размера
			// область оси. На данный момент мы говорим, что минимальный интервал между делениями в пикселях должен быть 50
			// Мы также ограничиваем максимальное количество тактов до 11, что дает 10 хороших квадратов на
			// график. Убедитесь, что у нас всегда есть не менее 2 тиков
			вар maxTicks = me.getTickLimit();
			maxTicks = Math.max(2, maxTicks);

			вар numericGeneratorOptions = {
				максТики: максТики,
				мин: tickOpts.min,
				макс: tickOpts.макс,
				stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
			};
			var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);

			я.handleDirectionalChanges();

			// На этом этапе нам нужно обновить наши максимальные и минимальные значения с учетом значений тиков, поскольку мы расширили
			// диапазон шкалы
			я.макс = помощники.макс(тики);
			я.мин = помощники.мин(тики);

			если (tickOpts.reverse) {
				тики.реверс();

				я.старт = я.макс;
				я.конец = я.мин;
			} еще {
				я.старт = я.мин;
				я.конец = я.макс;
			}
		},
		convertTicksToLabels: функция() {
			var me = это;
			я.тикиКакЧисла = я.тики.срез();
			я.zeroLineIndex = я.ticks.indexOf(0);

			Chart.Scale.prototype.convertTicksToLabels.call(me);
		}
	});
};

},{"45":45}],56:[function(require,module,exports){
«использовать строго»;

var helpers = require(45);
var Такты = require(34);

/**
 * Сгенерировать набор логарифмических отметок
 * @param generationOptions параметры, используемые для генерации тиков
 * @param dataRange диапазон данных
 * @returns {Array<Number>} массив значений тиков
 */
функция generateTicks(generationOptions, dataRange) {
	var тики = [];
	var значениеИлиПоУмолчанию = помощники.значениеИлиПоУмолчанию;

	// Выясняем, какое максимальное количество тиков мы можем поддерживать, исходя из размера
	// область оси. На данный момент мы говорим, что минимальный интервал между делениями в пикселях должен быть 50
	// Мы также ограничиваем максимальное количество тактов до 11, что дает 10 хороших квадратов на
	// график
	var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));

	var endExp = Math.floor(helpers.log10(dataRange.max));
	var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
	var exp, мантисса;

	если (tickVal === 0) {
		exp = Math.floor(helpers.log10(dataRange.minNotZero));
		значащая часть = Math.floor(dataRange.minNotZero / Math.pow(10, exp));

		тики.push(tickVal);
		tickVal = значащая часть * Math.pow(10, exp);
	} еще {
		exp = Math.floor(helpers.log10(tickVal));
		значащая часть = Math.floor(tickVal / Math.pow(10, exp));
	}
	точность переменной = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

	делать {
		тики.push(tickVal);

		++значащая часть;
		если (значимая часть === 10) {
			значащая часть = 1;
			++exp;
			точность = exp >= 0 ? 1 : точность;
		}

		tickVal = Math.round(значимая часть * Math.pow(10, exp) * точность) / точность;
	} while (exp < endExp || (exp === endExp && Significand < endSignificand));

	var lastTick = valueOrDefault(generationOptions.max, tickVal);
	тики.push(lastTick);

	возврат клещей;
}


модуль.экспорты = функция(Диаграмма) {

	var defaultConfig = {
		позиция: «слева»,

		// настройки метки
		тики: {
			обратный вызов: Ticks.formatters.logarithmic
		}
	};

	var LogarithmicScale = Chart.Scale.extend({
		defineDataLimits: функция() {
			var me = это;
			var opts = me.options;
			var chart = я.диаграмма;
			var data = chart.data;
			var datasets = данные.datasets;
			вар isHorizontal = me.isHorizontal();
			функция IDMatches(мета) {
				return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
			}

			// Рассчитать диапазон
			я.мин = ноль;
			я.макс = ноль;
			я.minNotZero = null;

			var hasStacks = opts.stacked;
			если (hasStacks === не определено) {
				helpers.each(наборы данных, функция(набор данных, индекс набора данных) {
					если (имеетСтеки) {
						возвращаться;
					}

					вар мета =chart.getDatasetMeta(datasetIndex);
					если (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
						мета.стек !== неопределено) {
						hasStacks = правда;
					}
				});
			}

			если (opts.stacked || hasStacks) {
				var значенияPerStack = {};

				helpers.each(наборы данных, функция(набор данных, индекс набора данных) {
					вар мета =chart.getDatasetMeta(datasetIndex);
					переменная ключ = [
						мета.тип,
						// у нас есть отдельный стек для наборов данных stack=undefined, когда opts.stacked не определен
						((opts.stacked === не определено && meta.stack === не определено) ? datasetIndex : ''),
						мета.стек
					].присоединиться('.');

					если (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						если (valuesPerStack[ключ] === не определено) {
							значенияPerStack[ключ] = [];
						}

						помощники.каждый(набор данных.данные, функция(rawValue, индекс) {
							var значения = значенияPerStack[ключ];
							значение var = +me.getRightValue(rawValue);
							// недействительные, скрытые и отрицательные значения игнорируются
							если (isNaN(значение) || meta.data[индекс].hidden || значение < 0) {
								возвращаться;
							}
							значения[индекс] = значения[индекс] || 0;
							значения[индекс] += значение;
						});
					}
				});

				помощники.каждый(значенияПоСтеку, функция(значенияДляТипа) {
					если (значенияДляТипа.длина > 0) {
						вар minVal = helpers.min(valuesForType);
						var maxVal = helpers.max(valuesForType);
						me.min = me.min === ноль? minVal : Math.min(me.min, minVal);
						я.макс = я.макс === null ? maxVal : Math.макс(я.макс, maxVal);
					}
				});

			} еще {
				helpers.each(наборы данных, функция(набор данных, индекс набора данных) {
					вар мета =chart.getDatasetMeta(datasetIndex);
					если (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
						помощники.каждый(набор данных.данные, функция(rawValue, индекс) {
							значение var = +me.getRightValue(rawValue);
							// недействительные, скрытые и отрицательные значения игнорируются
							если (isNaN(значение) || meta.data[индекс].hidden || значение < 0) {
								возвращаться;
							}

							если (я.мин === null) {
								me.min = значение;
							} иначе если (значение < me.min) {
								me.min = значение;
							}

							если (я.макс === null) {
								я.макс = значение;
							} иначе если (значение > me.max) {
								я.макс = значение;
							}

							если (значение !== 0 && (me.minNotZero === null || значение < me.minNotZero)) {
								me.minNotZero = значение;
							}
						});
					}
				});
			}

			// Общая базовая реализация для обработки ticks.min, ticks.max
			this.handleTickRangeOptions();
		},
		handleTickRangeOptions: функция() {
			var me = это;
			var opts = me.options;
			var tickOpts = opts.ticks;
			var значениеИлиПоУмолчанию = помощники.значениеИлиПоУмолчанию;
			var DEFAULT_MIN = 1;
			переменная DEFAULT_MAX = 10;

			me.min = valueOrDefault(tickOpts.min, me.min);
			me.max = valueOrDefault(tickOpts.max, me.max);

			если (я.мин === я.макс) {
				если (я.мин !== 0 && я.мин !== null) {
					я.мин = Math.pow(10, Math.floor(helpers.log10(я.мин)) - 1);
					я.макс = Math.pow(10, Math.floor(helpers.log10(я.макс)) + 1);
				} еще {
					me.min = DEFAULT_MIN;
					я.макс = DEFAULT_MAX;
				}
			}
			если (я.мин === null) {
				я.мин = Math.pow(10, Math.floor(helpers.log10(я.макс)) - 1);
			}
			если (я.макс === null) {
				я.макс = я.мин !== 0
					? Math.pow(10, Math.floor(helpers.log10(me.min)) + 1)
					: DEFAULT_MAX;
			}
			если (me.minNotZero === null) {
				если (я.мин > 0) {
					я.минНеНоль = я.мин;
				} иначе если (я.макс < 1) {
					me.minNotZero = Math.pow(10, Math.floor(helpers.log10(me.max)));
				} еще {
					me.minNotZero = DEFAULT_MIN;
				}
			}
		},
		buildTicks: функция() {
			var me = это;
			var opts = me.options;
			var tickOpts = opts.ticks;
			вар реверс = !me.isHorizontal();

			var generationOptions = {
				мин: tickOpts.min,
				макс: tickOpts.макс
			};
			var ticks = me.ticks = generateTicks(generationOptions, me);

			// На этом этапе нам нужно обновить наши максимальные и минимальные значения с учетом значений тиков, поскольку мы расширили
			// диапазон шкалы
			я.макс = помощники.макс(тики);
			я.мин = помощники.мин(тики);

			если (tickOpts.reverse) {
				обратный = !обратный;
				я.старт = я.макс;
				я.конец = я.мин;
			} еще {
				я.старт = я.мин;
				я.конец = я.макс;
			}
			если (обратный) {
				тики.реверс();
			}
		},
		convertTicksToLabels: функция() {
			this.tickValues ​​= this.ticks.slice();

			Chart.Scale.prototype.convertTicksToLabels.call(this);
		},
		// Получить правильную подсказку
		getLabelForIndex: функция(индекс, datasetIndex) {
			вернуть +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		getPixelForTick: функция(индекс) {
			вернуть this.getPixelForValue(this.tickValues[index]);
		},
		/**
		 * Возвращает значение первого тика.
		 * @param {Number} value — минимальное ненулевое значение.
		 * @return {Number} Значение первого тика.
		 * @частный
		 */
		_getFirstTickValue: функция(значение) {
			var exp = Math.floor(helpers.log10(value));
			var significand = Math.floor(value / Math.pow(10, exp));

			вернуть мантиссу * Math.pow(10, exp);
		},
		getPixelForValue: функция(значение) {
			var me = это;
			var reverse = me.options.ticks.reverse;
			var log10 = helpers.log10;
			var firstTickValue = me._getFirstTickValue(me.minNotZero);
			переменная offset = 0;
			varinnerDimension, пиксель, начало, конец, знак;

			значение = +me.getRightValue(значение);
			если (обратный) {
				начало = я.конец;
				конец = я.начало;
				знак = -1;
			} еще {
				начать = я.начать;
				конец = я.конец;
				знак = 1;
			}
			если (я.isHorizontal()) {
				внутреннийРазмер = я.ширина;
				пиксель = обратный ? я.право : я.лево;
			} еще {
				внутреннийРазмер = я.высота;
				знак *= -1; // инвертируем, так как верхний левый угол холста находится в пикселе (0, 0)
				пиксель = обратный ? я.верх : я.низ;
			}
			если (значение !== начало) {
				если (start === 0) { // включить нулевой тик
					смещение = helpers.getValueOrDefault(
						me.options.ticks.fontSize,
						Chart.defaults.global.defaultFontSize
					);
					внутреннееРазмер -= смещение;
					начало = firstTickValue;
				}
				если (значение !== 0) {
					смещение += innerDimension / (log10(конец) - log10(начало)) * (log10(значение) - log10(начало));
				}
				пиксель += знак * смещение;
			}
			возврат пикселя;
		},
		получитьЗначениеДляПикселя: функция(пиксель) {
			var me = это;
			var reverse = me.options.ticks.reverse;
			var log10 = helpers.log10;
			var firstTickValue = me._getFirstTickValue(me.minNotZero);
			вар InnerDimension, начало, конец, значение;

			если (обратный) {
				начало = я.конец;
				конец = я.начало;
			} еще {
				начать = я.начать;
				конец = я.конец;
			}
			если (я.isHorizontal()) {
				внутреннийРазмер = я.ширина;
				значение = обратное ? я.право - пиксель : пиксель - я.лево;
			} еще {
				внутреннийРазмер = я.высота;
				значение = обратное ? пиксель - я.верх : я.низ - пиксель;
			}
			если (значение !== начало) {
				если (start === 0) { // включить нулевой тик
					var смещение = helpers.getValueOrDefault(
						me.options.ticks.fontSize,
						Chart.defaults.global.defaultFontSize
					);
					значение -= смещение;
					внутреннееРазмер -= смещение;
					начало = firstTickValue;
				}
				значение *= log10(конец) - log10(начало);
				значение /= внутреннееРазмер;
				значение = Math.pow(10, log10(start) + значение);
			}
			возвращаемое значение;
		}
	});
	Chart.scaleService.registerScaleType('логарифмический', LogarithmicScale, defaultConfig);

};

},{"34":34,"45":45}],57:[function(require,module,exports){
«использовать строго»;

переменные по умолчанию = require(25);
var helpers = require(45);
var Такты = require(34);

модуль.экспорты = функция(Диаграмма) {

	var globalDefaults = defaults.global;

	var defaultConfig = {
		дисплей: правда,

		// Boolean - Анимировать ли масштабирование диаграммы от центра
		анимация: правда,
		позиция: 'chartArea',

		Угловые линии: {
			дисплей: правда,
			цвет: 'rgba(0, 0, 0, 0.1)',
			Ширина линии: 1
		},

		Линии сетки: {
			циркуляр: ложный
		},

		// настройки метки
		тики: {
			// Boolean — показать фон для метки шкалы
			showLabelBackdrop: правда,

			// Строка - Цвет фона этикетки
			Цвет фона: 'rgba(255,255,255,0.75)',

			// Число — отступ фона над и под меткой в ​​пикселях
			backdropPaddingY: 2,

			// Число — отступ фона сбоку от метки в пикселях
			backdropPaddingX: 2,

			обратный вызов: Ticks.formatters.linear
		},

		pointМетки: {
			// Логическое значение — если true, показать метки точек
			дисплей: правда,

			// Число - Размер шрифта метки точки в пикселях
			Размер шрифта: 10,

			// Функция - используется для преобразования меток точек
			обратный вызов: функция(метка) {
				этикетка возврата;
			}
		}
	};

	функция getValueCount(масштаб) {
		var opts = scale.options;
		вернуть opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
	}

	функция getPointLabelFontOptions(масштаб) {
		var pointLabelOptions = scale.options.pointLabels;
		var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
		var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
		var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
		var font = helpers.fontString(fontSize, fontStyle, fontFamily);

		возвращаться {
			размер: размер шрифта,
			стиль: fontStyle,
			семейство: fontFamily,
			шрифт: шрифт
		};
	}

	функция measureLabelSize(ctx, fontSize, label) {
		если (helpers.isArray(метка)) {
			возвращаться {
				w: helpers.longestText(ctx, ctx.font, label),
				h: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)
			};
		}

		возвращаться {
			w: ctx.measureText(метка).ширина,
			h: размер шрифта
		};
	}

	функция determineLimits(угол, поз., размер, мин., макс.) {
		если (угол === мин || угол === макс) {
			возвращаться {
				начало: поз - (размер / 2),
				конец: поз. + (размер / 2)
			};
		} иначе если (угол < мин || угол > макс) {
			возвращаться {
				начало: поз. - размер - 5,
				конец: поз.
			};
		}

		возвращаться {
			начало: поз,
			конец: поз. + размер + 5
		};
	}

	/**
	 * Вспомогательная функция для подгонки радиальной линейной шкалы под метками точек
	 */
	функция fitWithPointLabels(масштаб) {
		/*
		 * Да, это действительно сбивает с толку, и здесь много математики.
		 * Суть проблемы здесь: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
		 *
		 * Реакция: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
		 *
		 * Решение:
		 *
		 * Сначала мы предполагаем, что радиус многоугольника равен половине размера холста.
		 * в каждом индексе мы проверяем, перекрывается ли текст.
		 *
		 * Там, где это необходимо, мы сохраняем этот угол и этот индекс.
		 *
		 * После нахождения наибольшего индекса и угла мы вычисляем, сколько нам нужно удалить
		 * от радиуса формы, чтобы переместить точку внутрь на эту величину x.
		 *
		 * Мы усредняем левое и правое расстояния, чтобы получить максимальный радиус формы, который может поместиться в коробку.
		 * вместе с этикетками.
		 *
		 * После этого мы можем найти центральную точку диаграммы, взяв выступ текста по оси x
		 * с каждой стороны, вычтя это из размера, уменьшив его вдвое и добавив ширину выступа слева x.
		 *
		 * Это будет означать, что у нас есть фигура, подогнана к холсту, настолько большая, насколько это возможно с метками.
		 * и расположите его наиболее эффективно с точки зрения пространства
		 *
		 * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
		 */

		вар plFont = getPointLabelFontOptions (масштаб);

		// Получить максимальный радиус многоугольника. Либо половина высоты (минус ширина текста), либо половина ширины.
		// Используйте это для расчета смещения + изменения. - Убедитесь, что выступ слева/справа не менее 0, чтобы избежать проблем с центральными точками
		var largestPossibleRadius = Math.min(масштаб.высота / 2, масштаб.ширина / 2);
		var farthestLimits = {
			r: масштаб.ширина,
			л: 0,
			t: масштаб.высота,
			б: 0
		};
		var furthestAngles = {};
		вар я, textSize, pointPosition;

		масштаб.ctx.шрифт = plFont.шрифт;
		масштаб._pointLabelSizes = [];

		вар valueCount = getValueCount (масштаб);
		для (i = 0; i < valueCount; i++) {
			pointPosition = scale.getPointPosition(i, largestPossibleRadius);
			textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
			масштаб._pointLabelSizes[i] = textSize;

			// Добавьте четверть круга, чтобы сделать градус 0 средним значением вершины круга
			var angleRadians = scale.getIndexAngle(i);
			var angle = helpers.toDegrees(angleRadians) % 360;
			var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
			var vLimits = defineLimits(angle, pointPosition.y, textSize.h, 90, 270);

			если (hLimits.start < farthestLimits.l) {
				farthestLimits.l = hLimits.start;
				farthestAngles.l = уголРадианы;
			}

			если (hLimits.end > furthestLimits.r) {
				farthestLimits.r = hLimits.end;
				farthestAngles.r = уголРадианы;
			}

			если (vLimits.start < farthestLimits.t) {
				farthestLimits.t = vLimits.start;
				farthestAngles.t = уголРадианы;
			}

			если (vLimits.end > furthestLimits.b) {
				farthestLimits.b = vLimits.end;
				farthestAngles.b = уголРадианы;
			}
		}

		scale.setReductions(largestPossibleRadius, farthestLimits, farthestAngles);
	}

	/**
	 * Вспомогательная функция для подгонки радиальной линейной шкалы без меток точек
	 */
	функция fit(масштаб) {
		var largestPossibleRadius = Math.min(масштаб.высота / 2, масштаб.ширина / 2);
		scale.drawingArea = Math.round(largestPossibleRadius);
		масштаб.setCenterPoint(0, 0, 0, 0);
	}

	функция getTextAlignForAngle(угол) {
		если (угол === 0 || угол === 180) {
			вернуть «центр»;
		} иначе если (угол < 180) {
			возврат «налево»;
		}

		вернуть «направо»;
	}

	функция fillText(ctx, текст, позиция, размер шрифта) {
		если (helpers.isArray(текст)) {
			var y = позиция.y;
			var интервал = 1,5 * fontSize;

			для (var i = 0; i < text.length; ++i) {
				ctx.fillText(текст[i], позиция.x, y);
				y += интервал;
			}
		} еще {
			ctx.fillText(текст, позиция.x, позиция.y);
		}
	}

	функция adjustPointPositionForLabelHeight(угол, размер текста, положение) {
		если (угол === 90 || угол === 270) {
			позиция.y -= (textSize.h / 2);
		} иначе если (угол > 270 || угол < 90) {
			позиция.y -= textSize.h;
		}
	}

	функция drawPointLabels(масштаб) {
		var ctx = масштаб.ctx;
		var opts = scale.options;
		var angleLineOpts = opts.angleLines;
		var pointLabelOpts = opts.pointLabels;

		ctx.lineWidth = angleLineOpts.lineWidth;
		ctx.strokeStyle = angleLineOpts.color;

		var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);

		// Шрифт метки точки
		вар plFont = getPointLabelFontOptions (масштаб);

		ctx.textBaseline = 'верх';

		для (var i = getValueCount(scale) - 1; i >= 0; i--) {
			если (angleLineOpts.display) {
				вар externalPosition = Scale.getPointPosition(i, externalDistance);
				ctx.beginPath();
				ctx.moveTo(масштаб.xCenter, масштаб.yCenter);
				ctx.lineTo(внешняяПозиция.x, внешняяПозиция.y);
				ctx.stroke();
				ctx.closePath();
			}

			если (pointLabelOpts.display) {
				// Дополнительные 3 пикселя для некоторого интервала между метками
				вар pointLabelPosition = Scale.getPointPosition(i, externalDistance + 5);

				// Сохраняем это в цикле, так как здесь мы можем поддерживать свойства массива
				var pointLabelFontColor = helpers.valueAtIndexOrDefault(pointLabelOpts.fontColor, i, globalDefaults.defaultFontColor);
				ctx.шрифт = plFont.шрифт;
				ctx.fillStyle = pointLabelFontColor;

				var angleRadians = scale.getIndexAngle(i);
				var angle = helpers.toDegrees(angleRadians);
				ctx.textAlign = getTextAlignForAngle(угол);
				adjustPointPositionForLabelHeight(угол, масштаб._pointLabelSizes[i], pointLabelPosition);
				fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
			}
		}
	}

	функция drawRadiusLine(масштаб, gridLineOpts, радиус, индекс) {
		var ctx = масштаб.ctx;
		ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
		ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);

		если (масштаб.опции.сеткаLines.круговая) {
			// Нарисуем дуги окружности между точками
			ctx.beginPath();
			ctx.arc(масштаб.xCenter, масштаб.yCenter, радиус, 0, Math.PI * 2);
			ctx.closePath();
			ctx.stroke();
		} еще {
			// Нарисуйте прямые линии, соединяющие каждый индекс
			вар valueCount = getValueCount (масштаб);

			если (valueCount === 0) {
				возвращаться;
			}

			ctx.beginPath();
			вар pointPosition = масштаб.getPointPosition(0, радиус);
			ctx.moveTo(pointPosition.x, pointPosition.y);

			для (var i = 1; i < valueCount; i++) {
				pointPosition = scale.getPointPosition(i, радиус);
				ctx.lineTo(pointPosition.x, pointPosition.y);
			}

			ctx.closePath();
			ctx.stroke();
		}
	}

	функция numberOrZero(параметр) {
		return helpers.isNumber(параметр) ? параметр : 0;
	}

	var ЛинейнаяРадиальнаяШкала = Диаграмма.ОсноваЛинейнойШкалы.расширить({
		setDimensions: функция() {
			var me = это;
			var opts = me.options;
			var tickOpts = opts.ticks;
			// Устанавливаем неограниченный размер перед поворотом метки
			я.ширина = я.максШирина;
			я.высота = я.максВысота;
			я.xCenter = Математическое.round(я.ширина / 2);
			я.yCenter = Math.round(я.высота / 2);

			var minSize = helpers.min([моя.высота, моя.ширина]);
			var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
			me.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);
		},
		defineDataLimits: функция() {
			var me = это;
			var chart = я.диаграмма;
			var min = Число.ПОЛОЖИТЕЛЬНАЯ_БЕСКОНЕЧНОСТЬ;
			var max = Число.ОТРИЦАТЕЛЬНАЯ_БЕСКОНЕЧНОСТЬ;

			helpers.each(chart.data.datasets, function(dataset, datasetIndex) {
				если (chart.isDatasetVisible(datasetIndex)) {
					вар мета =chart.getDatasetMeta(datasetIndex);

					помощники.каждый(набор данных.данные, функция(rawValue, индекс) {
						значение var = +me.getRightValue(rawValue);
						если (isNaN(значение) || meta.data[индекс].hidden) {
							возвращаться;
						}

						min = Math.min(значение, min);
						макс = Матем.макс(значение, макс);
					});
				}
			});

			me.min = (min === Число.ПОЛОЖИТЕЛЬНАЯ_БЕСКОНЕЧНОСТЬ ? 0 : min);
			я.макс = (макс === Число.ОТРИЦАТЕЛЬНАЯ_БЕСКОНЕЧНОСТЬ ? 0 : макс);

			// Общая базовая реализация для обработки ticks.min, ticks.max, ticks.beginAtZero
			я.handleTickRangeOptions();
		},
		getTickLimit: функция() {
			var tickOpts = this.options.ticks;
			var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
			вернуть Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
		},
		convertTicksToLabels: функция() {
			var me = это;

			Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);

			// Метки точек
			me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
		},
		getLabelForIndex: функция(индекс, datasetIndex) {
			вернуть +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
		},
		подходит: функция() {
			если (эти.опции.точкиМетки.отображение) {
				fitWithPointLabels(это);
			} еще {
				подходит(это);
			}
		},
		/**
		 * Установите уменьшение радиуса и определите новый радиус и центральную точку
		 * @частный
		 */
		setReductions: функция (самый большой возможный радиус, самые большие пределы, самые большие углы) {
			var me = это;
			var radiusReductionLeft = farthestLimits.l / Math.sin(furthestAngles.l);
			var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
			var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
			var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);

			radiusReductionLeft = numberOrZero(radiusReductionLeft);
			radiusReductionRight = numberOrZero(radiusReductionRight);
			radiusReductionTop = numberOrZero(radiusReductionTop);
			radiusReductionBottom = numberOrZero(radiusReductionBottom);

			я.рисунокПлощадь = Математика.мин(
				Math.round(самый большойвозможныйрадиус - (радиусСниженияЛевого+радиусСниженияПравого) / 2),
				Math.round(самый большойВозможныйРадиус - (радиусСниженияВерхнего+радиусСниженияНижнего) / 2));
			me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
		},
		setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
			var me = это;
			var maxRight = моя.ширина - правоеПеремещение - моя.ОбластьРисования;
			var maxLeft = leftMovement + me.drawingArea;
			вар maxTop = topMovement + me.drawingArea;
			var maxBottom = me.height - bottomMovement - me.drawingArea;

			я.xCenter = Math.round(((maxLeft + maxRight) / 2) + я.left);
			я.yCenter = Math.round(((maxTop + maxBottom) / 2) + я.top);
		},

		getIndexAngle: функция(индекс) {
			вар angularMultiplier = (Math.PI * 2) / getValueCount(this);
			var startAngle = this.chart.options && this.chart.options.startAngle ?
				this.chart.options.startAngle :
				0;

			вар startAngleRadians = startAngle * Math.PI * 2/360;

			// Начинаем сверху, а не справа, поэтому удаляем четверть круга
			возвращаемый индекс * angleMultiplier + startAngleRadians;
		},
		получитьРасстояниеОтЦентраДляЗначения: функция(значение) {
			var me = это;

			если (значение === null) {
				return 0; // null всегда в центре
			}

			// Учитываем половину размера шрифта + yPadding верхнего значения
			var scalingFactor = me.drawingArea / (me.max - me.min);
			если (я.опции.тики.обратный) {
				вернуть (me.max - значение) * scalingFactor;
			}
			возврат (значение - me.min) * scalingFactor;
		},
		getPointPosition: функция(индекс, расстояниеОтЦентра) {
			var me = это;
			var thisAngle = me.getIndexAngle(index) - (Math.PI / 2);
			возвращаться {
				x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
				y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
			};
		},
		getPointPositionForValue: функция(индекс, значение) {
			вернуть this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
		},

		получитьBasePosition: функция() {
			var me = это;
			var min = me.min;
			var max = me.max;

			верните меня.getPointPositionForValue(0,
				я.beginAtZero ? 0 :
				мин < 0 && макс < 0 ? макс :
				мин > 0 && макс > 0 ? мин :
				0);
		},

		рисовать: функция() {
			var me = это;
			var opts = me.options;
			var gridLineOpts = opts.gridLines;
			var tickOpts = opts.ticks;
			var значениеИлиПоУмолчанию = помощники.значениеИлиПоУмолчанию;

			если (opts.display) {
				var ctx = я.ctx;
				вар startAngle = this.getIndexAngle(0);

				// Шрифт для галочки
				var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
				var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
				var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
				вар TicketLabelFont = helpers.fontString(tickFontSize, TicketFontStyle, TicketFontFamily);

				helpers.each(me.ticks, function(label, index) {
					// Не рисовать центральное значение (если оно минимально)
					если (индекс > 0 || tickOpts.reverse) {
						var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);

						// Нарисуйте круговые линии вокруг шкалы
						если (gridLineOpts.display && index !== 0) {
							drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
						}

						если (tickOpts.display) {
							var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
							ctx.font = tickLabelFont;

							ctx.сохранить();
							ctx.translate(me.xCenter, me.yCenter);
							ctx.rotate(начальныйугол);

							если (tickOpts.showLabelBackdrop) {
								var labelWidth = ctx.measureText(label).width;
								ctx.fillStyle = tickOpts.backdropColor;
								ctx.fillRect(
									-labelWidth / 2 - tickOpts.backdropPaddingX,
									-yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,
									labelWidth + tickOpts.backdropPaddingX * 2,
									tickFontSize + tickOpts.backdropPaddingY * 2
								);
							}

							ctx.textAlign = 'центр';
							ctx.textBaseline = 'средний';
							ctx.fillStyle = tickFontColor;
							ctx.fillText(метка, 0, -yCenterOffset);
							ctx.восстановить();
						}
					}
				});

				если (opts.angleLines.display || opts.pointLabels.display) {
					drawPointLabels(я);
				}
			}
		}
	});
	Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);

};

},{"25":25,"34":34,"45":45}],58:[function(require,module,exports){
/* глобальное окно: ложь */
«использовать строго»;

переменная момент = require(1);
момент = тип момента === 'функция' ? момент : окно.момент;

переменные по умолчанию = require(25);
var helpers = require(45);

// Целочисленные константы взяты из спецификации ES6.
вар MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
var MAX_INTEGER = Число.MAX_SAFE_INTEGER || 9007199254740991;

вар ИНТЕРВАЛЫ = {
	миллисекунда: {
		общее: правда,
		размер: 1,
		шаги: [1, 2, 5, 10, 20, 50, 100, 250, 500]
	},
	второй: {
		общее: правда,
		размер: 1000,
		шаги: [1, 2, 5, 10, 30]
	},
	минута: {
		общее: правда,
		размер: 60000,
		шаги: [1, 2, 5, 10, 30]
	},
	час: {
		общее: правда,
		размер: 3600000,
		шаги: [1, 2, 3, 6, 12]
	},
	день: {
		общее: правда,
		размер: 86400000,
		шаги: [1, 2, 5]
	},
	неделя: {
		распространено: ложно,
		размер: 604800000,
		шаги: [1, 2, 3, 4]
	},
	месяц: {
		общее: правда,
		размер: 2.628e9,
		шаги: [1, 2, 3]
	},
	четверть: {
		распространено: ложно,
		размер: 7.884e9,
		шаги: [1, 2, 3, 4]
	},
	год: {
		общее: правда,
		размер: 3.154e10
	}
};

var UNITS = Object.keys(ИНТЕРВАЛЫ);

функция сортировщик(a, b) {
	возврат а - б;
}

функция arrayUnique(элементы) {
	var хэш = {};
	вар вых = [];
	вар i, илен, элемент;

	для (i = 0, ilen = items.length; i < ilen; ++i) {
		элемент = элементы[i];
		если (!хэш[элемент]) {
			хэш[элемент] = истина;
			out.push(элемент);
		}
	}

	вернуться;
}

/**
 * Возвращает массив объектов {time, pos}, используемых для интерполяции определенного `time` или позиции
 * (`pos`) на шкале, путем поиска записей до и после запрошенного значения. `pos` - это
 * десятичная дробь от 0 до 1: 0 — начало шкалы (левое или верхнее), а 1 — другое
 * крайность (левая + ширина или верхняя + высота). Обратите внимание, что было бы более оптимизировано напрямую
 * хранить предварительно вычисленные пиксели, но масштабные размеры не гарантируются в нужный нам момент времени
 * для создания таблицы поиска. Таблица ВСЕГДА содержит как минимум два элемента: min и max.
 *
 * @param {Number[]} временные метки — временные метки, отсортированные от наименьшего к наибольшему.
 * Распределение @param {String} — если «линейное», временные метки будут распределены линейно вдоль минимума
 * и максимальный диапазон, поэтому по сути таблица будет содержать только два элемента: {min, 0} и {max, 1}.
 * Если «серия», то временные метки будут располагаться на одинаковом расстоянии друг от друга. В этом
 * случае регистрируются только те временные метки, которые нарушают линейность времени, что означает, что в
 * в лучшем случае все временные метки линейны, таблица содержит только минимум и максимум.
 */
функция buildLookupTable(временные метки, мин, макс, распределение) {
	если (распределение === 'линейное' || !timestamps.length) {
		возвращаться [
			{время: мин, поз: 0},
			{время: макс, поз: 1}
		];
	}

	переменная таблица = [];
	var items = [мин];
	вар я, илен, предыдущая, текущая, следующая;

	для (i = 0, ilen = timestamps.length; i < ilen; ++i) {
		curr = временные метки[i];
		если (текущ > мин && текущ < макс) {
			items.push(curr);
		}
	}

	элементы.push(макс);

	для (i = 0, ilen = items.length; i < ilen; ++i) {
		следующий = элементы[i + 1];
		предыдущая = элементы[i - 1];
		curr = элементы[i];

		// добавляйте только те точки, которые нарушают линейность шкалы
		если (пред. === не определено || след. === не определено || Math.round((след. + пред.) / 2) !== curr) {
			table.push({время: текущ, полож: i / (илен - 1)});
		}
	}

	таблица возврата;
}

// @see адаптировано из http://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
функция поиска(таблица, ключ, значение) {
	var lo = 0;
	var hi = table.length - 1;
	вар середина, i0, i1;

	в то время как (ло >= 0 && ло <= привет) {
		средний = (низкий + высокий) >> 1;
		i0 = таблица[середина - 1] || null;
		i1 = таблица[середина];

		если (!i0) {
			// данное значение находится вне таблицы (перед первым элементом)
			возврат {lo: null, hi: i1};
		} иначе если (i1[ключ] < значение) {
			ло = середина + 1;
		} иначе если (i0[ключ] > значение) {
			привет = середина - 1;
		} еще {
			возврат {lo: i0, hi: i1};
		}
	}

	// данное значение находится за пределами таблицы (после последнего элемента)
	возврат {lo: i1, hi: null};
}

/**
 * Линейно интерполирует заданное исходное `value`, используя значения `skey` элементов таблицы и
 * возвращает связанное значение `tkey`. Например, interpolate(table, 'time', 42, 'pos')
 * возвращает позицию для временной метки, равной 42. Если значение выходит за пределы, значения в
 * для интерполяции используются индексы [0, 1] или [n - 1, n].
 */
функция интерполяции(таблица, skey, sval, tkey) {
	диапазон вар = поиск (таблица, skey, sval);

	// Примечание: таблица поиска ВСЕГДА содержит не менее 2 элементов (мин и макс)
	var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
	var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;

	var span = следующий[skey] - предыдущий[skey];
	соотношение вар = интервал? (sval - prev[skey])/span: 0;
	var offset = (next[tkey] - prev[tkey]) * ratio;

	вернуть prev[tkey] + смещение;
}

/**
 * Преобразовать заданное значение в объект момента, используя заданные параметры времени.
 * @см. http://momentjs.com/docs/#/parsing/
 */
функция momentify(значение, параметры) {
	var parser = параметры.parser;
	var format = options.parser || options.format;

	если (тип парсера === 'функция') {
		возврат парсера(значение);
	}

	если (typeof значение === 'строка' && typeof формат === 'строка') {
		момент возврата(значение, формат);
	}

	если (!(значение экземпляра момента)) {
		значение = момент(значение);
	}

	если (значение.isValid()) {
		возвращаемое значение;
	}

	// Метки имеют несовместимый формат момента, а `парсер` не предоставлен.
	// Пользователь по-прежнему может использовать устаревшую опцию `format` для преобразования своих входных данных.
	если (формат typeof === 'function') {
		формат возврата(значение);
	}

	возвращаемое значение;
}

функция разбора(вход, масштаб) {
	если (helpers.isNullOrUndef(вход)) {
		вернуть ноль;
	}

	var options = scale.options.time;
	var value = momentify(scale.getRightValue(input), options);
	если (!value.isValid()) {
		вернуть ноль;
	}

	если (опции.раунд) {
		значение.startOf(опции.раунд);
	}

	возвращаемое значение.valueOf();
}

/**
 * Возвращает количество пропущенных единиц, чтобы можно было отобразить до `capacity` числа тиков
 * в `единицах` для заданного диапазона `min` / `max` и с учетом ограничений по шагам интервала.
 */
функция determineStepSize(мин, макс, единица, емкость) {
	диапазон переменных = макс - мин;
	вар интервал = ИНТЕРВАЛЫ [единица измерения];
	var миллисекунды = интервал.размер;
	var шаги = интервал.шаги;
	var i, ilen, фактор;

	если (!шаги) {
		return Math.ceil(диапазон / (емкость * миллисекунды));
	}

	for (i = 0, ilen = Steps.length; i < ilen; ++i) {
		фактор = шаги[i];
		если (Math.ceil(диапазон / (миллисекунды * фактор)) <= емкость) {
			перерыв;
		}
	}

	коэффициент возврата;
}

/**
 * Выясняет, какая единица измерения приводит к соответствующему количеству автоматически сгенерированных тиков
 */
функция determineUnitForAutoTicks(minUnit, мин, макс, емкость) {
	var ilen = ЕДИНИЦЫ.длина;
	var i, интервал, фактор;

	для (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
		интервал = ИНТЕРВАЛЫ[ЕДИНИЦЫ[i]];
		фактор = интервал.шаги ? интервал.шаги[интервал.шагов.длина - 1] : MAX_INTEGER;

		если (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
			вернуть ЕДИНИЦЫ[i];
		}
	}

	вернуть ЕДИНИЦЫ[ilen - 1];
}

/**
 * Выясняет, в каких единицах форматировать набор делений
 */
функция determineUnitForFormatting(тики, minUnit, мин, макс) {
	var продолжительность = момент.продолжительность(момент(макс).разница(момент(мин)));
	var ilen = ЕДИНИЦЫ.длина;
	вар i, единица;

	для (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
		единица = ЕДИНИЦЫ[i];
		если (ИНТЕРВАЛЫ[единица].общий && длительность.как(единица) >= тики.длина) {
			возвратный блок;
		}
	}

	вернуть UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}

функция determineMajorUnit(единица) {
	для (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
		если (ИНТЕРВАЛЫ[ЕДИНИЦЫ[i]].общий) {
			вернуть ЕДИНИЦЫ[i];
		}
	}
}

/**
 * Генерирует максимальное количество временных меток «емкости» между минимальным и максимальным значением, округленное до
 * `второстепенная` единица, выровненная по `главной` единице и использующая заданные `опции` масштабного времени.
 * Важно: этот метод может возвращать тики за пределами минимального и максимального диапазона, это
 * ответственность вызывающего кода за фиксацию значений при необходимости.
 */
функция генерации(мин, макс, емкость, параметры) {
	var timeOpts = параметры.время;
	var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
	вар майор = defineMajorUnit (минор);
	var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
	var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
	var majorTicksEnabled = options.ticks.major.enabled;
	вар интервал = ИНТЕРВАЛЫ [минор];
	var first = момент(мин);
	var last = момент(макс);
	var тики = [];
	переменное время;

	если (!stepSize) {
		stepSize = determineStepSize(мин, макс, минор, емкость);
	}

	// Для единицы измерения «неделя» обработайте опцию первого дня недели
	если (будний день) {
		первый = первый.isoWeekday(день недели);
		последний = последний.isoWeekday(день недели);
	}

	// Выровнять первый/последний такты на единице
	first = first.startOf(день недели ? 'день' : второстепенный);
	последний = последний.startOf(день недели ? 'день' : минор);

	// Убедитесь, что последний тик включает макс.
	если (последний < макс) {
		последний.добавить(1, минор);
	}

	время = момент(первый);

	если (majorTicksEnabled && major && !weekday && !timeOpts.round) {
		// Выровнять первую отметку по предыдущей единице `minor`, ​​выровненной по единице `major`:
		// сначала мы выровняли время по предыдущему `основному` блоку, затем добавили количество полных
		// stepSize находится между первым и предыдущим основным временем.
		время.начало(основное);
		время.добавить(~~((первое - время) / (интервал.размер * размер шага)) * размер шага, минор);
	}

	для (; время < последнее; время.add(stepSize, minor)) {
		тики.push(+время);
	}

	тики.push(+время);

	возврат клещей;
}

/**
 * Возвращает смещения вправо и влево от краев в виде {влево, вправо}.
 * Смещения добавляются, если опция `offset` имеет значение true.
 */
функция computeOffsets(таблица, такты, мин, макс, параметры) {
	переменная левая = 0;
	переменная справа = 0;
	вар верхний, нижний;

	если (параметры.смещение && такты.длина) {
		если (!options.time.min) {
			верхняя = ticks.length > 1 ? ticks[1] : max;
			нижний = тики[0];
			слева = (
				интерполировать(таблица, 'время', верхняя, 'поз') -
				интерполировать(таблица, 'время', нижняя, 'поз')
			) / 2;
		}
		если (!options.time.max) {
			верхний = такты[такты.длина - 1];
			нижняя = длина.тиков > 1 ? тики[длина.тиков - 2] : мин;
			правильно = (
				интерполировать(таблица, 'время', верхняя, 'поз') -
				интерполировать(таблица, 'время', нижняя, 'поз')
			) / 2;
		}
	}

	вернуть {слева: слева, справа: справа};
}

функция ticksFromTimestamps(значения, majorUnit) {
	var тики = [];
	var i, ilen, значение, мажор;

	для (i = 0, ilen = значения.длина; i < ilen; ++i) {
		значение = значения[i];
		майор = майорЮнит? значение === +moment(value).startOf(majorUnit) : false;

		тики.push({
			значение: значение,
			майор: майор
		});
	}

	возврат клещей;
}

функция determineLabelFormat(data, timeOpts) {
	var i, momentDate, hasTime;
	var ilen = data.length;

	// найти метку с наибольшим количеством частей (миллисекунд, минут и т. д.)
	// форматировать все метки с тем же уровнем детализации, что и самая конкретная метка
	для (i = 0; i < ilen; i++) {
		momentDate = momentify(data[i], timeOpts);
		если (momentDate.millisecond() !== 0) {
			вернуть 'МММ Д, ГГГГ ч:мм:сс.ССС а';
		}
		если (momentDate.second() !== 0 || momentDate.minute() !== 0 || momentDate.hour() !== 0) {
			hasTime = правда;
		}
	}
	если (естьВремя) {
		вернуть 'МММ Д, ГГГГ ч:мм:сс а';
	}
	вернуть 'МММ Д, ГГГГ';
}

модуль.экспорты = функция(Диаграмма) {

	var defaultConfig = {
		положение: «внизу»,

		/**
		 * Распределение данных по шкале:
		 * - «линейный»: данные распределены по времени (расстояния могут меняться),
		 * - «серия»: данные разбросаны на одинаковом расстоянии друг от друга.
		 * @см. https://github.com/chartjs/Chart.js/pull/4507
		 * @с версии 2.7.0
		 */
		распределение: «линейное»,

		/**
		 * Стратегия масштабирования границ (обходится опциями минимального/максимального времени)
		 * - `data`: убедитесь, что данные полностью видны, галочки за пределами убраны
		 * - `галочки`: убедитесь, что галочки полностью видны, данные за пределами обрезаются
		 * @см. https://github.com/chartjs/Chart.js/pull/4556
		 * @с версии 2.7.0
		 */
		границы: «данные»,

		время: {
			parser: false, // false == строка шаблона из http://momentjs.com/docs/#/parsing/string-format/ или пользовательский обратный вызов, который преобразует свой аргумент в момент
			формат: false, // УСТАРЕВШЕЕ значение false == объекты даты, объект момента, обратный вызов или строка шаблона из http://momentjs.com/docs/#/parsing/string-format/
			единица измерения: false, // false == автоматически или переопределяется неделей, месяцем, годом и т. д.
			округление: false, // none или переопределение с неделей, месяцем, годом и т. д.
			displayFormat: false, // УСТАРЕВШИЙ
			isoWeekday: false, // переопределить день начала недели - см. http://momentjs.com/docs/#/get-set/iso-weekday/
			minUnit: 'миллисекунда',

			// по умолчанию используется соответствующий unitFormat единицы измерения ниже или переопределяется с помощью шаблонной строки из http://momentjs.com/docs/#/displaying/format/
			Форматы отображения: {
				миллисекунда: 'ч:мм:сс.ССС а', // 11:20:01.123 AM,
				второй: 'ч:мм:сс а', // 11:20:01 AM
				минута: 'ч:мм а', // 11:20 AM
				час: 'hA', // 5PM
				день: 'MMM D', // 4 сен
				неделя: 'll', // Неделя 46, или может быть "[W]WW - YYYY" ?
				месяц: «МММ ГГГГ», // Сентябрь 2015 г.
				квартал: '[Q]Q - YYYY', // Q3
				год: 'ГГГГ' // 2015
			},
		},
		тики: {
			автопропуск: ложь,

			/**
			 * Входные значения генерации тактов:
			 * - «авто»: генерирует «оптимальные» тики на основе размера шкалы и параметров времени.
			 * - 'data': генерирует отметки из данных (включая метки из объектов данных {t|x|y}).
			 * - 'labels': генерирует отметки ТОЛЬКО на основе значений `data.labels`, заданных пользователем.
			 * @см. https://github.com/chartjs/Chart.js/pull/4507
			 * @с версии 2.7.0
			 */
			источник: 'авто',

			главный: {
				включено: ложно
			}
		}
	};

	var TimeScale = Chart.Scale.extend({
		инициализировать: функция() {
			если (!момент) {
				throw new Error('Chart.js - Moment.js не найден! Вы должны включить его перед Chart.js, чтобы использовать шкалу времени. Загрузите по адресу https://momentjs.com');
			}

			this.mergeTicksOptions();

			Chart.Scale.prototype.initialize.call(this);
		},

		обновление: функция() {
			var me = это;
			var options = me.options;

			// УСТАРЕВШИЕ: выводить сообщение только один раз за обновление
			если (опции.время && опции.время.формат) {
				console.warn('options.time.format устарел и заменен на options.time.parser.');
			}

			вернуть Chart.Scale.prototype.update.apply(me, arguments);
		},

		/**
		 * Позволяет ссылаться на данные через атрибут «t»
		 */
		getRightValue: функция (rawValue) {
			если (rawValue && rawValue.t !== не определено) {
				rawValue = rawValue.t;
			}
			вернуть Chart.Scale.prototype.getRightValue.call(this, rawValue);
		},

		defineDataLimits: функция() {
			var me = это;
			var chart = я.диаграмма;
			var timeOpts = me.options.time;
			var unit = timeOpts.unit || 'день';
			var min = MAX_INTEGER;
			var max = MIN_INTEGER;
			var временные метки = [];
			var datasets = [];
			var метки = [];
			вар я, j, ilen, jlen, данные, метка времени;

			// Преобразуем метки в временные метки
			для (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {
				labels.push(parse(chart.data.labels[i], me));
			}

			// Преобразуем данные в метки времени
			for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
				если (chart.isDatasetVisible(i)) {
					данные = chart.data.datasets[i].data;

					// Будем считать, что все данные имеют одинаковый формат.
					если (helpers.isObject(data[0])) {
						наборы данных[i] = [];

						for (j = 0, jlen = data.length; j < jlen; ++j) {
							временная метка = parse(data[j], me);
							временные метки.push(временная метка);
							наборы данных[i][j] = временная метка;
						}
					} еще {
						timestamps.push.apply(временные метки, метки);
						наборы данных[i] = метки.срез(0);
					}
				} еще {
					наборы данных[i] = [];
				}
			}

			если (метки.длина) {
				// Сортировать метки **после** преобразования данных
				labels = arrayUnique(метки).sort(сортировщик);
				мин = Математика.мин(мин, метки[0]);
				макс = Математика.макс(макс, метки[метки.длина - 1]);
			}

			если (временные метки.длина) {
				timestamps = arrayUnique(timestamps).sort(sorter);
				min = Math.min(min, timestamps[0]);
				макс = Math.max(макс, временные метки[временные метки.длина - 1]);
			}

			min = parse(timeOpts.min, me) || min;
			макс = parse(timeOpts.макс, я) || макс;

			// В случае отсутствия допустимых значений мин/макс, установите ограничения на основе параметра единицы времени
			мин = мин === MAX_INTEGER ? +moment().startOf(единица измерения): мин;
			макс = макс === MIN_INTEGER ? +moment().endOf(unit) + 1 : макс;

			// Убедитесь, что max строго больше min (требуется таблицей поиска)
			я.мин = Матем.мин(мин, макс);
			я.макс = Матем.макс(мин + 1, макс);

			// ЧАСТНЫЙ
			я._горизонтальный = я.являетсягоризонтальным();
			я._таблица = [];
			я._временные_метки = {
				данные: временные метки,
				наборы данных: наборы данных,
				метки: метки
			};
		},

		buildTicks: функция() {
			var me = это;
			var min = me.min;
			var max = me.max;
			var options = me.options;
			var timeOpts = параметры.время;
			var временные метки = [];
			var тики = [];
			var i, ilen, временная метка;

			переключатель (options.ticks.source) {
			случай «данные»:
				временные метки = я._временные метки.данные;
				перерыв;
			случай «метки»:
				временные метки = я._временные метки.метки;
				перерыв;
			случай «авто»:
			по умолчанию:
				временные метки = generate(min, max, me.getLabelCapacity(min), options);
			}

			если (options.bounds === 'ticks' && timestamps.length) {
				мин = временные метки[0];
				макс = временные метки[временные метки.длина - 1];
			}

			// Принудительное применение ограничений с помощью пользовательских опций min/max
			min = parse(timeOpts.min, me) || min;
			макс = parse(timeOpts.макс, я) || макс;

			// Удалить отметки за пределами диапазона мин/макс
			для (i = 0, ilen = timestamps.length; i < ilen; ++i) {
				метка времени = метки времени[i];
				если (временная метка >= мин. && временная метка <= макс.) {
					ticks.push(отметка времени);
				}
			}

			я.мин = мин;
			я.макс = макс;

			// ЧАСТНЫЙ
			me._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);
			я._основная_единица = determineMajorUnit(я._единица);
			me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
			me._offsets = computeOffsets(me._table, ticks, min, max, options);
			me._labelFormat = determineLabelFormat(me._timestamps.data, timeOpts);

			вернуть ticksFromTimestamps(ticks, me._majorUnit);
		},

		getLabelForIndex: функция(индекс, datasetIndex) {
			var me = это;
			var data = me.chart.data;
			var timeOpts = me.options.time;
			var label = data.labels && index < data.labels.length ? data.labels[index] : '';
			var value = data.datasets[индекс_набора_данных].data[индекс];

			если (helpers.isObject(значение)) {
				метка = me.getRightValue(значение);
			}
			если (timeOpts.tooltipFormat) {
				return momentify(label, timeOpts).format(timeOpts.tooltipFormat);
			}
			если (тип метки === 'строка') {
				этикетка возврата;
			}

			return momentify(label, timeOpts).format(me._labelFormat);
		},

		/**
		 * Функция форматирования отдельной отметки
		 * @частный
		 */
		tickFormatFunction: функция (тик, индекс, тики, formatOverride) {
			var me = это;
			var options = me.options;
			var время = tick.valueOf();
			var formats = options.time.displayFormats;
			вар minorFormat = форматы [me._unit];
			вар majorUnit = me._majorUnit;
			вар majorFormat = форматы [majorUnit];
			вар majorTime =ick.clone().startOf(majorUnit).valueOf();
			var majorTickOpts = options.ticks.major;
			var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
			var label =ick.format(formatOverride? formatOverride: Major? MajorFormat: MinorFormat);
			var tickOpts = major ? majorTickOpts : options.ticks.minor;
			var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);

			вернуть форматтер? formatter(метка, индекс, отметки) : метка;
		},

		convertTicksToLabels: функция(тики) {
			var метки = [];
			вар i, илен;

			для (i = 0, ilen = ticks.length; i < ilen; ++i) {
				labels.push(this.tickFormatFunction(moment(тики[i].value), i, тики));
			}

			этикетки возврата;
		},

		/**
		 * @частный
		 */
		getPixelForOffset: функция(время) {
			var me = это;
			var size = me._horizontal ? me.width : me.height;
			var start = me._horizontal ? me.left : me.top;
			var pos = interpolate(me._table, 'время', время, 'pos');

			вернуть начало + размер * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
		},

		getPixelForValue: функция(значение, индекс, datasetIndex) {
			var me = это;
			переменная времени = null;

			если (индекс !== не определено && datasetIndex !== не определено) {
				время = me._timestamps.datasets[индекс_набора_данных][индекс];
			}

			если (время === ноль) {
				время = parse(значение, я);
			}

			если (время !== null) {
				вернуть меня.getPixelForOffset(время);
			}
		},

		getPixelForTick: функция(индекс) {
			var ticks = this.getTicks();
			вернуть индекс >= 0 && индекс < ticks.length ?
				this.getPixelForOffset(тики[индекс].значение) :
				нулевой;
		},

		получитьЗначениеДляПикселя: функция(пиксель) {
			var me = это;
			var size = me._horizontal ? me.width : me.height;
			var start = me._horizontal ? me.left : me.top;
			var pos = (размер ? (пиксель - начало) / размер : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
			var time = interpolate(me._table, 'pos', pos, 'time');

			момент возврата(время);
		},

		/**
		 * Грубое приближение возможной ширины этикетки
		 * @частный
		 */
		getLabelWidth: функция(метка) {
			var me = это;
			var ticksOpts = me.options.ticks;
			var tickLabelWidth = me.ctx.measureText(метка).ширина;
			var angle = helpers.toRadians(ticksOpts.maxRotation);
			var cosRotation = Math.cos(угол);
			вар sinRotation = Math.sin(угол);
			var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);

			вернуть (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
		},

		/**
		 * @частный
		 */
		getLabelCapacity: функция(exampleTime) {
			var me = это;

			var formatOverride = me.options.time.displayFormats.millisecond; // Выберите самый длинный формат для гостевой имитации

			var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);
			var tickLabelWidth = me.getLabelWidth(exampleLabel);
			var innerWidth = me.isHorizontal() ? me.width : me.height;

			var capacity = Math.floor(innerWidth / tickLabelWidth);
			обратная емкость > 0 ? емкость : 1;
		}
	});

	Chart.scaleService.registerScaleType('время', TimeScale, defaultConfig);
};

},{"1":1,"25":25,"45":45}]},{},[7])(7)
});